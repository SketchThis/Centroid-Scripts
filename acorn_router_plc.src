;------------------------------------------------------------------------------
; File:        acorn_universal_template.src
; Programmers: Mario Lopes, Freddy McGarry, Milton McDonald, Scott Pratt, Christopher Bowser, Dyllan Kobal
; Date:        13 Nov 2018
; Purpose:     PLC Mill & Lathe Template for ACORN BOARD
; Requires:    Requires CNC12
;
; Mods:         09 Mar 2023 CTB Added SV_PLC_DISABLE_TRAVEL_LIMITS logic, allowing
;                               PLC to disable software travel limits when SET.
;               15 Feb 2023 CTB Added Parameter 19 WMPG Z Axis X100 Lockout
;               20 Jan 2023 CTB Modified LaserAlignActivate Logic
;                               Laser VCP button should now always turn on/off laser output, will override Mcode request.
;               01 Jan 2023 CTB Added C-Axis Logic
;               09 Dec 2022 CTB Added Spindle Fan Off Delay Timer Parameter 977.
;               09 Nov 2022 CTB Added Feedrate Override 70, 50, 20 Skin Events.
;               15 Jun 2022 CTB Added Support for WMPG-4 Plasma
;               03 Jun 2022 CTB Added SpindleOK Fault Timer to Parameter 996
;                               Modified PairedHomeTripped Logic to include Individual Home Inputs.
;               31 May 2022 CTB Added diagonal Jog Skin Events 107-110 for Axis 1 and Axis 2. 
;               05 May 2022 CTB Added Ohmic Sensor Logic
;               20 Apr 2022 CTB Added SlavedAxisDriveOk as an option
;               21 Feb 2022 CTB Added ability for Traverse to disable Breakaway condition temporarily using SkinBreakawayDisable_M
;               07 Feb 2022 CTB Reworked P523 to include THC, Dryrun, and other Plasma Settings. Added Mem 730-735 for Bits.
;               24 Jan 2022 CTB Added SV_THC_ENCODER_STATUS for error reporting of encoder cable from THC_RX Board.
;               11 Jan 2022 CTB Added ButtonPressed Memory Bits for restart feature related buttons with 200s timer.
;                               Allows time for the Skinning API to react to user input on VCP.	  		
;               07 Jan 2022 CTB Added TorchArcOk Input for use with external Arc Ok Signals. When used will ignore PLC's "Arc Ok".
;               08 Dec 2021 CTB Added SkinTorchRestartForward_M and SkinTorchRestartBackward_M for Forward/Backward in cut feature.
;                               Moved SkinTorchRestartFire_M from Skin Event 91 to 101, will most likely become obsolete.
;				12 Nov 2021 CTB Breakaway now clears fault after E-Stop Cycle, To allow jogging of Z-Axis in Positive Direction to clear.
;				09 Nov 2021 CTB Added Torch Restart Functions
;				03 Nov 2021 CTB Prohibit Anti-Dive if Voltage Override has recently changed.
;				02 Nov 2021 CTB Added Plasma Voltage Override Functionality
;				24 Sep 2021 CTB Added Plasma Voltage Calibration Functionality.
;				19 Aug 2021 CTB Added Plasma Related Code.
;				09 Jun 2021 CTB Added Initial "Universal" ATC Logic. Additional files from Forums still required however.
;				02 Jun 2021 CTB Added DoorFeedHold_M to DoFeedHold logic to prevent delayed feedhold when job is started and door is open.
;				26 Mar 2021 CTB Fixed issue with M37 disabling "DoSpindleStop" disallowing the use of M3 and M5 to
;								turn on/off laser.
;				12 Jan 2021 CTB Reworked RPM Sensor, Now goes by time between seen input to calculate RPM.
;								Added Initalize_T to Probe Save Jog mode to prevent Fast/Slow jog issues on Startup.
;				14 Dec 2020 CTB Added RPM_Sensor, Averages Counts per Half Second. Uses Fast Stage for Counts.+
;				17 NOV 2020 CTB Reworked Chuck and Collet Logic. Collet Now works with M10/M11 and ChuckFootPedal_I
;				05 OCT 2020 CTB ChuckFootPedal_I to Open/Close Chuck added.
;				31 AUG 2020 CTB Logic Changes for Laser Enable
;				21 AUG 2020 CTB Added LaserEnable, PWMSelect, and LaserReset for J-TECH Laser.
;				29 Jul 2020 CTB Reworked DoAux5Key for when Backgear is used,
;								Added Parameter 419 for PLC features, Disable Worklight on startup and Popuppins Cycle start Feature.
;				27 Jul 2020 DK 	Add Enter key's SV_PC_KEYBOARD_KEY and allow enter key to be cycle start button		
;               22 Jun 2020 CTB Moved Configurable IO Section to beginning of Main Stage.
;       		20 Apr 2020 CTB Limited Dryrun to be toggled only when not running job or not in MDI.
;				09 Apr 2020 CTB Added Generic M94M95 111-126 for Outputs
;								Added Parameter 890 to disable blinking of Stack Lights
;				03 Apr 2020 CTB Added Disable Memory bits to Probe and TT Detect Logic.
;				27 Mar 2020 CTB Reworked Spindle Inhibit for Probe and TT Detect.
;				13 Mar 2020 CTB Reworked Reset Button Logic
;				11 Mar 2020 CTB Added Initialize_T Logic for Ether1616 and OUT1-8 to prevent "twitching outputs" during start up.
;				09 Mar 2020 CTB Reworked Logic for DustCollectionOn, LaserAlignActivate, and DustFootActivate to fix issues related with M94/M95 commands and VCP2.0 Buttons.
;								Incremented INP for Aux13-16 by 1 to match OUTs, removed conflicting memory bits.
;				28 Feb 2020 CTB Added Light Stack Logic for Green,Amber, and Red Lights.
;								Moved Rapid Over from Aux4 to dedicated Skin Event (82)
;				25 Feb 2020 CTB Added SafetyDoorLockOpen_O and SafetyDoorLockConfirmed_I for locking the door.
;				14 Feb 2020 DK 	Added DryRun_M, DryRunLED, and DryRunPD
;       		07 Feb 2020 CTB Added ColletOpenClose and AirBlowNozzle, added skinevents for vcp2.0
;								Created Skin events for Spindle Range and Brake keys to allow aux keys
;								to be assigned via vcp 2.0
;				04 Feb 2020 CTB Added Additional LED Outs and SkinEvents for VCP 2.0
;				23 Jan 2020 CTB Added VacOn VCP Key Functionality, Fixed Worklight LED on Startup
;				23 Jan 2020 DK  Updated ResetOK logic so user cant use the reset button is estop tripped. Also if reset is tripped then estop is tripped reset will clear.
;       		21 Jan 2020 CTB Added DriveFaultTimer to Individual Axes
;       		03 Jan 2020 DK  Added Aux13-16Keys, Aux13-16LED, Aux13-16Out, KbAux13-16Key, SkinAux15-18_M, DoAux13-16Key, AuxPD13-16 for new VCP
;				19 Nov 2019 CTB Changed SafetyDoorInterlock Parameter 85 to 985
;				31 OCT 2019 CTB Fixed Fault happening after issuing m15 then shortly after before fault timer issuing M16
;				17 OCT 2019 CTB Added SpindleTemp and AirPressure Warning Messages with 2 inputs options for each.
;				16 OCT 2019 CTB Added External ToolUnclampButton Input, VFDZeroSpeed and UpToSpeed.
;								Also Added Router DustCollection and VacuumHoldDown, Replaces Flood and Mist.
;								Added a ManualLubePump_SV to enable lubepump operation with macros
;								Added DustFootActivate, LaserAlignActivate, PopUpPins, SpindleCooling Outputs
;				14 OCT 2019 CTB Added Individual Drive Fault Logic, Added Lube Warning during Job.
;								Remapped some macros and Fixed problem causing fast jog when safetydoor was opened.
;				11 OCT 2019 CTB Reworked LimitOverride Logic allowing limits to be defeated on Ether1616
;				10 OCT 2019 CTB Added Ether1616 "ALIVE" Logic and Error Messages, Added TailStockInOut and
;								Temporarily removed VacuumOn macro M33.
;				09 OCT 2019 CTB Added External Inputs for Cyclestart, CycleCancel, FeedHold,
;								ToolCheck and added PLC message for when probe trip is cleared
;				26 Sep 2019 CTB Fixed Issue related with Probe Protection while jogging
;				05 Sep 2019 CTB Fixed Constant slowjog issue related with code added by SafetyDoorInterlock
;				22 Aug 2019 CTB Fixed UnClampTool not reseting when m16 was issued
;				15 Apr 2019 MML Updated ChuckTimer logic as it was never being set
;				29 Mar 2019 MML Added AUX10PD - AUX12PD
;				13 Mar 2019 MML Added ToolUnclamp and OrientSpindle logic
;				27 Feb 2019 JTT Added Logic to add Warning when probe tripped while handwheel jogging
;				26 Feb 2019 JTT Changed behaviour of Jog +/jog- on MPG to be in incremental mode
;								when set to 1X.
;				08 Feb 2019 MML Updated Spin Brake VCP button logic
;				31 Jan 2019 MML Updated SpindleBrakeRelease logic as it wouldn't turn off
;								when M5 was issued
;				08 Jan 2019 MML Added same protection for ProbeTripped to
;								ToolTouchOffTriggered
;				02 Jan 2019 MML Red button on wireless MPG behaves like Cycle Cancel,
;								AUX7LED logic mirrors SpindleBrakeRelease state, M35
;								clears when program/MDI stopped.
;				26 Nov 2018 MML Added ProbeDetect logic in conjunction w/ ProbeTripped
;				02 Nov 2018 MML Made it so switching from Fast/Slow or Inc/Cont will
;								only happen when in ALT+J mode
;				01 Nov 2018 FM  Changed ToolTouchOff to ToolTouchOffTriggered
;				24 Oct 2018 FM  Removed VCPinit logic to allow the VCP and MPG to
;								create the red "Reset is enabled" message in CN12.
;				24 Oct 2018 MM  Wait on Cycle Start before starting spindle when
;								auto spindle is pressed.
;				15 Oct 2018 MML Added logic to handle NO probe signals
;				01 Jun 2018 KD  Converted VCP to Skinning 2.0
;				24 Apr 2018 RSP Fixed Z axis shuttle jogging
;				19 Apr 2018 RSP Added Shuttle support
;				18 Apr 2018 RSP Removed mpg spinover buttons
;				18 Apr 2018 RSP Fixed Reset/Estop bug
;				24 Mar 2018 RSP Added HomeLimitMem
;				20 Mar 2018 RSP Added ToolTouchOff
;				20 Mar 2018 RSP Added LimitAll. Reworked FastSlowLED logic w/usbmpg
;				15 MAR 2018 RSP Added HomeAll
;				23 Feb 2018 RSP Fixed problem in clearing reset when using mpg
;				21 FEB Added step rate definitions to p968 comments
;				16 Feb 2018 RSP Added Reset, auto/inc, mpg x1, x10, x100 led support
;								paired axis homing & windup disable above x1 etc..
;				20 Jan 2018 RAM Added Wireless MPG support
;				13 Dec 2017 RSP Added parms 831-846 for tool turret position
;								definitions when using absolute turret position sensors
;								15 Nov 2017 RSP Added ATC functions, AuxKeyOutputs
;								moved all "output" membits to 300's, all "input" membits are now
;								in 200's. Existing 300 range membits moved to 500's
;
;------------------------------------------------------------------------------

;Parameters:
;SV_MACHINE_PARAMETER_1 is used to determine axis jog layout
;SV_MACHINE_PARAMETER_6 is ATC on/off. 1 = ATC on, 0 = ATC off.
;SV_MACHINE_PARAMETER_19 = MPG Modes
;                          Add 1 = MPG Ignore Encoder Error
;                          Add 2 = MPG Z-Axis X100 Lockout
;                          Add 4 = MPG Independent Z-Axis Jogging Enabled
;SV_MACHINE_PARAMETER_153 is ProbeProtectionEnable for VCP. 1 = VCP Jog Moves are protected, 0 = VCP Jog Moves not Protected
;SV_MACHINE_PARAMETER_218 if non-zero value, start UsbMpg Pipe client with CNC12
;SV_MACHINE_PARAMETER_219 if non-zero value, start VCP with CNC12
;SV_MACHINE_PARAMETER_411 = MPG Type: CWP-4 = 0, WMPG-4 = 1, WMPG-4 Plasma = 2
;SV_MACHINE_PARAMETER_416 is Spindle Inhibit. 1 = Probe and TT, 2 = TT, 3 = Probe
;SV_MACHINE_PARAMETER_419 = PLC Feature bit for Inputs/OUTPUTS
;							Add 1 to Disable Worklight on Startup
;							Add 2 to Deactivate PopUpPins on CycleStart
;SV_MACHINE_PARAMETER_511 = THC Target Voltage
;SV_MACHINE_PARAMETER_512 = THC Maximum Offset Accel
;SV_MACHINE_PARAMETER_513 = THC Maximum Offset Velocity
;SV_MACHINE_PARAMETER_514 = THC Maximum Offset
;SV_MACHINE_PARAMETER_515 = THC Minimum Offset
;SV_MACHINE_PARAMETER_516 = THC Voltage Error Level
;SV_MACHINE_PARAMETER_517 = THC Voltage Max Consecutive Errors
;SV_MACHINE_PARAMETER_518 = THC Plasma Voltage Divider Ratio
;SV_MACHINE_PARAMETER_519 = THC Active Timer
;SV_MACHINE_PARAMETER_520 = % Ratio Velocity to Enable THC
;SV_MACHINE_PARAMETER_521 = Desired Feedrate in Counts / Interrupt for Ratio Calculation in PLC
;SV_MACHINE_PARAMETER_522 = Torch Arc Ok Threshold in Counts
;SV_MACHINE_PARAMETER_523 = Add 1 = Automatic THC, Add 2 = AutoSense THC, Add 4 = Plasma Dry Run at Pierce, Add 8 = Dry Run at Cut Height, Add 16 = Use Float Head Switch, Add 32 = THC Not Installed
;SV_MACHINE_PARAMETER_525 = THC Voltage Factor
;SV_MACHINE_PARAMETER_526 = THC Pierce-Cut Z Feedrate
;SV_MACHINE_PARAMETER_527 = THC Z Kp
;SV_MACHINE_PARAMETER_528 = THC Z Ki
;SV_MACHINE_PARAMETER_529 = THC Z Kd
;SV_MACHINE_PARAMETER_530 = THC Z Il
;SV_MACHINE_PARAMETER_531 = Ohmic Offset
;SV_MACHINE_PARAMETER_800 = DB25 Enables pin mapping
;SV_MACHINE_PARAMETER_801 = DB25 remapping for pin 1
;SV_MACHINE_PARAMETER_802 = DB25 remapping for pin 2
;SV_MACHINE_PARAMETER_803 = DB25 remapping for pin 3
;SV_MACHINE_PARAMETER_804 = DB25 remapping for pin 4
;SV_MACHINE_PARAMETER_805 = DB25 remapping for pin 5
;SV_MACHINE_PARAMETER_806 = DB25 remapping for pin 6
;SV_MACHINE_PARAMETER_807 = DB25 remapping for pin 7
;SV_MACHINE_PARAMETER_808 = DB25 remapping for pin 8
;SV_MACHINE_PARAMETER_809 = DB25 remapping for pin 9
;SV_MACHINE_PARAMETER_810 = DB25 remapping for pin 10
;SV_MACHINE_PARAMETER_811 = DB25 remapping for pin 11
;SV_MACHINE_PARAMETER_812 = DB25 remapping for pin 12
;SV_MACHINE_PARAMETER_813 = DB25 Used for Header/Or screw terminal 1 = DB25
;SV_MACHINE_PARAMETER_814-819 available for use.
;SV_MACHINE_PARAMETER_820 = Mill = 0, Lathe = 1, Router = 2, Plasma = 3, Waterjet = 4, (future) etc...

;SV_MACHINE_PARAMETER_821 = Bitwise PLC inputs for paired axis homing.
; 3=INP1(Master) & INP2(paired). Negate if paired is first. etc...
; -3=INP1(paired) & INP2(master) = paired.

;SV_MACHINE_PARAMETER_822 = Input for HomeAll
;SV_MACHINE_PARAMETER_823 = Input for ZRI
;SV_MACHINE_PARAMETER_824 = Input for LimitAll
;SV_MACHINE_PARAMETER_825 = available

;SV_MACHINE_PARAMETER_826 = ToolTurretPosBit1 (1) or ToolCounter input#
;SV_MACHINE_PARAMETER_827 = ToolTurretPosBit2 (2) input#
;SV_MACHINE_PARAMETER_828 = ToolTurretPosBit3 (4) input#
;SV_MACHINE_PARAMETER_829 = ToolTurretPosBit4 (8) input#


;SV_MACHINE_PARAMETER_830 = ATC Type, 0 = none. 1 = Umbrella, 2 = Counter Turret,
;                           3 = Graycode 2 Output, 4 = Graycode 1 Output, 5 = Time Based Turret
;                           6 = Axis Based Turret, 7 = Rack Based Tool Changer
;
;For parms 831-846, For each closed sensor while at a particular turret
;position, add sensor values to obtain a decimal value to insert in the
;parameter for that turret position. ToolTurretPosBit1 +1, ToolTurretPosBit2 +2,
;ToolTurretPosBit3 +4, ToolTurretPosBit4 +8. example: If turret is at position 1 and
;ToolTurretPosBit1 and ToolTurretPosBit4 are closed (green), a value of 9 should be
;entered into parm 831.
;
;SV_MACHINE_PARAMETER_831 = Tool Turret Position 1
;SV_MACHINE_PARAMETER_832 = Tool Turret Position 2
;SV_MACHINE_PARAMETER_833 = Tool Turret Position 3
;SV_MACHINE_PARAMETER_834 = Tool Turret Position 4
;SV_MACHINE_PARAMETER_835 = Tool Turret Position 5
;SV_MACHINE_PARAMETER_836 = Tool Turret Position 6
;SV_MACHINE_PARAMETER_837 = Tool Turret Position 7
;SV_MACHINE_PARAMETER_838 = Tool Turret Position 8
;SV_MACHINE_PARAMETER_839 = Tool Turret Position 9
;SV_MACHINE_PARAMETER_840 = Tool Turret Position 10
;SV_MACHINE_PARAMETER_841 = Tool Turret Position 11
;SV_MACHINE_PARAMETER_842 = Tool Turret Position 12
;SV_MACHINE_PARAMETER_843 = Tool Turret Position 13
;SV_MACHINE_PARAMETER_844 = Tool Turret Position 14
;SV_MACHINE_PARAMETER_845 = Tool Turret Position 15
;SV_MACHINE_PARAMETER_846 = Tool Turret Position 16
;
;SV_MACHINE_PARAMETER_847 = TurretSettleTimer. Default = 750
;SV_MACHINE_PARAMETER_848 = TurretReverseTimer. Default = 1500
;
;SV_MACHINE_PARAMETER_849 = ToolChangeTimeOutTimer, default = 10 seconds

;SV_MACHINE_PARAMETER_855 = Mpg Performance, 0 = slow, 1 = balanced, 2 = quick
;SV_MACHINE_PARAMETER_856 = Default jog behavior on startup,
;0 = fast/incremental, 1 = fast/continuous,
;2 = slow/incremental, 3 = slow/continuous
;SV_MACHINE_PARAMETER_857 = Z Following options. 0 = Disabled, 1 Allow z jog
;keys to adjust Z offset, 2 = allow Z mpgbalanced, 3 = allow jog keys and mpg
;to adjust offset.
;
;;SV_MACHINE_PARAMETER_890 = Light Stack Settings, 0 = Blinks, 1 = Blink Disabled
;
; SV_MACHINE_PARAMETER_911 used to invert inps 1-16 during limit override function
; If limit override function is not active, it reverts to it reverts to inverting
; inputs based on the value stored in the parameter file.
;SV_MACHINE_PARAMETER_912 = Invert INP17-32 during Limit Override
;SV_MACHINE_PARAMETER_913 = Invert INP33-48 during Limit Override
;SV_MACHINE_PARAMETER_914 = Invert INP49-64 during Limit Override
;SV_MACHINE_PARAMETER_915 = Invert INP65-80 during Limit Override
;
;SV_MACHINE_PARAMETER_916-920 = Force Inputs 1-16, 17-32, 33-48, 49-64, or 65-80
;SV_MACHINE_PARAMETER_921-925 = Force OUTPUTS 1-16, 17-32, 33-48, 49-64, or 65-80 ON
;SV_MACHINE_PARAMETER_926-930 = Force OUTPUTS 1-16, 17-32, 33-48, 49-64, or 65-80 OFF
;SV_MACHINE_PARAMETER_931-940 = Used for MEM Bit Force On/Off
;
;SV_MACHINE_PARAMETER_941 = Inputs 1-16 set as limits for limit override function.
;If inp1 is defined as a limit then 941 = 2, if inp1 & inp2 are limits 941 = 6 etc..
;Wizard will only slave axis 4 to axis 1, 2 or 3 therefore only param 967 is effected
;by Wizard slaving. If user selects axis 4 to be slaved to axis AND axis 4 is to run
;in same direction as axis 1, 1 is entered in parm 941. To run axis 4 in opposite direction
;of axis 1, the wizard will enter a value of -1. A 2 slaves 4th to axis 2 etc... To slave
;1 to 4, a 4 would need to be entered into parm964 -this is NOT the same as slaving 4 to 1
;and can't be done in wizard.
;SV_MACHINE_PARAMETER_942 = Inputs 33-48 set as limits for limit override function.
;SV_MACHINE_PARAMETER_943 = Inputs 49-64 set as limits for limit override function.
;SV_MACHINE_PARAMETER_944 = Inputs 65-80 set as limits for limit override function.
;SV_MACHINE_PARAMETER_945 = Inputs 81-96 set as limits for limit override function.
;SV_MACHINE_PARAMETER_946 = Inputs 97-112 set as limits for limit override function.
;SV_MACHINE_PARAMETER_947 = Disable Worklight on Start
;
;SV_MACHINE_PARAMETER_960* = divider for charge pump freq (hz) 1,200,000 / parm960 = freq. if parm 960 = 96 12,500 hz
;SV_MACHINE_PARAMETER_961 = inversion for step/direction/enable
;SV_MACHINE_PARAMETER_962 = disable alt-j jog panel (use usb jog device) 0=disable, 1 enable, 2 = use shuttle

;SV_MACHINE_PARAMETER_967 = Axis Pairing Axis4 if = 2 then master is axis 2
;                           If -2 then paired axis is reversed relative to master

;SV_MACHINE_PARAMETER_968* Pulse/Step Frequency(Hz) = 0 = 200000, 1 = 1200000,
; 2 = 600000, 3 = 400000, 4 = 300000 5 = 240000, 6 = 200000, 12 =  100000,
; 30 = 40000, 60 =  20000, 100 = 12000

;SV_MACHINE_PARAMETER_985 = Acorn DoorSafetyswitch mode selections
;1 = Slowjog while door open, 2 = SV_STOP while door open

;SV_MACHINE_PARAMETER_990 = 0 THEN SpindleBrakeTimer = 250 (milliseconds)
;SV_MACHINE_PARAMETER_991 = DriveFaultTimer (in milliseconds)
;SV_MACHINE_PARAMETER_992 = ChuckTimer (in milliseconds)
;SV_MACHINE_PARAMETER_993 = SpindleLockTimer (in milliseconds)
;SV_MACHINE_PARAMETER_994 = PartChuteTimer (in milliseconds)
;SV_MACHINE_PARAMETER_995 = CutOffTimer (in milliseconds)
;SV_MACHINE_PARAMETER_996 = SpindleFaultTimer (in milliseconds)

;Inputs available
;----Limit----
;FirstAxisMinusLimitOk
;FirstAxisPlusLimitOk
;SecondAxisMinusLimitOk
;SecondAxisPlusLimitOk
;ThirdAxisMinusLimitOk
;ThirdAxisPlusLimitOk
;FourthAxisMinusLimitOk
;FourthAxisPlusLimitOk
;LimitAll
;----Home----
;FirstAxisHomeOk
;SecondAxisHomeOk
;ThirdAxisHomeOk
;FourthAxisHomeOk
;HomeAll
;SlavedHomeInput
;----HomeLimit----
;FirstAxisHomeLimitOk
;SecondAxisHomeLimitOk
;ThirdAxisHomeLimitOk
;FourthAxisHomeLimitOk
;----Probe----
;ProbeDetect
;ProbeTripped
;ToolTouchOffTriggered
;ToolTouchOffDetect
;----General Purpose----
;EStopOk
;DriveOk
;BackGear
;LubeOk
;SpindleOk
;SpindleLowRange			M41
;SpindleMedRange			M42
;SpindleHighRange			M43
;ChuckIsOpen
;ChuckIsClosed
;SpindleIsLocked				;Currently Not Selectable in Wizard
;CutOffIsDown
;PartChuteIsIn
;ToolIsUnclamped
;SpindleIsOriented
;SafetyDoorSwitchClosed_I
;CycleStart2
;FeedHold2
;CycleCancel2
;ToolCheck2
;Axis1DriveOk
;Axis2DriveOk
;Axis3DriveOk
;Axis4DriveOk
;ToolUnclampButton
;VFDZeroSpeed
;VFDUpToSpeed
;DrawBarReleased
;SpindleTempAlarmMessage
;SpindleTempAlarmStop
;AirPressureLowMessage
;AirPressureLowStop
;SlavedAxisDriveOk
;---Future ATC Implimentation----
;ToolTurretPosBit1
;ToolTurretPosBit2
;ToolTurretPosBit3
;ToolTurretPosBit4
;ToolTurretCounter
;ToolTurretSyncBit
;ToolTurretIsLocked
;ToolTurretIsUnlocked
;ToolIsClamped
;ToolTurretIsIn
;ToolTurretIsOut

;Outputs available
;----General Purpose----
;NoFaultOut
;LubePump
;SpindleBrakeRelease
;SpinFWD				M3, M5
;SpinREV				M4, M5
;DriveResetOut
;Flood					M8, M9
;RouterDustCollection	M8, M9
;Mist					M7, M9
;RouterVacuumHoldDown	M7, M9
;TurnClampOn        	M10, M11
;OpenChuck          	M10
;CloseChuck         	M11
;G540SpinRevOff
;G540SpinFwdOff
;VacuumOn				M27, M28
;DustCollectionOn   	M35, M36
;CutOff					M13, M14
;PartChute          	M22, M23
;Axis1BrakeRelease
;Axis2BrakeRelease
;Axis3BrakeRelease
;Axis4BrakeRelease
;ChargePump
;UnclampTool			M15, M16
;OrientSpindle			M19, M20
;VFDEnable_O			M3, M5
;VFDDirection_O			M4, M5
;VFDResetOut_O
;TailStockInOut			M32, M33
;ATCAirBlowActivate		M15, M16
;----Macroable Outputs----
;DustFootActivate
;LaserAlignActivate
;PopUpPins
;SpindleCooling
;OUTPUT1            	M61, M81
;OUTPUT2            	M62, M82
;OUTPUT3            	M63, M83
;OUTPUT4            	M64, M84
;OUTPUT5            	M65, M85
;OUTPUT6            	M66, M86
;OUTPUT7            	M67, M87
;OUTPUT8            	M68, M88
;WorkLight							;Currently Not Selectable in Wizard
;LaserEnable         M37, M38
;LockSpindle						;Currently Not Selectable in Wizard
;----ATC----
;RotateToolTurret
;ReverseToolTurret
;----AuxKeys----
;Aux1Out
;Aux2Out
;Aux3Out
;Aux4Out
;Aux5Out
;Aux6Out
;Aux7Out
;Aux8Out
;Aux9Out
;Aux10Out
;Aux11Out
;Aux12Out
;Aux13Out
;Aux14Out
;Aux15Out
;Aux16Out

;Available configurable aux keys
;AUX 1-16
;VAC ON
;Rapid Over
;SET XY0
;SET XZ0
;SET Z0
;SPIN LOW
;SPIN MED
;SPIN HIGH
;SPIN BRAKE
;RESET HOME
;DEFEAT LIMITS
;OPEN CHUCK
;CLOSE CHUCK
;PART CHUTE

;Axes 1&2 jog key selection is determined by whether mill or lathe software
;is running and setting of parameter 1

;StandardSpindleStage

;G540SpindleStage
;The Gecko G540 requires that the spindle outputs for Fwd and Rev are inverted
;------------------------------------------------------------------------------
;                        CONSTANT DEFINITIONS
;------------------------------------------------------------------------------
MIN_FROR_PCT                  IS 1 ; Minimum allowed feedrate override percentage

PLC_EXECUTOR_FLT_MSG          IS 257; (1+256*1)

SPINDLE_LOCK_TIMEOUT          IS 1025;(2+256*4)

RAPID_OVERRIDE_ENABLED        IS 1282;(2+256*5)
RAPID_OVERRIDE_DISABLED       IS 1538;(2+256*6)
CHUCK_TIMEOUT                 IS 1793;(1+256*7)
PART_CHUTE_TIMEOUT            IS 2049;(1+256*8)
CUT_OFF_TIMEOUT               IS 2305;(1+256*9)

ORIENT_TIMEOUT                IS 3585;(1+256*14)
TOOL_UNCLAMP_TIMEOUT          IS 3841;(1+256*15)

PLC_INFLT                     IS 5634;(2+256*22)
PLC_OUTFLT                    IS 5890;(2+256*23)
PLC_FLT_CLR                   IS 6146;(2+256*24)
AXIS1_DRIVE_FAULT_MSG		  IS 6401;(1+256*25)
AXIS2_DRIVE_FAULT_MSG		  IS 6657;(1+256*26)
AXIS3_DRIVE_FAULT_MSG		  IS 6913;(1+256*27)
AXIS4_DRIVE_FAULT_MSG		  IS 7169;(1+256*28)
AXIS5_DRIVE_FAULT_MSG		  IS 7425;(1+256*29)
SPINDLE_FAULT_MSG             IS 7681;(1+256*30)
DRIVE_FAULT_MSG               IS 7937;(1+256*31)

RESET_CLEARED                 IS 8194;(2+256*32)
RESET_DETECTED                IS 8449;(1+256*33)

PROBE_FAULT_MSG               IS 8705;(1+256*34)

KB_JOG_MSG                    IS 8962;(2+256*35)

LUBE_FAULT_MSG                IS 9217;(1+256*36)
PROBE_JOG_TRIP_MSG            IS 9474;(2+256*37)

MIN_SPEED_MSG                 IS 9730;(2+256*38)
SOFTWARE_EXIT_MSG             IS 9985;(1+256*39)

POWERUP_PROBE_TRIPPED_MSG     IS 10241;(1+256*40)
HANDWHEEL_PROBE_TRIPPED_MSG   IS 10497;(1+256*41)
PROBE_TRIP_CLEARED_MSG		  IS 10753;(1+256*42)

LUBE_WARNING_MSG			  IS 11009;(1+256*43)

DRAWBAR_RELEASED_MSG		  IS 11265;(1+256*44)
DRAWBAR_CLAMPED_MSG			  IS 11521;(1+256*45)
SPINDLETEMPALARM_MSG		  IS 11777;(1+256*46)
AIRPRESSURELOW_MSG			  IS 12033;(1+256*47)

AUTO_COOL_MSG                 IS 12802;(2+256*50)
MAN_COOL_MSG                  IS 13058;(2+256*51)
;                             IS 13314;(2+256*52)
AUTO_SPINDLE_PROMPT           IS 13570;(2+256*53)
AUTO_COOLANT_PROMPT           IS 13826;(2+256*54)

ETH1616_FAULT_MSG             IS 14081;(1+256*55)
ETH1616_CONFIGFAULT_MSG       IS 14337;(1+256*56)
;Spare                        IS 14592;(?+256*57)
;Spare                        IS 14848;(?+256*58)
;Spare                        IS 15104;(?+256*59)
SHUTTLE_AXIS1_SELECTED        IS 15362;(2+256*60)
SHUTTLE_AXIS2_SELECTED        IS 15618;(2+256*61)
SHUTTLE_AXIS3_SELECTED        IS 15874;(2+256*62)
SHUTTLE_AXIS4_SELECTED        IS 16130;(2+256*63)
JOG_INCREMENT_INCREASED       IS 16386;(2+256*64)
JOG_INCREMENT_DECREASED       IS 16642;(2+256*65)
SHUTTLE_DISABLED              IS 16898;(2+256*66)
FAST_JOG_SELECTED             IS 17154;(2+256*67)
SLOW_JOG_SELECTED             IS 17410;(2+256*68)
CONTINUOUS_SELECTED           IS 17666;(2+256*69)
INCREMENTAL_SELECTED          IS 17922;(2+256*70)
PLEASE_SELECT_AN_AXIS         IS 18178;(2?+256*71)
RESET2_DETECTED               IS 18434;(2+256*72)
PRESS_ALT_J_TO_ENABLE_USB_JOGGING	IS 18690;(2+256*73)

TTO_JOG_TRIP_MSG			  IS 18946;(2+256*74)
POWERUP_TTO_TRIPPED_MSG		  IS 19201;(1+256*75)
HANDWHEEL_TTO_TRIPPED_MSG	  IS 19457;(1+256*76)
TTO_TRIP_CLEARED_MSG		  IS 19713;(1+256*77)
TORCH_TIP_TRIPPED_MSG		  IS 19970;(2+256*78)
TORCH_TIP_CLEARED_MSG		  IS 20225;(1+256*79)

DOOR_NOT_CLOSED				  IS 20482;(2+256*80)
WAITING_FOR_DOOR_CLOSED		  IS 20738;(2+256*81)
DOOR_OPEN_SLOW_ONLY			  IS 20994;(2+256*82)
DOOR_CLOSED_FEED			  IS 21250;(2+256*83)
DOOR_CLOSED_SHUTDOWN		  IS 21506;(2+256*84)
DOOR_OPEN					  IS 21762;(2+256*85)
DOOR_CLOSED					  IS 22018;(2+256*86)
DOOR_LOCK_FAULT				  IS 22274;(2+256*87)

TURRET_TIMEOUT_FAULT		  IS 23042;(2+256*90)
MANUAL_INDEX_WHILE_ATC_MSG	  IS 23298;(2+256*91)
ATC_WHILE_MANUAL_INDEX_MSG	  IS 23554;(2+256*92)
INVALID_TOOL_REQUEST		  IS 23810;(2+256*93)
CAROUSEL_IN_OUT_TIMEOUT_MSG	  IS 24066;(2+256*94)

MSG_CLEARED_MSG				  IS 25345;(1+256*99)
BAD_MESSAGE_MSG				  IS 25602;(2+256*100)

TORCH_BREAK_MSG               IS 25858;(2+256*101)
DIVE_DETECTED_MSG             IS 26114;(2+256*102)
TORCH_BREAK_ALLOW_MSG         IS 26370;(2+256*103)
TORCH_BREAK_CLEAR_MSG         IS 26626;(2+256*104)
THC_ENCODER_FAULT_MSG         IS 26881;(1+256*105)

;------------------------------------------------------------------------------
;                        INPUT DEFINITIONS
;               Closed = 1 (green)  Open = 0 (red)
;------------------------------------------------------------------------------

; DO NOT MODIFY (MM-DD-YYYY)
; #wizardregion Date
; Date: 03-09-2023
; #endregion

; DO NOT MODIFY
; #wizardregion Drive
; Drive Name:Bench Test 'DB25'
; #endregion

; DO NOT MODIFY
; #wizardregion Inputs
EStopOk    IS INP8
; #endregion

;Input 9 Dedicated to THC Board Torch Input
;Uses Index pulse on Encoder
TorchTipTouchOff_I		IS INP9

;------------------------------------------------------------------------------
; INP769 - INP784 encompass the MPU11 onboard input connections
; which are generally used for MPG and probing functions.
;------------------------------------------------------------------------------
DSPProbe                      IS INP770
ProbeAux                      IS INP772
MPG_Inc_X_1                   IS INP773
MPG_Inc_X_10                  IS INP774
MPG_Inc_X_100                 IS INP775
MPG_AXIS_1                    IS INP776
MPG_AXIS_2                    IS INP777
MPG_AXIS_3                    IS INP778
MPG_AXIS_4                    IS INP779
MPG_AXIS_5                    IS INP780
MPG_AXIS_6                    IS INP781
MPG_AXIS_7                    IS INP782
MPG_AXIS_8                    IS INP783

;------------------------------------------------------------------------------
; Jog panel are mapped to INP1057-INP1312. Alternatively,
; jog panel inputs can also be referenced as JPI1 through JPI256.
;------------------------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right

SpinOverPlusKey               IS INP1057  ; Row  1 Column 1
SpinAutoManKey                IS INP1058  ; Row  1 Column 2
Aux1Key                       IS INP1059  ; Row  1 Column 3
Aux2Key                       IS INP1060  ; Row  1 Column 4
Aux3Key                       IS INP1061  ; Row  1 Column 5

SpinOver100Key                IS INP1062  ; Row  2 Column 1
SpinCWKey                     IS INP1063  ; Row  2 Column 2
Aux4Key                       IS INP1064  ; Row  2 Column 3
Aux5Key                       IS INP1065  ; Row  2 Column 4
Aux6Key                       IS INP1066  ; Row  2 Column 5

SpinOverMinusKey              IS INP1067 ; Row  3 Column 1
SpinCCWKey                    IS INP1068 ; Row  3 Column 2
Aux7Key                       IS INP1069 ; Row  3 Column 3
Aux8Key                       IS INP1070 ; Row  3 Column 4
Aux9Key                       IS INP1071 ; Row  3 Column 5

SpinStopKey                   IS INP1072 ; Row  4 Column 1
SpinStartKey                  IS INP1073 ; Row  4 Column 2
Aux10Key                      IS INP1074 ; Row  4 Column 3
Aux11Key                      IS INP1075 ; Row  4 Column 4
Aux12Key                      IS INP1076 ; Row  4 Column 5

CoolAutoManKey                IS INP1077 ; Row  5 Column 1
CoolFloodKey                  IS INP1078 ; Row  5 Column 2
CoolMistKey                   IS INP1079 ; Row  5 Column 3
VacOnKey                      IS INP1080 ; Row  5 Column 4
LimitDefeatKey                IS INP1081 ; Row  5 Column 5

IncrContKey                   IS INP1082  ; Row  6 Column 1
x1JogKey                      IS INP1083  ; Row  6 Column 2
x10JogKey                     IS INP1084  ; Row  6 Column 3
x100JogKey                    IS INP1085  ; Row  6 Column 4
MPGKey                        IS INP1086  ; Row  6 Column 5

Ax4PlusJogKey                 IS INP1087  ; Row  7 Column 1
UnusedR7C2Key                 IS INP1088  ; Row  7 Column 2
Ax2PlusJogKey                 IS INP1089  ; Row  7 Column 3
UnusedR7C4Key                 IS INP1090  ; Row  7 Column 4
Ax3PlusJogKey                 IS INP1091  ; Row  7 Column 5

UnusedR8C1Key                 IS INP1092  ; Row  8 Column 1
Ax1MinusJogKey                IS INP1093  ; Row  8 Column 2
FastSlowKey                   IS INP1094  ; Row  8 Column 3
Ax1PlusJogKey                 IS INP1095  ; Row  8 Column 4
UnusedR8C5Key                 IS INP1096  ; Row  8 Column 5

Ax4MinusJogKey                IS INP1097  ; Row  9 Column 1
UnusedR9C2Key                 IS INP1098  ; Row  9 Column 2
Ax2MinusJogKey                IS INP1099  ; Row  9 Column 3
UnusedR9C4Key                 IS INP1100  ; Row  9 Column 4
Ax3MinusJogKey                IS INP1101  ; Row  9 Column 5

CycleCancelKey                IS INP1102  ; Row 10 Column 1
SingleBlockKey                IS INP1103  ; Row 10 Column 2
ToolCheckKey                  IS INP1104  ; Row 10 Column 3
FeedHoldKey                   IS INP1105  ; Row 10 Column 4
CycleStartKey                 IS INP1106  ; Row 10 Column 5

;Unused						  IS INP1107
Aux13Key                      IS INP1108
Aux14Key                      IS INP1109
Aux15Key                      IS INP1110
Aux16Key                      IS INP1111

;------------------------------------------------------------------------------
;                    Feedrate Override Knob
;------------------------------------------------------------------------------
JpFeedOrKnobBit0              IS INP1249
JpFeedOrKnobBit1              IS INP1250
JpFeedOrKnobBit2              IS INP1251
JpFeedOrKnobBit3              IS INP1252
JpFeedOrKnobBit4              IS INP1253
JpFeedOrKnobBit5              IS INP1254
JpFeedOrKnobBit6              IS INP1255
JpFeedOrKnobBit7              IS INP1256
JpFeedOrKnobBit8              IS INP1257 ; Current jog panels send first 8 bits
JpFeedOrKnobBit9              IS INP1258 ; unused
JpFeedOrKnobBit10             IS INP1259 ; unused
JpFeedOrKnobBit11             IS INP1260 ; unused
JpFeedOrKnobBit12             IS INP1261 ; unused
JpFeedOrKnobBit13             IS INP1262 ; unused
JpFeedOrKnobBit14             IS INP1263 ; unused
JpFeedOrKnobBit15             IS INP1264 ; unused

;------------------------------------------------------------------------------
;                   Output Definitions
;       Logic 1 = OUTPUT ON (Green), 0 = OUTPUT OFF (Red)
;------------------------------------------------------------------------------

; DO NOT MODIFY
; #wizardregion Outputs
OUTPUT1    IS OUT1
OUTPUT2    IS OUT2
OUTPUT3    IS OUT3
OUTPUT4    IS OUT4
OUTPUT5    IS OUT5
OUTPUT6    IS OUT6
OUTPUT7    IS OUT7
OUTPUT8    IS OUT8
; #endregion

;NOTE ALL OUTPUTS on DB25 and H10 are rated 50ma max. They are pulled to ground (24V)
;when turned on.

; These bits control the actual analog hardware output
; Output = 12bit (0-4095) 0-10VDC.
SpinAnalogOutBit0             IS OUT17
SpinAnalogOutBit1             IS OUT18
SpinAnalogOutBit2             IS OUT19
SpinAnalogOutBit3             IS OUT20
SpinAnalogOutBit4             IS OUT21
SpinAnalogOutBit5             IS OUT22
SpinAnalogOutBit6             IS OUT23
SpinAnalogOutBit7             IS OUT24
SpinAnalogOutBit8             IS OUT25
SpinAnalogOutBit9             IS OUT26
SpinAnalogOutBit10            IS OUT27
SpinAnalogOutBit11            IS OUT28

MPG_LED_OUT                   IS OUT769

;------------------------------------------------------------------------------
;              Jog Panel Output (LED) Definitions
;       Jog Panel LED's can be addressed as OUT1057 - OUT1312
;                              OR
;                         JPO1 - JPO256
;------------------------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right
;
SpinOverPlusLED               IS OUT1057; Row  1 Column 1
SpinAutoModeLED               IS OUT1058; Row  1 Column 2
Aux1LED                       IS OUT1059; Row  1 Column 3
Aux2LED                       IS OUT1060; Row  1 Column 4
Aux3LED                       IS OUT1061; Row  1 Column 5

SpinOver100LED                IS OUT1062; Row  2 Column 1
SpindleCWLED                  IS OUT1063; Row  2 Column 2
Aux4LED                       IS OUT1064; Row  2 Column 3
Aux5LED                       IS OUT1065; Row  2 Column 4
Aux6LED                       IS OUT1066; Row  2 Column 5

SpinOverMinusLED              IS OUT1067; Row  3 Column 1
SpindleCCWLED                 IS OUT1068; Row  3 Column 2
Aux7LED                       IS OUT1069; Row  3 Column 3
Aux8LED                       IS OUT1070; Row  3 Column 4
Aux9LED                       IS OUT1071; Row  3 Column 5

SpinStopLED                   IS OUT1072; Row  4 Column 1
SpinStartLED                  IS OUT1073; Row  4 Column 2
Aux10LED                      IS OUT1074; Row  4 Column 3
Aux11LED                      IS OUT1075; Row  4 Column 4
Aux12LED                      IS OUT1076; Row  4 Column 5

CoolAutoModeLED               IS OUT1077; Row  5 Column 1
CoolFloodLED                  IS OUT1078; Row  5 Column 2
CoolMistLED                   IS OUT1079; Row  5 Column 3
VacOnLED                      IS OUT1080; Row  5 Column 4
LimitDefeatLED                IS OUT1081; Row  5 Column 5

IncrContLED                   IS OUT1082 ; Row  6 Column 1
x1JogLED                      IS OUT1083 ; Row  6 Column 2
x10JogLED                     IS OUT1084 ; Row  6 Column 3
x100JogLED                    IS OUT1085 ; Row  6 Column 4
MPGLED                        IS OUT1086 ; Row  6 Column 5

Ax4PlusJogLED                 IS OUT1087 ; Row  7 Column 1
UnusedR7C2LED                 IS OUT1088 ; Row  7 Column 2
Ax2PlusJogLED                 IS OUT1089 ; Row  7 Column 3
UnusedR7C4LED                 IS OUT1090 ; Row  7 Column 4
Ax3PlusJogLED                 IS OUT1091 ; Row  7 Column 5

UnusedR8C1LED                 IS OUT1092 ; Row  8 Column 1
Ax1MinusJogLED                IS OUT1093 ; Row  8 Column 2
FastSlowLED                   IS OUT1094 ; Row  8 Column 3
Ax1PlusJogLED                 IS OUT1095 ; Row  8 Column 4
UnusedR8C5LED                 IS OUT1096 ; Row  8 Column 5

Ax4MinusJogLED                IS OUT1097 ; Row  9 Column 1
UnusedR9C2LED                 IS OUT1098 ; Row  9 Column 2
Ax2MinusJogLED                IS OUT1099 ; Row  9 Column 3
UnusedR9C4LED                 IS OUT1100 ; Row  9 Column 4
Ax3MinusJogLED                IS OUT1101 ; Row  9 Column 5

CycleCancelLED                IS OUT1102 ; Row 10 Column 1
SingleBlockLED                IS OUT1103 ; Row 10 Column 2
ToolCheckLED                  IS OUT1105 ; Row 10 Column 3
FeedHoldLED                   IS OUT1104 ; Row 10 Column 4

PairedAxesLED                 IS OUT1106
ResetOutput                   IS OUT1107
Aux13LED                      IS OUT1108
Aux14LED                      IS OUT1109
Aux15LED                      IS OUT1110
Aux16LED                      IS OUT1111

WorklightLED				  IS OUT1112
CloseChuckLED				  IS OUT1113
OpenChuckLED				  IS OUT1114
TailStockLED				  IS OUT1115

SpindleHighLED				  IS OUT1116
SpindleMedLED				  IS OUT1117
SpindleLowLED				  IS OUT1118
SpindleBrakeLED				  IS OUT1119

;LED for VCP 2.0
ManualLubeLED				  IS OUT1120
ClampOnLED					  IS OUT1121
DustCollectionLED			  IS OUT1122
CutoffLED					  IS OUT1123
PartChuteLED				  IS OUT1124
ToolUnclampLED			  	  IS OUT1125
DustFootLED				  	  IS OUT1126
LaserAlignLED			  	  IS OUT1127
PopUpPinsLED				  IS OUT1128
SpindleCoolingLED		  	  IS OUT1129
ColletOpenCloseLED			  IS OUT1130
AirBlowNozzleLED			  IS OUT1131
DryRunLED			          IS OUT1132
RapidOverLED				  IS OUT1133
THCAutoLED					  IS OUT1134
TorchRestartModeLED			  IS OUT1135
TorchTouchLED                 IS OUT1136
FeedOver100LED                IS OUT1137
FeedOver75LED                 IS OUT1138
FeedOver50LED                 IS OUT1139
FeedOver25LED                 IS OUT1140

;------------------------------------------------------------------------------
;                        Memory Bit Definitions
;------------------------------------------------------------------------------
;AtcPresent_M                  	IS MEM1
;AtcIsAbsolute_M               	IS MEM2
;AtcIsIncremental_M            	IS MEM3
;AtcReversesToLock_M           	IS MEM4
;AtcIsGang_M                   	IS MEM5
;AtcIsGrayCode3_M              	IS MEM6
;AtcIsGrayCode4_M              	IS MEM7
;AtcIsBidirectional_M          	IS MEM8
ValidMpgAxisSelected_M        	IS MEM9
ProbeNO_M                     	IS MEM10
TTNO_M                        	IS MEM11
ToolUnclampedState_M          	IS MEM12
SpindleOrientedState_M        	IS MEM13
SpindleZeroSpeedState_M			IS MEM14

DoorOpen_M					  	IS MEM20
DoorClosed_M				  	IS MEM21
DoorInterlockMode_M			  	IS MEM22
DoorInterlockShutdown_M		  	IS MEM23
DoorOpenSlowJog_M	  		  	IS MEM24
DoorShutDownStop_M			  	IS MEM25
DoorFeedHold_M				  	IS MEM26
ProbeTripped_M				  	IS MEM27
ToolTouchTripped_M			  	IS MEM28
UsbProbeTripped_M			  	IS MEM29
ProbeProtectionEnable_M		  	IS MEM30
ProbeSpindleInhibit_M		  	IS MEM31

;MEM 39-49 for Plasma
TorchCheckMode_M			    IS MEM39
DiveDetected_M					IS MEM40
VelocityDive_M					IS MEM41
DiveDetectHold_M				IS MEM42
TorchArcOk_M					IS MEM43
TorchArcMonitor_M				IS MEM44
TorchToggleOn_M					IS MEM45
TorchOn_M						IS MEM46
TorchTouched_M					IS MEM47
TorchKnobChanged_M				IS MEM48
BreakAwayAllowZ_M				IS MEM49

TurretIndex_M					IS MEM50
TurretHomed_M					IS MEM51
ToolChangeComplete_M			IS MEM52
DoingM6_M						IS MEM53
DoingIndexMinus_M				IS MEM54
DoingIndexPlus_M				IS MEM55
DoingIndex_M					IS MEM56
ToolCounterArmed_M				IS MEM57
CarouselReversed_M				IS MEM58
AtPutbackLocation_M				IS MEM59
WaitingForPutbackComplete_M		IS MEM60
DoingPutback_M					IS MEM61
DoingM18_M						IS MEM62
CarouselCCW_M					IS MEM63
AtRequestedToolLocation_M		IS MEM64
CarouselHomeComplete_M			IS MEM65

;Reserve MEM70-99 for ATC Setup
ATCToolCounterUsed_M			IS MEM70
ATCRequiresCountSkip_M			IS MEM71
ATCSyncHoming_M					IS MEM72
ATCGrayCodeUsed_M				IS MEM73
CarouselInState_M				IS MEM74
CarouselOutState_M				IS MEM75
MovingCarouselIn_M				IS MEM76
MovingCarouselOut_M				IS MEM77

LaserAlignVCP_M					IS MEM100
DustFootVCP_M					IS MEM101

ContinuousJog_M               	IS MEM135
FastJog_M                     	IS MEM136
XkeysUsb_M                    	IS MEM137
ShuttleExpressUsb_M           	IS MEM138
Input_IsLimit_M               	IS MEM140
Input_IsInverted_M            	IS MEM141
;Input3_IsLimit                	IS MEM142
;Input4_IsLimit                	IS MEM143
;Input5_IsLimit                	IS MEM144
;Input6_IsLimit                	IS MEM145
;Input7_IsLimit                	IS MEM146
;Input8_IsLimit                	IS MEM147
WTF_Flag                      	IS MEM148
LimitOverrideEnabled          	IS MEM149
JogKeyPressed_M               	IS MEM150

SpindleForward_M              	IS MEM157
SpindleReverse_M              	IS MEM158
SpindleDisable_M              	IS MEM159

True                          	IS MEM161
SpinRangeReversed_M           	IS MEM162
SpindleDirection_M            	IS MEM163
SpindlePause_M                	IS MEM164
LimitTripped_M                	IS MEM165
SpinStart_M                   	IS MEM166
SpinStop_M                    	IS MEM167
SpindleEnableOut_M            	IS MEM168
SpindleDirectionOut_M         	IS MEM169
ProbeMsgSent_M                	IS MEM170
SpindleBrakeDisabled_M        	IS MEM171
JoggingDisabled_M             	IS MEM172
JogWithProbeTrippedArmed_M    	IS MEM173
ProbeTrippedDisarm_M		  	IS MEM174
JogWithHandwheelTripped_M	  	IS MEM175

ETHER1616_1_ONLINE_M		  	IS MEM176
ETHER1616_2_ONLINE_M		  	IS MEM177
ETHER1616_3_ONLINE_M		  	IS MEM178
ETHER1616_4_ONLINE_M		  	IS MEM179
ETHER1616_5_ONLINE_M		  	IS MEM180

;MEM 181-200 Wizard Memory Bits
WorkLightDisabled_M			  	IS MEM181
ProbeDetectDisabled_M		  	IS MEM182
TTDetectDisabled_M			  	IS MEM183
PopUpPinsCycleStart_M			IS MEM184
ChuckState_M					IS MEM185
ColletDisabled_M				IS MEM186
RPMSensorDisabled_M				IS MEM187
TorchArcOkDisabled_M            IS MEM188
TorchFloatSwitchDisabled_M      IS MEM189

; Used by Wizard to assign/unassign when I/O is assigned
; If an input or output label has been assigned a label below, the Wizard will
; add a semi-colon in front of the matching to comment out the mem bit
; assignment. If the label has not been used, a the semi-colon is removed and a
; mem assigned to the unused I/O label

;--Memory bits that were in the Wizard IO
ChuckIsOpenIs_M               IS MEM230
ChuckIsClosedIs_M             IS MEM231
ChuckOpenCloseComplete_M      IS MEM232
SpindleIsLockedIs_M           IS MEM235
CutOffIsDownIs_M              IS MEM237
PartChuteIsInIs_M             IS MEM238
;							  IS MEM239
SpindleLockComplete           IS MEM240
CutOffComplete                IS MEM241
PartChuteComplete             IS MEM242
ToolTurretIsLocked            IS MEM249
ToolTurretIsUnlocked          IS MEM250
ToolTurretIsIn                IS MEM253
ToolTurretIsOut               IS MEM254
ToolRackIsUp                  IS MEM256
ToolRackIsDown                IS MEM257
PotIsUp                       IS MEM258
PotIsDown                     IS MEM259
DrawBarReleasedDisable_M	  IS MEM261
ToolIsUnclampedDisable_M	  IS MEM266
PairedHomeTripped             IS MEM263
ProbeToolTripped              IS MEM267
Custom                        IS MEM314  ; M37, M38
LockSpindle                   IS MEM319
LockToolTurret                IS MEM331
UnlockToolTurret              IS MEM332
MoveToolTurretIn              IS MEM335
MoveToolTurretOut             IS MEM336
MovePotUp                     IS MEM339
MovePotDown                   IS MEM340
MoveToolRackUp                IS MEM341
MoveToolRackDown              IS MEM342

; DO NOT MODIFY
; #wizardregion MemoryBits
FirstAxisHomeLimitOk         IS MEM201
FirstAxisMinusLimitOk        IS MEM202
FirstAxisPlusLimitOk         IS MEM203
FirstAxisHomeOk              IS MEM204
SecondAxisHomeLimitOk        IS MEM205
SecondAxisHomeOk             IS MEM206
SecondAxisMinusLimitOk       IS MEM207
SecondAxisPlusLimitOk        IS MEM208
ThirdAxisHomeOk              IS MEM209
ThirdAxisMinusLimitOk        IS MEM210
ThirdAxisPlusLimitOk         IS MEM211
FourthAxisHomeLimitOk        IS MEM212
FourthAxisHomeOk             IS MEM213
FourthAxisMinusLimitOk       IS MEM214
FourthAxisPlusLimitOk        IS MEM215
BackGear                     IS MEM216
ProbeTripped                 IS MEM217
ProbeDetect                  IS MEM218
DriveOk                      IS MEM220
LubeOk                       IS MEM221
ChuckIsOpen                  IS MEM222
ChuckIsClosed                IS MEM223
SpindleOk                    IS MEM224
SpindleLowRange              IS MEM225
SpindleMedRange              IS MEM226
SpindleHighRange             IS MEM228
ThirdAxisHomeLimitOk         IS MEM229
ChuckFootPedal_I             IS MEM233
CutOffIsDown                 IS MEM234
PartChuteIsIn                IS MEM236
ToolTurretPosBit1            IS MEM243
ToolTurretPosBit2            IS MEM244
ToolTurretPosBit3            IS MEM245
ToolTurretPosBit4            IS MEM246
ToolTurretCounter            IS MEM247
ToolTurretSyncBit            IS MEM248
ToolIsUnclamped              IS MEM252
SpindleIsOriented            IS MEM255
HomeAll                      IS MEM260
SlavedHomeInput              IS MEM262
LimitAll                     IS MEM264
ToolTouchOffTriggered        IS MEM265
ZriHomingAll                 IS MEM266
ToolTouchOffDetect           IS MEM268
SafetyDoorSwitchClosed_I     IS MEM269
SafetyDoorLockConfirmed_I    IS MEM270
CycleStart2                  IS MEM271
CycleCancel2                 IS MEM272
FeedHold2                    IS MEM273
ToolCheck2                   IS MEM274
Axis1DriveOk                 IS MEM275
Axis2DriveOk                 IS MEM276
Axis3DriveOk                 IS MEM277
Axis4DriveOk                 IS MEM278
ToolUnclampButton            IS MEM279
VFDZeroSpeed                 IS MEM280
VFDUpToSpeed                 IS MEM281
DrawBarReleased              IS MEM282
SpindleTempAlarmMessage      IS MEM283
SpindleTempAlarmStop         IS MEM284
AirPressureLowMessage        IS MEM285
AirPressureLowStop           IS MEM286
RPM_Sensor                   IS MEM287
TorchBreakawayOk             IS MEM288
TorchFloatSwitch_I           IS MEM289
TorchArcOk_I                 IS MEM290
SlavedAxisDriveOk            IS MEM291
Ohmic_Sensor                 IS MEM292
NoFaultOut                   IS MEM301
LubePump                     IS MEM302
SpindleBrakeRelease          IS MEM303
SpinFWD                      IS MEM304
SpinREV                      IS MEM305
DriveResetOut                IS MEM306
Flood                        IS MEM307
TurnClampOn                  IS MEM308
G540SpinRevOff               IS MEM309
G540SpinFwdOff               IS MEM310
Mist                         IS MEM311
VacuumOn                     IS MEM312
DustCollectionOn             IS MEM313
OpenChuck                    IS MEM315
CloseChuck                   IS MEM316
WorkLight                    IS MEM317
PartChute                    IS MEM318
AirBlowNozzle                IS MEM318
ColletOpenClose              IS MEM319
ChargePump                   IS MEM319
CutOff                       IS MEM320
RotateToolTurret             IS MEM329
ReverseToolTurret            IS MEM330
ToolTurretEnable             IS MEM333
UnclampTool                  IS MEM334
OrientSpindle                IS MEM337
ATC_CarouselForward          IS MEM343
ATC_CarouselReverse          IS MEM344
ATC_ToolCounter              IS MEM345
ATC_CarouselIsIn             IS MEM346
ATC_CarouselIsOut            IS MEM347
ATC_CarouselOut              IS MEM348
ATC_CarouselIn               IS MEM349
Axis1BrakeRelease            IS MEM355
Axis2BrakeRelease            IS MEM356
Axis3BrakeRelease            IS MEM357
Axis4BrakeRelease            IS MEM358
SafetyDoorLockOpen_O         IS MEM360
VFDEnable_O                  IS MEM361
VFDDirection_O               IS MEM362
VFDResetOut_O                IS MEM363
TailStockInOut               IS MEM364
ATCAirBlowActivate           IS MEM365
RouterDustCollection         IS MEM366
RouterVacuumHoldDown         IS MEM367
DustFootActivate             IS MEM368
LaserAlignActivate           IS MEM369
PopUpPins                    IS MEM370
SpindleCooling               IS MEM371
GreenLight                   IS MEM372
AmberLight                   IS MEM373
RedLight                     IS MEM374
SpindleCooling_Fan           IS MEM375
LaserEnable                  IS MEM377
PWMSelect                    IS MEM378
LaserReset                   IS MEM379
PWMOutput                    IS MEM380
TorchOn                      IS MEM381
TorchTouchDisconnect         IS MEM382
Ohmic_Enable                 IS MEM383
CAxisEnable                  IS MEM384
M94M95124                    IS MEM389
M94M95123                    IS MEM389
M94M95122                    IS MEM389
M94M95121                    IS MEM389
M94M95120                    IS MEM389
M94M95119                    IS MEM389
M94M95113                    IS MEM389
M94M95125                    IS MEM389
M94M95111                    IS MEM389
M94M95118                    IS MEM389
M94M95117                    IS MEM389
M94M95116                    IS MEM389
M94M95115                    IS MEM389
M94M95114                    IS MEM389
M94M95112                    IS MEM389
M94M95126                    IS MEM389
; #endregion

; Reserved for Centroid. DO NOT USE.
KbCycleStart_M                IS MEM400 ; "alt" + "s"
KbCycleCancel_M               IS MEM401 ; escape
KbToolCheck_M                 IS MEM402 ; "Ctrl" + "t"
KbTogSingleBlock_M            IS MEM403 ; "Ctrl" + "b"
KbIncreaseJogInc_M            IS MEM404 ; "Insert"
KbDecreaseJogInc_M            IS MEM405 ; "Delete"
KbIncFeedOver_M               IS MEM406 ; "ctrl" + "keyboard "+" ("=")
KbDecFeedOver_M               IS MEM407 ; "ctrl" + "keyboard "-"
KbTogIncContJog_M             IS MEM408 ; "ctrl" + "i"
KbTogFastSlowJog_M            IS MEM409 ; "ctrl" + "f"
KbJogAx1Plus_M                IS MEM411 ; right arrow + KbJpActive_M
KbJogAx1Minus_M               IS MEM412 ; left arrow + KbJpActive_M
KbJogAx2Plus_M                IS MEM413 ; up arrow + KbJpActive_M
KbJogAx2Minus_M               IS MEM414 ; down arrow + KbJpActive_M
KbJogAx3Plus_M                IS MEM415 ; page up + KbJpActive_M
KbJogAx3Minus_M               IS MEM416 ; page down + KbJpActive_M
KbJogAx4Plus_M                IS MEM417 ; "home"+ KbJpActive_M
KbJogAx4Minus_M               IS MEM418 ; "end" + KbJpActive_M
KbAux1Key_M                   IS MEM419 ; "ctrl" + "F1"
KbAux2Key_M                   IS MEM420 ; "ctrl" + "F2"
KbAux3Key_M                   IS MEM421 ; "ctrl" + "F3"
KbAux4Key_M                   IS MEM422 ; "ctrl" + "F4"
KbAux5Key_M                   IS MEM423 ; "ctrl" + "F5"
KbAux6Key_M                   IS MEM424 ; "ctrl" + "F6"
KbAux7Key_M                   IS MEM425 ; "ctrl" + "F7"
KbAux8Key_M                   IS MEM426 ; "ctrl" + "F8"
KbAux9Key_M                   IS MEM427 ; "ctrl" + "F9"
KbAux10Key_M                  IS MEM428 ; "ctrl" + "F10"
KbAux11Key_M                  IS MEM429 ; "ctrl" + "F11"
KbAux12Key_M                  IS MEM430 ; "ctrl" + "F12"
KbTogRapidOver_M              IS MEM431 ; "ctrl" + "r"
KbTogSpinAutoMan_M            IS MEM432 ; "ctrl" + "a"
KbSpinCW_M                    IS MEM433 ; "ctrl" + "c"
KbSpinCCW_M                   IS MEM434 ; "ctrl" + "w"
KbSpinStart_M                 IS MEM435 ; "ctrl" + "s"
KbSpinStop_M                  IS MEM436 ; "ctrl" + "q"
KbFloodOnOff_M                IS MEM437 ; "ctrl" + "n"
KbTogCoolAutoMan_M            IS MEM438 ; "ctrl" + "m"
KbFeedHold_M                  IS MEM439 ; space bar
KbIncSpinOver_M               IS MEM440 ; "ctrl" + ">" (.)
KbDecSpinOver_M               IS MEM441 ; "ctrl" + "<" (,)
KbSpinOver100_M               IS MEM442 ; "ctrl" + "?" (/)
ShuttleAxisSelectKey          IS MEM443 ; "ctrl" + 9 or ctrl numpad 9
ShuttleAxisJogMinusKey        IS MEM444
Shuttle10_OverMinusKey        IS MEM445
Shuttle35_OverMinusKey        IS MEM446
Shuttle75_OverMinusKey        IS MEM447
Shuttle100_OverMinusKey       IS MEM448
Shuttle135_OverMinusKey       IS MEM449
Shuttle175_OverMinusKey       IS MEM450
Shuttle200_OverMinusKey       IS MEM451
Shuttle10_OverPlusKey         IS MEM452
Shuttle35_OverPlusKey         IS MEM453
Shuttle75_OverPlusKey         IS MEM454
Shuttle100_OverPlusKey        IS MEM455
Shuttle135_OverPlusKey        IS MEM456
Shuttle175_OverPlusKey        IS MEM457
Shuttle200_OverPlusKey        IS MEM458
ShuttleAxisJogPlusKey         IS MEM459
ShuttleAxisJog0Position       IS MEM460
ShuttleIncJogMinus            IS MEM461
ShuttleIncJogPlus             IS MEM462
ShuttleFeedOrFlag             IS MEM463
ShuttleEnabled                IS MEM464
ShuttleResumeFeedFlag         IS MEM465
ShuttlePresent                IS MEM466
KbFeedOver100_M               IS MEM467 ; "ctrl" + "\"
KbMistOnOff_M                 IS MEM468 ; "ctrl" + "k"
ShuttleAxis1Selected          IS MEM469
ShuttleAxis2Selected          IS MEM470
ShuttleAxis3Selected          IS MEM471
ShuttleAxis4Selected          IS MEM472
ShuttleIncJogInc              IS MEM473; "ctrl" + z
ShuttleIncJogDec              IS MEM474; del
ShuttleDisabled               IS MEM475
SlowJogSelected               IS MEM476
FastJogSelected               IS MEM477
ContinuousSelected            IS MEM478
IncrementalSelected           IS MEM479
ShuttleAxisJogContPlus        IS MEM480
ShuttleAxisJogContMinus       IS MEM481
DisableKbInput_M              IS MEM501 ;If 1, disable kb jogging
AllowKbInput_M                IS MEM502 ;If 1, allow kb jogging
JogOverOnly_M                 IS MEM503
KbOverOnly_M                  IS MEM504
UsingFeedrateKnob_M           IS MEM505
WaitingForSleepTimer_M        IS MEM506
PLCBus_Oe_M                   IS MEM507
X1_M                          IS MEM508
X10_M                         IS MEM509
X100_M                        IS MEM510
PLCExecutorFault_M            IS MEM511
SoftwareNotReady_M            IS MEM512   ; 0 = okay, 1 = CNC12 not running/ready
MPGManOffFlag_M               IS MEM513
Ax1PlusJogDisabled_M          IS MEM514
Ax1MinusJogDisabled_M         IS MEM515
Ax2PlusJogDisabled_M          IS MEM516
Ax2MinusJogDisabled_M         IS MEM517
Ax3MinusJogDisabled_M         IS MEM518
KbJpActive_M                  IS MEM519 ; aka SV_PC_VIRTUAL_JOGPANEL_ACTIVE
MasterEnable_M                IS MEM520  ; 1 = enabled (echo of SV_MASTER_ENABLE)
OnAtPowerUp_M                 IS MEM521
LastProbeMode_M               IS MEM522
JogModeSaved_M                IS MEM523
;Reserved                     IS MEM524
ActivateFeedHold_M            IS MEM525  ; 0 = idle, 1 = trigger feed hold on
ErrorFlag_M                   IS MEM526  ; 0 = okay, 1 = error (but not a fault)
Stop_M                        IS MEM527  ; 0 = okay, 1 = fault (echo of SV_STOP)
Stall_M                       IS MEM528  ; 0 = okay, 1 = stall (echo of SV_STALL_ERROR)
LubeFault_M                   IS MEM529  ; 0 = okay, 1 = lube fault
PLCFault_M                    IS MEM530  ; 0 = okay, 1 = PLC fault
AxisFault_M                   IS MEM531  ; 0 = okay, 1 = drive or drive fiber problem
DriveComFltIn_M               IS MEM532  ; 0 = okay, 1 = incoming drive fiber problem
DriveComFltOut_M              IS MEM533  ; 0 = okay, 1 = outgoing drive fiber problem
ProbeFault_M                  IS MEM534  ; 0 = okay, 1 = tried to start spindle w/probe
JogProbeFault_M               IS MEM535  ; 0 = okay, 1 = tripped probe while jogging
SpindleFault_M                IS MEM536  ; 0 = okay, 1 = spindle drive fault
OtherFault_M                  IS MEM537
DriveFault_M                  IS MEM538
InvertXJogKeys_M              IS MEM539
SwapAxes_M                    IS MEM540
IsUsbMpgAxisSelected_M        IS MEM541
SlowLEDState_M                IS MEM542
FastLEDState_M                IS MEM543
PlasmaWMPG_M                  IS MEM544
;Reserved                     IS MEM545
;Reserved                     IS MEM546
;Reserved                     IS MEM547
;Reserved                     IS MEM548
;Reserved                     IS MEM549
PairTripped                   IS MEM550
KbAux13Key_M                  IS MEM551 ; "ctrl" + "1" change just defaulted for now
KbAux14Key_M                  IS MEM552 ; "ctrl" + "2" change just defaulted for now
KbAux15Key_M                  IS MEM553 ; "ctrl" + "3" change just defaulted for now
KbAux16Key_M                  IS MEM554 ; "ctrl" + "4" change just defaulted for now

;MPG bits 32 bits reserved 32 bits open for further use start at 663
;Centroid defined 600 - 631
MpgResetKey_M					IS MEM600
MpgFeedHold_M					IS MEM601
MpgCycleStart_M					IS MEM602
UsbMpgJogPlus_M					IS MEM603
UsbMpgJogMinus_M				IS MEM604
MpgSpinAutoMan_M				IS MEM605
MpgSpinOnOff_M					IS MEM606
MpgMacro1_M						IS MEM607
MpgMacro2_M						IS MEM608
MpgMacro3_M						IS MEM609
MpgMacro4_M						IS MEM610
MpgToolCheck_M					IS MEM611
MpgSetAxisZero_M				IS MEM612
UsbMpgOn						IS MEM613
;IS MEM614
ResetFlag_M						IS MEM615
SkinResetFlag_M					IS MEM616
;SkinResetOk_M					IS MEM617
;SkinResetSet_M					IS MEM618

;User defined 632-663

;Glue Logic   664+
MpgSpinOnOffPressed_M       	IS MEM664
MpgSpinOn_M			        	IS MEM665
MpgSpinOff_M			    	IS MEM666
MpgSpinOnState_M				IS MEM667
MpgAxis1Selected_M		    	IS MEM668
MpgAxis2Selected_M				IS MEM669
MpgAxis3Selected_M				IS MEM670
MpgAxis4Selected_M				IS MEM671
MpgSpinWheelSelect_M			IS MEM672
MpgSpinWheelSet_M				IS MEM673
MpgFeedWheelSelect_M        	IS MEM674
MpgFeedWheelSet_M           	IS MEM675
MpgAxis1JogPlus_M				IS MEM676
MpgAxis1JogMinus_M				IS MEM677
MpgAxis2JogPlus_M				IS MEM678
MpgAxis2JogMinus_M				IS MEM679
MpgAxis3JogPlus_M				IS MEM680
MpgAxis3JogMinus_M				IS MEM681
MpgAxis4JogPlus_M   			IS MEM682
MpgAxis4JogMinus_M				IS MEM683
UsbMpgWheelJoggingEnabled_M 	IS MEM684

MpgX100LockOut_M                IS MEM692
MpgZAxisLocked_M                IS MEM693

SpinBrakeOff_M			      	IS MEM694
SpinBrakeOn_M			      	IS MEM695
BackGearEnabled_M       		IS MEM696

;Mem 701-706 Reserved for Torch Restart Feature
CycleStartPressed_M             IS MEM701 ;Required for Restart Feature
TorchCheckPressed_M             IS MEM702 ;Required for Restart Feature
RestartForwardPressed_M         IS MEM703 ;Required for Restart Feature
RestartBackwardPressed_M        IS MEM704 ;Required for Restart Feature
CycleCancelPressed_M            IS MEM705 ;Required for Restart Feature
TorchBreakawayFault_M           IS MEM706 ;Required for Restart Feature

THCError_M                      IS MEM710
THCNegativeError_M              IS MEM711
THCDisconnectError_M            IS MEM712
TorchBreakawayTripped_M         IS MEM713
TorchFloatFirst_M               IS MEM714
TorchOhmicTouch_M               IS MEM715
TorchFloatTouch_M               IS MEM716
TorchIgnoreTip_M                IS MEM717
THCAutoSenseOnce_M              IS MEM718

;Mem730-736 for P523 Bits
THCAutomaticBit_M               IS MEM730
THCAutoSenseBit_M               IS MEM731
DryRunPierceHeightBit_M         IS MEM732
DryRunCutHeightBit_M            IS MEM733
FloatWithSwitchBit_M            IS MEM734
THCNotInstalledBit_M            IS MEM735
THCAutoSenseOnCutBit_M          IS MEM736

;Input1_IsInverted             	IS MEM801
;Input2_IsInverted             	IS MEM802
;Input3_IsInverted             	IS MEM803
;Input4_IsInverted             	IS MEM804
;Input5_IsInverted             	IS MEM805
;Input6_IsInverted             	IS MEM806
;Input7_IsInverted             	IS MEM807
;Input8_IsInverted             	IS MEM808
TempJPActive_M                	IS MEM809
SkinMem810                    	IS MEM810
Axis1HomeLimitOkMem           	IS MEM811
Axis2HomeLimitOkMem           	IS MEM812
Axis3HomeLimitOkMem           	IS MEM813
Axis4HomeLimitOkMem           	IS MEM814
;                             	IS MEM815
SkinMem816                    	IS MEM816
SkinMem817                    	IS MEM817
SkinMem818                    	IS MEM818
SkinMem819                    	IS MEM819
SkinMem820                    	IS MEM820
SkinMem821                    	IS MEM821
SkinMem822                    	IS MEM822
SkinMem823                    	IS MEM823
SkinMem824                    	IS MEM824
SkinMem825                    	IS MEM825
SkinMem826                    	IS MEM826
SkinMem827                    	IS MEM827
SkinMem828                    	IS MEM828
SkinMem829                    	IS MEM829
SkinMem830                    	IS MEM830
UsbMpgAxis1Active_M           	IS MEM831
UsbMpgAxis2Active_M           	IS MEM832
UsbMpgAxis3Active_M           	IS MEM833
UsbMpgAxis4Active_M           	IS MEM834
SkinMem835                    	IS MEM835
SkinMem836                    	IS MEM836
SkinMem837                    	IS MEM837
SkinMem838                    	IS MEM838
SkinMem839                    	IS MEM839
SkinMem840                    	IS MEM840
SkinMem841                    	IS MEM841
SkinMem842                    	IS MEM842
SkinMem843                    	IS MEM843
SkinMem844                    	IS MEM844
SkinMem845                    	IS MEM845
SkinMem846                    	IS MEM846
SkinMem847                    	IS MEM847
SkinMem848                    	IS MEM848
SkinMem849                    	IS MEM849
SkinMem850                    	IS MEM850
SkinMem851                    	IS MEM851
SkinMem852                    	IS MEM852
SkinMem853                    	IS MEM853
SkinMem854                    	IS MEM854
SkinMem855                    	IS MEM855
SkinMem856                    	IS MEM856
SkinMem857                    	IS MEM857
SkinMem858                    	IS MEM858
SkinMem859                    	IS MEM859
SkinMem860                    	IS MEM860
SkinMem861                    	IS MEM861
SkinMem862                    	IS MEM862
SkinMem863                    	IS MEM863
SkinMem864                    	IS MEM864
SkinMem865                    	IS MEM865

SkinMem880                    	IS MEM880

SkinMem893                    	IS MEM893
SkinMem894                    	IS MEM894
SkinMem895                    	IS MEM895
SkinMem896                    	IS MEM896
SkinMem897                    	IS MEM897
SkinMem898                    	IS MEM898
SkinMem899                    	IS MEM899
;Gray Code ATC Memory Bits
P831Bit0					  IS MEM900
P831Bit1					  IS MEM901
P831Bit2					  IS MEM902
P831Bit3					  IS MEM903
P832Bit0					  IS MEM904
P832Bit1					  IS MEM905
P832Bit2					  IS MEM906
P832Bit3					  IS MEM907
P833Bit0					  IS MEM908
P833Bit1					  IS MEM909
P833Bit2					  IS MEM910
P833Bit3					  IS MEM911
P834Bit0					  IS MEM912
P834Bit1					  IS MEM913
P834Bit2					  IS MEM914
P834Bit3					  IS MEM915
P835Bit0					  IS MEM916
P835Bit1					  IS MEM917
P835Bit2					  IS MEM918
P835Bit3					  IS MEM919
P836Bit0					  IS MEM920
P836Bit1					  IS MEM921
P836Bit2					  IS MEM922
P836Bit3					  IS MEM923
P837Bit0					  IS MEM924
P837Bit1					  IS MEM925
P837Bit2					  IS MEM926
P837Bit3					  IS MEM927
P838Bit0					  IS MEM928
P838Bit1					  IS MEM929
P838Bit2					  IS MEM930
P838Bit3					  IS MEM931
P839Bit0					  IS MEM932
P839Bit1					  IS MEM933
P839Bit2					  IS MEM934
P839Bit3					  IS MEM935
P840Bit0					  IS MEM936
P840Bit1					  IS MEM937
P840Bit2					  IS MEM938
P840Bit3					  IS MEM939
P841Bit0					  IS MEM940
P841Bit1					  IS MEM941
P841Bit2					  IS MEM942
P841Bit3					  IS MEM943
P842Bit0					  IS MEM944
P842Bit1					  IS MEM945
P842Bit2					  IS MEM946
P842Bit3					  IS MEM947
P843Bit0					  IS MEM948
P843Bit1					  IS MEM949
P843Bit2					  IS MEM950
P843Bit3					  IS MEM951
P844Bit0					  IS MEM952
P844Bit1					  IS MEM953
P844Bit2					  IS MEM954
P844Bit3					  IS MEM955
P845Bit0					  IS MEM956
P845Bit1					  IS MEM957
P845Bit2					  IS MEM958
P845Bit3					  IS MEM959
P846Bit0					  IS MEM960
P846Bit1					  IS MEM961
P846Bit2					  IS MEM962
P846Bit3					  IS MEM963

;------------------------------------------------------------------------------
;                     ---------SYSTEM VARIABLES--------
;
; For a complete list of System Variables and their functions, please see the
; MPU11 PLC manual.
;------------------------------------------------------------------------------

; MPU11 based systems provide the PLC with the ability to read/write to a
; limited number of "System Variables".  While the use of System Variables
; greatly expands PLC functionality, it comes with additional responsibility on
; the part of the PLC programmer.  Functionality that was once implemented as
; default behavior such as jogging, spindle speed, feedrate override, spindle
; gear ranges etc... is now implemented through System Variables in the PLC
; program.  It is now the sole responsibility of the PLC program to provide a
; method to jog an axis, override the spindle speed or feedrates or even map a
; jog panel keypress to a specific function.  Pressing a jog key or Aux key
; won't DO anything unless the PLC assigns an action to the keypress.  All jog
; panel functions MUST be explicitly implemented in the PLC program.
;                                 ----IMPORTANT----
; Menu navigation in the CNC software requires that the escape key or Cycle
; Cancel key is used to back out of menus and screens.  You must use the PLC
; program to map a jog panel key and/or a keyboard key to the Cycle Cancel
; System Variable (SV_PLC_FUNCTION_1 has been declared as "DoCycleCancel")
; in order to use the control.  For example:
; The following lines map the escape key and Jog Panel Cycle Cancel key to
; produce a Cycle Cancel event:

; 1. Map escape keypress event to identifier to describe what key was pressed.
;    Kb_Escape    IS SV_PC_Keyboard_Key_1

; 2. Map MEM bit to identifier that describes what the keypress is used for.
;    KbCycleCancel_M  IS MEM401

; 3. Logic to "SET" KbCycleCancel_M anytime the escape key is pressed.
;    IF Kb_Escape THEN(KbCycleCancel_M)

; 4. Logic to cancel job if the escape key or cycle cancel key is pressed.
;    IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING
;      THEN (DoCycleCancel)

;   Some of the information made available to the PLC through System Variables:
; 1. Encoder positions: SV_MPU11_ABS_POS_0 - SV_MPU11_ABS_POS_7
; 2. Parameter values: SV_MACHINE_PARAMETER_0 - SV_MACHINE_PARAMETER_999
; 3. Spindle Speed command from PC: SV_PC_DAC_SPINDLE_SPEED
; 4. PC Keyboard Keypress: SV_PC_FUNCTION_1 - SV_PC_FUNCTION_127
; 5. ...

;   Some of the functionality controlled by the PLC through System Variables:
; 1. Axis jogging: SV_PLC_FUNCTION_12 - SV_PLC_FUNCTION_23
; 2. "Final" Spindle speed reported to PC: SV_PLC_SPINDLE_SPEED -provides nearly
;     unlimited gear ranges
; 3. Feedrate (through override knob): SV_PLC_FeedrateKnob_W
; 4. Custom debounce, invert/force inputs: SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64
; 5. ...

;-------------------------------------------------------------------------------
;        PLC Input manipulation - SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_64
; The System Variables in this section are used to modify the characteristics
; of PLC inputs 1-240.  Each input can be inverted, forced or assigned a custom
; debounce time.

;-----------------------------Debounce Times-----------------------------------
; SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64 are used to define up to seven custom
; debounce times which can be selected for each input.

; The 32 bit integer System Variables SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64,
; are broken up into 8, 16 bit words, only 7 of which are used. The first word,
; the 16 MSB of SV_PLC_DEBOUNCE_61 is unused.  Each 16 bit word can be used to
; store a debounce time of between 0-32767 (the MSB of each word is unused).
; Debounce times are in increments of 62.5 usecs which provides debounce times
; of up to ~2 secs.

;                          SV_PLC_DEBOUNCE_61
;                     Unused:Bits 0-15 (Selection 0)
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;                    Debounce Time Selection #1
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                          SV_PLC_DEBOUNCE_62
;                      Debounce Time Selection #2
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;                      Debounce Time Selection #3
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;------------------------Configuring Input Behavior---------------------------
; Each System Variable from SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_60 is a 32 bit
; integer word broken up into 4 bit words to control the behavior of 4 inputs.
; Inputs 1-4 are configured using SV_PLC_DEBOUNCE_1, inputs 5-8 are handled
; using SV_PLC_DEBOUNCE_2 and so on to SV_PLC_DEBOUNCE_60 which controls inputs
; 237-240

; As mentioned above, each 32 bit word defines the characteristics for 4 inputs.
; SV_PLC_DEBOUNCE_1 defines the characteristics of INP1, INP2, INP3 & INP4 and
; so on through SV_PLC_DEBOUNCE_60 which handles INP237, INP238, INP239&INP240.
; The behavior of an input is set as follows:

; Five new operators have been introduced to simplify bit operations:
; BITSET, BITRST, BITTST, LSHIFT & RSHIFT.  Below we will use BITSET to
; invert an input.  This is convenient to use when a device is normally
; open and the logic is written for a normally closed device.  Inverting
; the input allows to reuse the existing logic rather than rewrite it.

; BITSET and BITRST can not operate directly on SV_PLC_DEBOUNCE_# system
; variables, they can only operate on W32 variables.  In order to use BITSET and
; BITRST to manipulate the debounce variables you'll have to perform all
; operations on a w32 first:

; Declare a W32:
; Inputs_9_12_W IS W1
; use BITSET or BITRST
; if 1 == 1 THEN BITSET Inputs_9_12_W 14  ;invert INP10 (bit14)

; Set Debounce system variable = to W32 variable
; IF 1 == 1 THEN SV_PLC_DEBOUNCE_3 = Inputs_9_12_W

;---------------------System Variable = SV_PLC_DEBOUNCE_1---------------------
;                      Inp4 = bits 31-24        Inp3 = bits 23-16
;                MSB 31 30 29 28 27 26 25 24| 23 22 21 20 19 18 17 16

;                        Inp2 = bits 15-8       Inp1 = bits 7-0
;                      15 14 13 12 11 10 9 8| 7 6 5 4 3 2 1 0LSB

;                              Each 8 bit word from above
;      MSB       7      6      5      4      3      2      1      0     LSB
;              Force  Invert Spare  Spare  Spare  Debounce Select (7)
;                                                          selects 1 of 7
;                                                          debounce times
;                                                         (zero is invalid)
;     Force (bit 7): Set this bit to force the input to a 1* (closed)
;     Invert(bit 6): Set this to invert an input
;     Spare(bit5-3): Not used
; Debounce(bit 0-2): Selects one of the 7 preset debounce times defined in
;                    SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64
;
;  *If you wish to force an input to 0, set the both invert AND force bits
;   for the input.

;------------------------------------------------------------------------------
; PLC Jog Panel input manipulation - The System Variables in this section are
; used to modify the characteristics of the Jog Panel keys.  The jog panel keys
; can be configured in the same manner as the PLC inputs and use debounce times
; as selected/set in SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64.
;------------------------------------------------------------------------------


;------------------------------------------------------------------------------
;  System variables:  Jog Panel Functions
;------------------------------------------------------------------------------
; Jog panel functions
;Invalid                      IS SV_PLC_FUNCTION_0
DoCycleCancel                 IS SV_PLC_FUNCTION_1
DoCycleStart                  IS SV_PLC_FUNCTION_2
DoToolCheck                   IS SV_PLC_FUNCTION_3
SelectSingleBlock             IS SV_PLC_FUNCTION_4
SelectX1JogInc                IS SV_PLC_FUNCTION_5
SelectX10JogInc               IS SV_PLC_FUNCTION_6
SelectX100JogInc              IS SV_PLC_FUNCTION_7
SelectUserJogInc              IS SV_PLC_FUNCTION_8
SelectIncContJog              IS SV_PLC_FUNCTION_9
SelectFastSlowJog             IS SV_PLC_FUNCTION_10
SelectMpgMode                 IS SV_PLC_FUNCTION_11
DoAx1PlusJog                  IS SV_PLC_FUNCTION_12
DoAx1MinusJog                 IS SV_PLC_FUNCTION_13
DoAx2PlusJog                  IS SV_PLC_FUNCTION_14
DoAx2MinusJog                 IS SV_PLC_FUNCTION_15
DoAx3PlusJog                  IS SV_PLC_FUNCTION_16
DoAx3MinusJog                 IS SV_PLC_FUNCTION_17
DoAx4PlusJog                  IS SV_PLC_FUNCTION_18
DoAx4MinusJog                 IS SV_PLC_FUNCTION_19
DoAx5PlusJog                  IS SV_PLC_FUNCTION_20
DoAx5MinusJog                 IS SV_PLC_FUNCTION_21
DoAx6PlusJog                  IS SV_PLC_FUNCTION_22
DoAx6MinusJog                 IS SV_PLC_FUNCTION_23
DoAux1Key                     IS SV_PLC_FUNCTION_24
DoAux2Key                     IS SV_PLC_FUNCTION_25
DoAux3Key                     IS SV_PLC_FUNCTION_26
DoAux4Key                     IS SV_PLC_FUNCTION_27
DoAux5Key                     IS SV_PLC_FUNCTION_28
DoAux6Key                     IS SV_PLC_FUNCTION_29
DoAux7Key                     IS SV_PLC_FUNCTION_30
DoAux8Key                     IS SV_PLC_FUNCTION_31
DoAux9Key                     IS SV_PLC_FUNCTION_32
DoAux10Key                    IS SV_PLC_FUNCTION_33
SelectRapidOverride           IS SV_PLC_FUNCTION_34
SelectManAutoSpindle          IS SV_PLC_FUNCTION_35
DoSpindleStart                IS SV_PLC_FUNCTION_37
DoSpindleStop                 IS SV_PLC_FUNCTION_38
DoAux11Key                    IS SV_PLC_FUNCTION_39
DoAux12Key                    IS SV_PLC_FUNCTION_40
;SelectCoolantMan             IS SV_PLC_FUNCTION_41 ;deprecated
;SelectCoolantAuto            IS SV_PLC_FUNCTION_42 ;deprecated
SelectCoolantFlood            IS SV_PLC_FUNCTION_43
SelectCoolantMist             IS SV_PLC_FUNCTION_44
DoFeedHold                    IS SV_PLC_FUNCTION_45
SelectSpindleCCW              IS SV_PLC_FUNCTION_98
SelectSpindleCW               IS SV_PLC_FUNCTION_99
SelectCoolAutoMan             IS SV_PLC_FUNCTION_104
DoIncreaseSpindleOR           IS SV_PLC_FUNCTION_106
DoDecreaseSpindleOR           IS SV_PLC_FUNCTION_107
SelectSpinOR100               IS SV_PLC_FUNCTION_108
DoAux13Key                    IS SV_PLC_FUNCTION_114
DoAux14Key                    IS SV_PLC_FUNCTION_115
DoAux15Key                    IS SV_PLC_FUNCTION_116
DoAux16Key                    IS SV_PLC_FUNCTION_117

;------------------------------------------------------------------------------
;  System variables:  Keyboard jogging functions
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; Keyboard Jogging Keys - The System Variables in this section inform the PLC
; that a PC keyboard keypress has occurred.  Keep in mind that some key presses
; only come down while the keyboard jogging screen is enabled (alt-j) and that
; NONE of these keys not perform ANY default actions unless programmed to do so.
; The assignments provided below are for reference only.  For an example of
; mapping a keyboard key press to an MPU11 action, see the logic assigned to
; KbCycleStart_M or KbCycleCancel_M.
;
;Note:
; Keypresses are sent down as individual keys.  It is the responsibility of
; the PLC programmer to insure that a keypress is only acted on at the
; appropriate times.
; The "SV_PC_VIRTUAL_JOGPANEL_ACTIVE" system variable can be used to prevent
; a keypress form being acted on unless the keyboard jog screen is being
; displayed.  NOTE The above,29 character sys variable is mapped to
; KbJpActive_M (MEM80) to make it a "little" shorter......
;------------------------------------------------------------------------------
Kb_a                          IS SV_PC_KEYBOARD_KEY_60
Kb_b                          IS SV_PC_KEYBOARD_KEY_79
Kb_c                          IS SV_PC_KEYBOARD_KEY_77
Kb_d                          IS SV_PC_KEYBOARD_KEY_62
Kb_e                          IS SV_PC_KEYBOARD_KEY_41
Kb_f                          IS SV_PC_KEYBOARD_KEY_63
Kb_g                          IS SV_PC_KEYBOARD_KEY_64
Kb_h                          IS SV_PC_KEYBOARD_KEY_65
Kb_i                          IS SV_PC_KEYBOARD_KEY_46
Kb_j                          IS SV_PC_KEYBOARD_KEY_66
Kb_k                          IS SV_PC_KEYBOARD_KEY_67
Kb_l                          IS SV_PC_KEYBOARD_KEY_68
Kb_m                          IS SV_PC_KEYBOARD_KEY_81
Kb_n                          IS SV_PC_KEYBOARD_KEY_80
Kb_o                          IS SV_PC_KEYBOARD_KEY_47
Kb_p                          IS SV_PC_KEYBOARD_KEY_48
Kb_q                          IS SV_PC_KEYBOARD_KEY_39
Kb_r                          IS SV_PC_KEYBOARD_KEY_42
Kb_s                          IS SV_PC_KEYBOARD_KEY_61
Kb_t                          IS SV_PC_KEYBOARD_KEY_43
Kb_u                          IS SV_PC_KEYBOARD_KEY_45
Kb_v                          IS SV_PC_KEYBOARD_KEY_78
Kb_w                          IS SV_PC_KEYBOARD_KEY_40
Kb_x                          IS SV_PC_KEYBOARD_KEY_76
Kb_y                          IS SV_PC_KEYBOARD_KEY_44
Kb_z                          IS SV_PC_KEYBOARD_KEY_75
Kb_spacebar                   IS SV_PC_KEYBOARD_KEY_95
Kb_L_Shift                    IS SV_PC_KEYBOARD_KEY_74
Kb_R_Shift                    IS SV_PC_KEYBOARD_KEY_85
Kb_L_Alt                      IS SV_PC_KEYBOARD_KEY_94
Kb_R_Alt                      IS SV_PC_KEYBOARD_KEY_96
Kb_L_Ctrl                     IS SV_PC_KEYBOARD_KEY_92
Kb_R_Ctrl                     IS SV_PC_KEYBOARD_KEY_99
Kb_Ins                        IS SV_PC_KEYBOARD_KEY_31
Kb_Home                       IS SV_PC_KEYBOARD_KEY_32
Kb_End                        IS SV_PC_KEYBOARD_KEY_53
Kb_PgDown                     IS SV_PC_KEYBOARD_KEY_54
Kb_PgUp                       IS SV_PC_KEYBOARD_KEY_33
Kb_Del                        IS SV_PC_KEYBOARD_KEY_52
Kb_Back                       IS SV_PC_KEYBOARD_KEY_30
Kb_Tab                        IS SV_PC_KEYBOARD_KEY_38
Kb_Up                         IS SV_PC_KEYBOARD_KEY_87
Kb_Down                       IS SV_PC_KEYBOARD_KEY_101
Kb_Left                       IS SV_PC_KEYBOARD_KEY_100
Kb_Right                      IS SV_PC_KEYBOARD_KEY_102
Kb_Escape                     IS SV_PC_KEYBOARD_KEY_1 ;Performs Cycle Cancel
Kb_F1                         IS SV_PC_KEYBOARD_KEY_2
Kb_F2                         IS SV_PC_KEYBOARD_KEY_3
Kb_F3                         IS SV_PC_KEYBOARD_KEY_4
Kb_F4                         IS SV_PC_KEYBOARD_KEY_5
Kb_F5                         IS SV_PC_KEYBOARD_KEY_6
Kb_F6                         IS SV_PC_KEYBOARD_KEY_7
Kb_F7                         IS SV_PC_KEYBOARD_KEY_8
Kb_F8                         IS SV_PC_KEYBOARD_KEY_9
Kb_F9                         IS SV_PC_KEYBOARD_KEY_10
Kb_F10                        IS SV_PC_KEYBOARD_KEY_11
Kb_F11                        IS SV_PC_KEYBOARD_KEY_12
Kb_F12                        IS SV_PC_KEYBOARD_KEY_13
Kb_Prt_Scrn                   IS SV_PC_KEYBOARD_KEY_14
Kb_Scrl_Lck                   IS SV_PC_KEYBOARD_KEY_15
Kb_Break                      IS SV_PC_KEYBOARD_KEY_16
Kb_Num_Lock                   IS SV_PC_KEYBOARD_KEY_34
Kb_1                          IS SV_PC_KEYBOARD_KEY_18
Kb_2                          IS SV_PC_KEYBOARD_KEY_19
Kb_3                          IS SV_PC_KEYBOARD_KEY_20
Kb_4                          IS SV_PC_KEYBOARD_KEY_21
Kb_5                          IS SV_PC_KEYBOARD_KEY_22
Kb_6                          IS SV_PC_KEYBOARD_KEY_23
Kb_7                          IS SV_PC_KEYBOARD_KEY_24
Kb_8                          IS SV_PC_KEYBOARD_KEY_25
Kb_9                          IS SV_PC_KEYBOARD_KEY_26
Kb_0                          IS SV_PC_KEYBOARD_KEY_27
Kb_10_Key_Div                 IS SV_PC_KEYBOARD_KEY_35
Kb_10_Key_Mlt                 IS SV_PC_KEYBOARD_KEY_36
Kb_10_Key_Sub                 IS SV_PC_KEYBOARD_KEY_37
Kb_10_Key_0                   IS SV_PC_KEYBOARD_KEY_103
Kb_10_Key_1                   IS SV_PC_KEYBOARD_KEY_88
Kb_10_Key_2                   IS SV_PC_KEYBOARD_KEY_89
Kb_10_Key_3                   IS SV_PC_KEYBOARD_KEY_90
Kb_10_Key_4                   IS SV_PC_KEYBOARD_KEY_71
Kb_10_Key_5                   IS SV_PC_KEYBOARD_KEY_72
Kb_10_Key_6                   IS SV_PC_KEYBOARD_KEY_73
Kb_10_Key_7                   IS SV_PC_KEYBOARD_KEY_55
Kb_10_Key_8                   IS SV_PC_KEYBOARD_KEY_56
Kb_10_Key_9                   IS SV_PC_KEYBOARD_KEY_57
Kb_10_Key_Dec_Pt              IS SV_PC_KEYBOARD_KEY_104
Kb_10_Key_Plus                IS SV_PC_KEYBOARD_KEY_58
Kb_Num_Enter                  IS SV_PC_KEYBOARD_KEY_91
Kb_L_Sq_Bracket               IS SV_PC_KEYBOARD_KEY_49
Kb_R_Sq_Bracket               IS SV_PC_KEYBOARD_KEY_50
Kb_Hyphen                     IS SV_PC_KEYBOARD_KEY_28
Kb_Equals                     IS SV_PC_KEYBOARD_KEY_29
Kb_Comma                      IS SV_PC_KEYBOARD_KEY_82
Kb_Period                     IS SV_PC_KEYBOARD_KEY_83
Kb_Slash                      IS SV_PC_KEYBOARD_KEY_84
Kb_Backslash                  IS SV_PC_KEYBOARD_KEY_86
Kb_Enter                      IS SV_PC_KEYBOARD_KEY_51

;------------------------------------------------------------------------------
;  System variables:  Virtual Control Panel Events
;------------------------------------------------------------------------------
;Maximum Number of Skin Events is 255

SkinSpinOverPlus_M            IS SV_SKIN_EVENT_1  ; Row  1 Column 1
SkinSpinAutoMan_M             IS SV_SKIN_EVENT_2  ; Row  1 Column 2
SkinAux1_M                    IS SV_SKIN_EVENT_3  ; Row  1 Column 3
SkinAux2_M                    IS SV_SKIN_EVENT_4  ; Row  1 Column 4
SkinAux3_M                    IS SV_SKIN_EVENT_5  ; Row  1 Column 5
SkinSpin100_M                 IS SV_SKIN_EVENT_6  ; Row  2 Column 1
SkinSpinCW_M                  IS SV_SKIN_EVENT_7  ; Row  2 Column 2
SkinAux4_M                    IS SV_SKIN_EVENT_8  ; Row  1 Column 6
SkinAux5_M                    IS SV_SKIN_EVENT_9  ; Row  2 Column 3
SkinAux6_M                    IS SV_SKIN_EVENT_10 ; Row  2 Column 4
SkinSpinOverMinus_M           IS SV_SKIN_EVENT_11 ; Row  3 Column 1
SkinSpinCCW_M                 IS SV_SKIN_EVENT_12 ; Row  3 Column 2
SkinAux7_M                    IS SV_SKIN_EVENT_13 ; Row  2 Column 5
SkinAux8_M                    IS SV_SKIN_EVENT_14 ; Row  2 Column 6
SkinAux9_M                    IS SV_SKIN_EVENT_15 ; Row  3 Column 3
SkinSpinStop_M                IS SV_SKIN_EVENT_16 ; Row  4 Column 1
SkinSpinStart_M               IS SV_SKIN_EVENT_17 ; Row  4 Column 2
SkinAux10_M                   IS SV_SKIN_EVENT_18 ; Row  3 Column 4
SkinAux11_M                   IS SV_SKIN_EVENT_19 ; Row  3 Column 5
SkinAux12_M                   IS SV_SKIN_EVENT_20 ; Row  3 Column 6
SkinCoolAutoMan_M             IS SV_SKIN_EVENT_21 ; Row  5 Column 1
SkinCoolFlood_M               IS SV_SKIN_EVENT_22 ; Row  5 Column 2
SkinCoolMist_M                IS SV_SKIN_EVENT_23 ; Row  5 Column 3
SkinVacOn_M                   IS SV_SKIN_EVENT_24 ; Row  5 Column 4
SkinLimitDefeat_M             IS SV_SKIN_EVENT_25 ; Row  5 Column 5
SkinIncCont_M                 IS SV_SKIN_EVENT_26 ; Row  6 Column 1
SkinX1_M                      IS SV_SKIN_EVENT_27 ; Row  6 Column 2
SkinX10_M                     IS SV_SKIN_EVENT_28 ; Row  6 Column 3
SkinX100_M                    IS SV_SKIN_EVENT_29 ; Row  6 Column 4
SkinMPG_M                     IS SV_SKIN_EVENT_30 ; Row  6 Column 5
SkinJogAx4Plus_M              IS SV_SKIN_EVENT_31 ; Row  7 Column 1
SkinR7C2_M                    IS SV_SKIN_EVENT_32 ; Row  7 Column 2
SkinJogAx2Plus_M              IS SV_SKIN_EVENT_33 ; Row  7 Column 3
SkinR7C4_M                    IS SV_SKIN_EVENT_34 ; Row  7 Column 4
SkinJogAx3Plus_M              IS SV_SKIN_EVENT_35 ; Row  7 Column 5
SkinR8C1_M                    IS SV_SKIN_EVENT_36 ; Row  8 Column 1
SkinJogAx1Minus_M             IS SV_SKIN_EVENT_37 ; Row  8 Column 2
SkinFastSlowJog_M             IS SV_SKIN_EVENT_38 ; Row  8 Column 3
SkinJogAx1Plus_M              IS SV_SKIN_EVENT_39 ; Row  8 Column 4
SkinR8C5_M                    IS SV_SKIN_EVENT_40 ; Row  8 Column 5
SkinJogAx4Minus_M             IS SV_SKIN_EVENT_41 ; Row  9 Column 1 ;set_x_0
SkinR9C2_M                    IS SV_SKIN_EVENT_42 ; Row  9 Column 2
SkinJogAx2Minus_M             IS SV_SKIN_EVENT_43 ; Row  9 Column 3
SkinR9C4_M                    IS SV_SKIN_EVENT_44 ; Row  9 Column 4
SkinJogAx3Minus_M             IS SV_SKIN_EVENT_45 ; Row  9 Column 5
SkinCycleCancel_M             IS SV_SKIN_EVENT_46 ; Row 10 Column 1
SkinSingleBlock_M             IS SV_SKIN_EVENT_47 ; Row 10 Column 2
SkinToolCheck_M               IS SV_SKIN_EVENT_48 ; Row 10 Column 3
SkinFeedHold_M                IS SV_SKIN_EVENT_49 ; Row 10 Column 4
SkinCycleStart_M              IS SV_SKIN_EVENT_50
SkinResetOk_M                 IS SV_SKIN_EVENT_51
SkinFeedOverMinus_M           IS SV_SKIN_EVENT_52
SkinFeedOver100               IS SV_SKIN_EVENT_53
SkinFeedOverPlus_M            IS SV_SKIN_EVENT_54
KeepAlive_M                   IS SV_SKIN_EVENT_55
SkinResetButtonPressed_M      IS SV_SKIN_EVENT_56
OverrideRapidsEnabled_M       IS SV_SKIN_EVENT_58
OverrideRapidsDisabled_M      IS SV_SKIN_EVENT_59
VirtualJpRunning_M            IS SV_SKIN_EVENT_60
UsingVirtualOverride_M        IS SV_SKIN_EVENT_61
SkinResetSet_M                IS SV_SKIN_EVENT_62
FeedOverLT100                 IS SV_SKIN_EVENT_63
FeedOverEQ100                 IS SV_SKIN_EVENT_64
FeedOverGT100                 IS SV_SKIN_EVENT_65
SkinAux13_M                   IS SV_SKIN_EVENT_66  ; Row  4 Column 3
SkinAux14_M                   IS SV_SKIN_EVENT_67  ; Row  4 Column 4
SkinAux15_M                   IS SV_SKIN_EVENT_68  ; Row  4 Column 5
SkinAux16_M                   IS SV_SKIN_EVENT_69  ; Row  4 Column 6
SkinTailStock_M				  IS SV_SKIN_EVENT_70  ; Row  3 Column 5
SkinOpenChuck_M				  IS SV_SKIN_EVENT_71  ; Row  4 Column 4
SkinCloseChuck_M			  IS SV_SKIN_EVENT_72  ; Row  4 Column 5
SkinWorklight_M				  IS SV_SKIN_EVENT_73
SkinColletOpenClose_M		  IS SV_SKIN_EVENT_74
SkinAirBlowNozzle_M			  IS SV_SKIN_EVENT_75
SkinSpindleHigh_M			  IS SV_SKIN_EVENT_76
SkinSpindleMed_M			  IS SV_SKIN_EVENT_77
SkinSpindleLow_M			  IS SV_SKIN_EVENT_78
SkinSpindleBrake_M			  IS SV_SKIN_EVENT_79

CncAndPlcActive_M             IS SV_SKIN_EVENT_80
DryRun_M			          IS SV_SKIN_EVENT_81
RapidOver_M					  IS SV_SKIN_EVENT_82
SkinATCIndexPlus_M			  IS SV_SKIN_EVENT_83
SkinATCIndexMinus_M			  IS SV_SKIN_EVENT_84
SkinTurretIndex_M			  IS SV_SKIN_EVENT_85
SkinTorchOn_M				  IS SV_SKIN_EVENT_86
SkinTorchOff_M				  IS SV_SKIN_EVENT_87
SkinTHCAuto_M				  IS SV_SKIN_EVENT_88
SkinTorchTest_M				  IS SV_SKIN_EVENT_89
SkinTorchRestartMode_M		  IS SV_SKIN_EVENT_90 ;Required for Restart Feature
SkinTorchRestartForward_M     IS SV_SKIN_EVENT_91 ;Required for Forward in Cut Feature
SkinTorchRestartBackward_M    IS SV_SKIN_EVENT_92 ;Required for Backward in Cut Feature

EStopPressed_M                IS SV_SKIN_EVENT_93
UsingKbOverride_M             IS SV_SKIN_EVENT_94
;SetMem_M                      IS MEM795 ;Used for skinning
;RstMem_M                      IS MEM796 ;Used for skinning
;SetOut_M                      IS MEM797 ;Used for skinning
;RstOut_M                      IS MEM798 ;Used for skinning
SpinBrakeMode_M               IS SV_SKIN_EVENT_99

SkinDebugTest_M				  IS SV_SKIN_EVENT_100
SkinRestartCycleStart_M		  IS SV_SKIN_EVENT_101 ;Used for Restart Feature
SkinRestartCycleCancel_M      IS SV_SKIN_EVENT_102 ;Used for Restart Feature
SkinTorchCheck_M              IS SV_SKIN_EVENT_103
SkinRestartModeCancel_M       IS SV_SKIN_EVENT_104 ;Used for Restart Feature
SkinResetTorchCheck_M         IS SV_SKIN_EVENT_105 ;Used for Restart Feature
SkinBreakawayDisable_M        IS SV_SKIN_EVENT_106 ;Used for Restart Feature
SkinJogAx1MinusAx2Plus_M      IS SV_SKIN_EVENT_107
SkinJogAx1Ax2Plus_M           IS SV_SKIN_EVENT_108
SkinJogAx1Ax2Minus_M          IS SV_SKIN_EVENT_109
SkinJogAx1PlusAx2Minus_M      IS SV_SKIN_EVENT_110

SkinFeedOver75_M              IS SV_SKIN_EVENT_111
SkinFeedOver50_M              IS SV_SKIN_EVENT_112
SkinFeedOver25_M              IS SV_SKIN_EVENT_113

SkinManualLube_M			  IS SV_SKIN_EVENT_200
SkinClampOn_M				  IS SV_SKIN_EVENT_201
SkinDustCollection_M		  IS SV_SKIN_EVENT_202
SkinCutoff_M				  IS SV_SKIN_EVENT_203
SkinPartChute_M				  IS SV_SKIN_EVENT_204
SkinToolUnclamp_M			  IS SV_SKIN_EVENT_205
SkinDustFoot_M				  IS SV_SKIN_EVENT_206
SkinLaserAlign_M			  IS SV_SKIN_EVENT_207
SkinPopUpPins_M				  IS SV_SKIN_EVENT_208
SkinSpindleCooling_M		  IS SV_SKIN_Event_209
SkinToolRelease_M			  IS SV_SKIN_EVENT_210

;------------------------------------------------------------------------------
; M functions - The System Variables in this section inform the
; PLC that an M function has been requested.
;------------------------------------------------------------------------------
M3                            IS SV_M94_M95_1 ;(Spindle CW)
M4                            IS SV_M94_M95_2 ;(Spindle CCW)
M8                            IS SV_M94_M95_3 ;(Flood On)
M10L                          IS SV_M94_M95_4 ;SET OpenChuck, RST CloseChuck
M7                            IS SV_M94_M95_5 ;(Mist)
M11L                          IS SV_M94_M95_6 ;RST OpenChuck, SET CloseChuck
M6                            IS SV_M94_M95_7 ;
ManualLubePump_SV             IS SV_M94_M95_8 ;Activates LubePump Manually
M3P                           IS SV_M94_M95_9 ;
M10M                          IS SV_M94_M95_10; SET TurnClampOn, M11 RST TurnClampOn
;                             IS SV_M94_M95_11;
;                             IS SV_M94_M95_12;
M13                           IS SV_M94_M95_13; Cutoff On, M14 Cutoff Off
;                             IS SV_M94_M95_14;
M15                           IS SV_M94_M95_15; M15 Tool Unclamp On, M16 Tool Unclamp Off
;                             IS SV_M94_M95_16;

M18							  IS SV_M94_M95_18;

M19                           IS SV_M94_M95_19;(Spindle Orient), M20 Off
;                             IS SV_M94_M95_20;
;PutbackComplete_SV				IS SV_M94_M95_21;

M22                           IS SV_M94_M95_22; Turn on PartChute, M23 off
;                             IS SV_M94_M95_23;

M27                           IS SV_M94_M95_27; Turn on VacuumOn, M28 off

DustFootActivate_SV           IS SV_M94_M95_28; DustFootActivate Output
LaserAlignActivate_SV		  IS SV_M94_M95_29; LaserAlignActivate Output
PopUpPins_SV				  IS SV_M94_M95_30; PopUpPins Output
SpindleCooling_SV			  IS SV_M94_M95_31; SpindleCooling Output

M32							  IS SV_M94_M95_32; TailStockInOut On, M33 TailStockInOut Off

M35                           IS SV_M94_M95_35; SET DustCollectionOn, M36 RST DustCollectionOn

M35P_SV						  IS SV_M94_M95_36; TorchTHCEnable

M37                           IS SV_M94_M95_37; Set Laser Enable
PWMSelect_SV                  IS SV_M94_m95_38; Set PWMSelect
LaserReset_SV				  IS SV_M94_M95_39; Set LaserReset

PutbackComplete_SV			  IS SV_M94_M95_40;
M41                           IS SV_M94_M95_41 ;(Spindle Low Range)
M42                           IS SV_M94_M95_42 ;(Spindle Medium Low Range)
M43                           IS SV_M94_M95_43 ;(Spindle Medium High Range)

M51_SV                        IS SV_M94_M95_51 ;(C-Axis Enable)

M61                           IS SV_M94_M95_61; OUTPUT1 (NOT the same as OUT1), M81 Off
M62                           IS SV_M94_M95_62; OUTPUT2 (NOT the same as OUT2), M82 Off
M63                           IS SV_M94_M95_63; OUTPUT3 (NOT the same as OUT3), M83 Off
M64                           IS SV_M94_M95_64; OUTPUT4 (NOT the same as OUT4), M84 Off
M65                           IS SV_M94_M95_65; OUTPUT5 (NOT the same as OUT5), M85 Off
M66                           IS SV_M94_M95_66; OUTPUT6 (NOT the same as OUT6), M86 Off
M67                           IS SV_M94_M95_67; OUTPUT7 (NOT the same as OUT7), M87 Off
M68                           IS SV_M94_M95_68; OUTPUT8 (NOT the same as OUT8), M88 Off

M80_SV							IS SV_M94_M95_80;
M81_SV							IS SV_M94_M95_81;

VCalibration_SV				  IS SV_M94_M95_88
PLOT_SV						  IS SV_M94_M95_89	;Debug

DisableTouchFault_SV          IS SV_M94_M95_100
DisableAxis1Limit             IS SV_M94_M95_101
DisableAxis2Limit             IS SV_M94_M95_102
DisableAxis3Limit             IS SV_M94_M95_103
DisableAxis4Limit             IS SV_M94_M95_104

M94M95111_SV					  IS SV_M94_M95_111
M94M95112_SV					  IS SV_M94_M95_112
M94M95113_SV					  IS SV_M94_M95_113
M94M95114_SV					  IS SV_M94_M95_114
M94M95115_SV					  IS SV_M94_M95_115
M94M95116_SV					  IS SV_M94_M95_116
M94M95117_SV					  IS SV_M94_M95_117
M94M95118_SV					  IS SV_M94_M95_118
M94M95119_SV					  IS SV_M94_M95_119
M94M95120_SV					  IS SV_M94_M95_120
M94M95121_SV					  IS SV_M94_M95_121
M94M95122_SV					  IS SV_M94_M95_122
M94M95123_SV					  IS SV_M94_M95_123
M94M95124_SV					  IS SV_M94_M95_124
M94M95125_SV					  IS SV_M94_M95_125
M94M95126_SV					  IS SV_M94_M95_126

;Spindle CW			M3, M5
;Spindle CCW		M4, M5
;ToolChange			M6
;Mist				M7, M9
;Flood				M8, M9
;TurnClampOn        M10, M11 ;Selectable Only in Mill
;OpenChuck			M10 ;Selectable Only in Lathe
;CloseChuck			M11 ;Selectable Only in Lathe
;Cutoff				M13, M14
;ToolUnclamp		M15, M16
;Spindle Orient		M19, M20
;PartChute          M22, M23
;VacuumOn           M27, M28
;TailStockInOut		M32, M33
;DustCollectionOn   M35, M36
;Custom             M37, M38
;Low Gear Range		M41
;Med Gear Range		M42
;High Gear Range	M43
;OUTPUT1            M61, M81
;OUTPUT2            M62, M82
;OUTPUT3            M63, M83
;OUTPUT4            M64, M84
;OUTPUT5            M65, M85
;OUTPUT6            M66, M86
;OUTPUT7            M67, M87
;OUTPUT8            M68, M88

;For Optional Custom Macros
;ManualLubePump_SV
;DustFootActivate_SV
;LaserAlignActivate_SV
;PopUpPins_SV
;SpindleCooling_SV

;Currently Not Used
;LockSpindle

;------------------------------------------------------------------------------
;                              Word Definitions
;------------------------------------------------------------------------------
SkinFeedOverride_W1				IS W1
TotalOffsetAppliedFW			IS W2
JogIncMultiplier				IS W3
ZJogOffset						IS W4
ZAxisEncoder					IS W5
TorchVoltage_W					IS W6
TargetVoltage_W					IS W7
Last_TorchKnob_W				IS W8

ShuttleAxisSelect_W				IS W10
ShuttleResumeFeedOver_W			IS W11
SkinningInt12_W					IS W12
TwelveBitSpeed_W				IS W13
FaultMsg_W						IS W14
ErrorMsg_W						IS W15
InfoMsg_W						IS W16

SpinOverride_W                IS W19
Mem_W                         IS W20
Out_W                         IS W21
MpgOffsetWord                 IS W23

SpindleRange_W                IS W24  ; 1 = low ... 4 = high
PrevFeedOverride_W            IS W25

UsbAxisMonitor_W        	    IS W26
UsbScaleMonitor_W			        IS W27

AtcType_W                     IS W28
KbOverride_W                  IS W29
FeedrateKnob_W                IS W30
FinalFeedOverride_W           IS W31
Last_FeedrateKnob_W           IS W32
LastKbOverride_W              IS W33
LastSkinFeedOverride_W        IS W34
UsbJog_W                      IS W35

MiniPLCStatus_W               IS W36
JogKeyCfg_W                   IS W37

UsbButtonMonitor				IS W38
UsbWheelCurrent					IS W39
UsbWheelLast					IS W40
UsbWheelDelta					IS W41
UsbMpgActiveAxes_W            	IS W42
DefaultJogging_W              	IS W43

LastCarouselDir_W				IS W49
PutBackPosition_W				IS W50
CurrentTurretPosition_W       	IS W52
RequestedTurretPosition_W     	IS W53
CurrentCarouselPosition_W		IS W54
RequestedCarouselPosition_W		IS W55

CycloneStatus_W               IS W56
THCEncoderStatus_W            IS W9;57

PLC_Fault_W                   IS W61
PLCFaultAddr_W                IS W62
BadMsg_W                      IS W63

Lube_W                        IS W65
P148Value_W                   IS W66
P146Value_W                   IS W67
P170Value_W                   IS W68
LubeAccumTime_W               IS W69
LubeM_W                       IS W70
LubeS_W                       IS W71
P985Value_W					  IS W72
P415Value_W                   IS W73

Inputs1_16_W                  IS W74
Inputs33_48_W				  IS W75
Inputs49_64_W				  IS W76
Inputs65_80_W				  IS W77
;Inputs81_96_W                 IS W78
;Inputs97_112_W				  IS W79
InvertedInputs911_W           IS W80
InvertedInputs913_W			  IS W81
InvertedInputs914_W			  IS W82
InvertedInputs915_W			  IS W83
;InvertedInputs9??1_W			  IS W84
;InvertedInputs9??2_W		   	  IS W85
Limit_Invert_W			      IS W86
ETHER1616_ALIVE_W             IS W87
P419Value_W						IS W88
P523Value_W                     IS W89

PValue_W                        IS W92

;------------------------------------------------------------------------------
P831Value_W					  	IS W101
P832Value_W					  	IS W102
P833Value_W					  	IS W103
P834Value_W					  	IS W104
P835Value_W					  	IS W105
P836Value_W					  	IS W106
P837Value_W					  	IS W107
P838Value_W					  	IS W108
P839Value_W					  	IS W109
P840Value_W					  	IS W110
P841Value_W					  	IS W111
P842Value_W					  	IS W112
P843Value_W					  	IS W113
P844Value_W					  	IS W114
P845Value_W					  	IS W115
P846Value_W					  	IS W116

;------------------------------------------------------------------------------
;           Word Definitions cont. (f32)
;------------------------------------------------------------------------------
SkinningF1_FW                 IS FW1
XYVelocity_Ratio_FW           IS FW2
FeedRate_FW					  IS FW3
Velocity_Threshold_FW		  IS FW4

SpinRangeAdjust_FW            IS FW13
RPMPerBit_FW                  IS FW14
CfgMinSpeed_FW                IS FW15
CfgMaxSpeed_FW                IS FW16
TwelveBitSpeed_FW             IS FW17
SpinSpeedCommand_FW           IS FW18
SpinSensorSpeed_FW			  IS FW19
SpinSensorTimer_FW			  IS FW20

SkinningDF1_FW                IS DFW1
SkinningDF2_FW                IS DFW2
SkinningDF3_FW                IS DFW3
SkinningDF4_FW                IS DFW4
SkinningDF5_FW                IS DFW5
SkinningDF6_FW                IS DFW6
SkinningDF7_FW                IS DFW7
SkinningDF8_FW                IS DFW8
SkinningDF9_FW                IS DFW9
SkinningDF10_FW               IS DFW10
SkinningDF11_FW               IS DFW11

;------------------------------------------------------------------------------
;            One Shot Definitions
;------------------------------------------------------------------------------
IncrContPD                    	IS PD1
SlowFastPD                    	IS PD2
MpgPD                         	IS PD3
SingleBlockPD                 	IS PD4
FeedHoldPD                    	IS PD5
SpinAutoManPD                 	IS PD6
SpinOverPlusPD                 	IS PD7
SpinOverMinusPD               	IS PD8
SpinOver100PD                 	IS PD9
ProbePD                       	IS PD10
SaveJogModePD                 	IS PD11
AutoSpindlePD                 	IS PD12
AutoCoolantPD                 	IS PD13
F9PD                          	IS PD14
x1JogPD                       	IS PD15
x10JogPD                      	IS PD16
x100JogPD                     	IS PD17
Aux11KeyPD                    	IS PD18
RapidOverPD                   	IS PD19
ResetOkPD                     	IS PD20
CoolantAutoManualPD           	IS PD21
CoolantFloodPD                	IS PD22
CoolantMistPD                 	IS PD23
ToolCheckPD                   	IS PD24
JogProbeFaultPD               	IS PD25
RigidTapPD                    	IS PD26
SkinResetDetectedPD           	IS PD27
SpindleBrakePD                	IS PD28
KbIncreaseJogIncPD            	IS PD29
KbDecreaseJogIncPD            	IS PD30

TailStockPD					  	IS PD31
OpenChuckPD					  	IS PD32
CloseChuckPD				  	IS PD33

LimitOverridePD               	IS PD34
StopRunningPD                 	IS PD35
SoftwareReadyPD               	IS PD36
SkinFeedOverMinusPD           	IS PD37
SkinFeedOverPlusPD            	IS PD38
ShuttleAxisSelectPD           	IS PD39
MpgOffsetPD                   	IS PD40

Aux1PD                        	IS PD41
Aux2PD                        	IS PD42
Aux3PD                        	IS PD43
Aux4PD                        	IS PD44
Aux5PD                        	IS PD45
Aux6PD                        	IS PD46
Aux7PD                        	IS PD47
Aux8PD                        	IS PD48
Aux9PD                        	IS PD49
Aux10PD                       	IS PD50
Aux11PD                       	IS PD51
Aux12PD                       	IS PD52
MpgCancelPD                   	IS PD53
ClearOffsetPD                 	IS PD54
Aux13PD                       	IS PD55
Aux14PD                       	IS PD56
Aux15PD                       	IS PD57
Aux16PD                       	IS PD58
VacOnPD                       	IS PD59
LimitDefeatPD                 	IS PD60

MpgMacro1PD                   	IS PD61
MpgMacro2PD                   	IS PD62
MpgMacro3PD                   	IS PD63
MpgMacro4PD                   	IS PD64
SkinResetOkPD                 	IS PD65
ResetPD                       	IS PD66
ResetSetPD                    	IS PD67
ResetResetPD                  	IS PD68

WorklightPD					  	IS PD69
ManualLubePD				  	IS PD70
ClampOnPD					  	IS PD71
DustCollectionPD			  	IS PD72
CutOffPD					  	IS PD73
PartchutePD					  	IS PD74
DustFootPD					  	IS PD75
LaserAlignPD				  	IS PD76
PopUpPinsPD					  	IS PD77
SpindleCoolingPD			  	IS PD78
ColletOpenClosePD			  	IS PD79
AirBlowNozzlePD				  	IS PD80
DryRunPD				      	IS PD81
ChuckFootPedal_PD			  	IS PD82
TurretIndexPD					IS PD83
ATCIndexMinusPD					IS PD84
ATCIndexPlusPD					IS PD85
RPMSensorPD						IS PD86
ToolCounterPD					IS PD90
ToolTimerPD						IS PD91
M6PD							IS PD92
OffsetReset_PD					IS PD93

THCAuto_PD						IS PD94
PLOT_PD							IS PD95
TorchTHCEnabled_PD				IS PD96
THCAutoOn_PD					IS PD97
THCAutoOff_PD					IS PD98
TorchTripped_PD					IS PD99
TorchCleared_PD					IS PD100
TorchRestartMode_PD				IS PD101
RestartCycleStart_PD			IS PD102
TorchBreakaway_PD               IS PD103
TorchRestartModeOff_PD          IS PD104
TouchOffStarted_PD              IS PD105


;------------------------------------------------------------------------------
;                    Timer Definitions
;------------------------------------------------------------------------------
; 1000 = 1 second for all timers.
;
MsgClear_T                    	IS T1
SleepTimer                    	IS T2
CycloneStatus_T               	IS T3
Initialize_T                  	IS T4
ErrorFlag_T                   	IS T5
TriggerPause_T                	IS T6
SpindleBrakeTimer             	IS T7
OverrideMsgTimer              	IS T8
DriveFaultTimer               	IS T9
SkinFeedOverTimer             	IS T10
KeepAliveTimer                	IS T11
OverrideLimitTimer            	IS T12
LubeM_T                       	IS T13
LubeS_T                       	IS T14
ChuckTimer                    	IS T15
SpindleLockTimer              	IS T16
PartchuteTimer                	IS T17
CutOffTimer                   	IS T18
MessageTimer                  	IS T19
TurretReverseTimer            	IS T20
ToolTurretOffCurrentToolTimer   IS T21
ToolChangeTimeOutTimer        	IS T22
ProbeTripTimer                	IS T23
NoMacroKeyPressedTimer        	IS T24
TestTimer                     	IS T25
OrientTimer                   	IS T26
ToolUnclampTimer              	IS T27
TailOut_T					  	IS T28
SafetyDoorLock_T			  	IS T29
SafetyDoorLockConfirm_T		  	IS T30
LightTurnOnTimer				IS T31
LightTurnOffTimer				IS T32
CountSkipTimer			  	  	IS T33
ToolChangeTimer					IS T34
CarouselInOutTimer_T			IS T35
RPMSensorTimer_T				IS T36
TorchTHCEnable_T				IS T37
TorchDisconnect_T				IS T38
TorchConnect_T					IS T39
TorchArcLost_T					IS T40
TorchDiveReset_T				IS T41
SpinOverTimer_T					IS T42
ButtonPressed_T                 IS T43
TorchMarking_T                  IS T44
SpindleFaultTimer_T             IS T45
SpindleCooling_T                IS T46

;------------------------------------------------------------------------------
;                       Fast Stage Definitions
;------------------------------------------------------------------------------
RPMSensorStage				  IS FSTG1
TorchStage					  IS FSTG2

;------------------------------------------------------------------------------
;                       Stage Definitions
;------------------------------------------------------------------------------
WatchDogStage                 IS STG1
InitialStage                  IS STG2
JogPanelStage                 IS STG3
MainStage                     IS STG4
AxesEnableStage               IS STG5
StandardSpindleStage          IS STG6
G540SpindleStage              IS STG7
SpindleBrakeStage             IS STG8
MPGStage                      IS STG9
ShuttleStage                  IS STG10
TorchSectionStage             IS STG11

LoadParametersStage           IS STG20
KeyboardEventsStage           IS STG21
LubeUsePumpTimersStage        IS STG23
LubeUsePLCTimersStage         IS STG24
LimitOverrideStage            IS STG25
JogKeysNormalStage            IS STG26
JogKeysInvert2Stage           IS STG27
JogKeysSwappedStage           IS STG28
JogKeysSwapAndInvert2Stage    IS STG29
ReportCarouselPositionStage    IS STG30
ToolChangeStage               IS STG31
ResetCarouselStage             IS STG32
RequestedBinPositionStage             IS STG33
AtcIncrementalStage           IS STG34
IndexTurretStage              IS STG35
SetRequestedPositionStage     IS STG36
TailStockStage				  IS STG37
RotateTurretStage				IS STG38
HomeTurretStage					IS STG39							

RotateTurretStage2				IS STG41
RotateTurretStage3				IS STG42

MonitorATCStage					IS STG50
ATCPositionReportStage			IS STG51
MonitorIndexATCRequestStage		IS STG52
CarouselDirectionStage			IS STG53
RotateCarouselStage				IS STG54

ATCGrayCodeStage				IS STG55

DoorInterlockStage			      IS STG56

PairedHomingStage             IS STG70
ZriHomeStage                  IS STG71
LimitAllStage                 IS STG73
UsbMpgStage                   IS STG74
HomeAllStage                  IS STG75

MessageStage                  IS STG90
ShowFaultStage                IS STG91
ShowErrorStage                IS STG92
ShowInfoStage                 IS STG93
BadMsgStage                   IS STG94

;#############################################################################
;                         Program Start
;#############################################################################

;==============================================================================
                          WatchDogStage
;==============================================================================

; Handle PLC executor faults. The only way to reset a PLC executor fault
; is to reboot the MPU11.
IF SV_PLC_FAULT_STATUS != 0
  THEN PLC_Fault_W    = SV_PLC_FAULT_STATUS,
       PLCFaultAddr_W = SV_PLC_FAULT_ADDRESS,
       FaultMsg_W    = PLC_EXECUTOR_FLT_MSG, MSG FaultMsg_W,
       SET PLCExecutorFault_M, RST MessageStage, SET SV_STOP

; Handle software exit.
IF !SV_PC_SOFTWARE_READY ;&& (SV_PLC_FAULT_STATUS == 0)
  THEN SET SoftwareNotReady_M, SET SkinResetSet_M, RST SkinResetOK_M,
       SET SV_STOP,
       FaultMsg_W = SOFTWARE_EXIT_MSG

IF SV_PC_SOFTWARE_READY && SoftwareNotReady_M && (!EstopOK || SkinResetSet_M)
  THEN RST SoftwareNotReady_M,
       RST ProbeTripTimer,
       SET ProbeTripTimer

; If the memory bit we call "True" is not yet true, it is because this is
; the first scan after power up.  In that case execute InitialStage.
IF !True THEN SET InitialStage

;==============================================================================
                          InitialStage
;==============================================================================
IF SV_MACHINE_PARAMETER_822 > 0 THEN SET HomeAllStage

IF 1==1 THEN SET True,
             SET OnAtPowerUp_M,
             SET AxesEnableStage,
             SET MainStage,
             SET JogPanelStage,
             SET LoadParametersStage,
             SET MPGStage,
             SET PLCBus_Oe_M,
			 SET TailStockStage,
             RST DriveComFltIn_M,
             RST DriveComFltOut_M,
             RST PLCFault_M,
             CycloneStatus_T = 300,
             FaultMsg_W = MSG_CLEARED_MSG,
             RST BadMsgStage,
             SET MessageStage,
			 SET MonitorATCStage,
             Initialize_T = 1000, SET Initialize_T,
             ErrorFlag_T = 1000,
             MsgClear_T = 100,
			 TailOut_T = 15000,
			 RPMSensorTimer_T = 0,
			 SafetyDoorLockConfirm_T = 2000,
			 SafetyDoorLock_T = 3000,
             ProbeTripTimer = 1000, SET ProbeTripTimer,
			 LightTurnOnTimer = 1500,
			 LightTurnOffTimer = 5000,
			 CarouselInOutTimer_T = 10000,
             TorchArcLost_T = 500,
             TorchDiveReset_T = 10,
             TorchDisconnect_T = 50,
             TorchConnect_T = 1000,
			 SpinOverTimer_T = 500,
			 ButtonPressed_T = 200,
			 NoMacroKeyPressedTimer = 100,
             RST InitialStage

;			 PairedHomingStage             IS STG70
;            ZriHomeStage                  IS STG71
;            LimitAllStage                 IS STG73
;            UsbMpgStage                   IS STG74

IF (ATCType_W == 1) THEN CurrentCarouselPosition_W = SV_ATC_CAROUSEL_POSITION,
						 RequestedCarouselPosition_W = CurrentCarouselPosition_W,
						 PutBackPosition_W = SV_ATC_TOOL_IN_SPINDLE

;==============================================================================
                      LoadParametersStage
;==============================================================================
; There are two methods of control for the lube pump and they are set by CNC12
; Machine Parameter 179, where the value is between 0 - 65535 and is formatted
; as MMMSS where MMM is a time in minutes and SS is a time in seconds.
;
; METHOD 1 (SS == 0) For lube pumps with internal timers.
; METHOD 2 (SS != 0) For lube pumps with no timers (controlled solely by PLC).
;
; Load lube pump times from P179 and convert to milliseconds.
IF True THEN Lube_W = SV_MACHINE_PARAMETER_179,
             LubeM_W = (Lube_W / 100) * 60000,
             LubeS_W = (Lube_W % 100) * 1000
			 
;Set MPG Settings
IF True THEN PValue_W = SV_MACHINE_PARAMETER_19
IF True THEN BITTST PValue_W 1 MpgX100LockOut_M

; Set the appropriate stage according to method of control
IF LubeS_W == 0 THEN SET LubeUsePumpTimersStage, RST LubeUsePLCTimersStage
IF LubeS_W != 0 THEN SET LubeUsePLCTimersStage, RST LubeUsePumpTimersStage

IF True THEN P146Value_W = SV_MACHINE_PARAMETER_146,  ; Feed hold threshold
             P148Value_W = SV_MACHINE_PARAMETER_148,  ; Misc Jogging Options
             P170Value_W = SV_MACHINE_PARAMETER_170  ; Enable Keyboard Jogging

IF True THEN (SV_ENABLE_IO_OVERRIDE),
             SV_INVERT_INP17_32_BITS     = SV_MACHINE_PARAMETER_912,
             SV_FORCE_INP1_16_BITS       = SV_MACHINE_PARAMETER_916,
             SV_FORCE_INP17_32_BITS      = SV_MACHINE_PARAMETER_917,
             SV_FORCE_INP33_48_BITS      = SV_MACHINE_PARAMETER_918,
             SV_FORCE_INP49_64_BITS      = SV_MACHINE_PARAMETER_919,
             SV_FORCE_INP65_80_BITS      = SV_MACHINE_PARAMETER_920,
             SV_FORCE_ON_OUT1_16_BITS    = SV_MACHINE_PARAMETER_921,
             SV_FORCE_ON_OUT17_32_BITS   = SV_MACHINE_PARAMETER_922,
             SV_FORCE_ON_OUT33_48_BITS   = SV_MACHINE_PARAMETER_923,
             SV_FORCE_ON_OUT49_64_BITS   = SV_MACHINE_PARAMETER_924,
             SV_FORCE_ON_OUT65_80_BITS   = SV_MACHINE_PARAMETER_925,
             SV_FORCE_OFF_OUT1_16_BITS   = SV_MACHINE_PARAMETER_926,
             SV_FORCE_OFF_OUT17_32_BITS  = SV_MACHINE_PARAMETER_927,
             SV_FORCE_OFF_OUT33_48_BITS  = SV_MACHINE_PARAMETER_928,
             SV_FORCE_OFF_OUT49_64_BITS  = SV_MACHINE_PARAMETER_929,
             SV_FORCE_OFF_OUT65_80_BITS  = SV_MACHINE_PARAMETER_930
;             ,
;             SV_FORCE_ON_MEM1_16_BITS    = SV_MACHINE_PARAMETER_931,
;             SV_FORCE_ON_MEM17_32_BITS   = SV_MACHINE_PARAMETER_932,
;             SV_FORCE_ON_MEM33_48_BITS   = SV_MACHINE_PARAMETER_933,
 ;            SV_FORCE_ON_MEM49_64_BITS   = SV_MACHINE_PARAMETER_934,
  ;            SV_FORCE_ON_MEM65_80_BITS   = SV_MACHINE_PARAMETER_935,
  ;           SV_FORCE_OFF_MEM1_16_BITS   = SV_MACHINE_PARAMETER_936,
   ;          SV_FORCE_OFF_MEM17_32_BITS  = SV_MACHINE_PARAMETER_937,
    ;         SV_FORCE_OFF_MEM33_48_BITS  = SV_MACHINE_PARAMETER_938,
     ;        SV_FORCE_OFF_MEM49_64_BITS  = SV_MACHINE_PARAMETER_939,
      ;        SV_FORCE_OFF_MEM65_80_BITS  = SV_MACHINE_PARAMETER_940

IF True THEN BITTST P148Value_W 1 DisableKbInput_M,
             BITTST P170Value_W 0 AllowKbInput_M,
             BITTST P170Value_W 1 JogOverOnly_M,
             BITTST P170Value_W 2 KbOverOnly_M

IF TRUE THEN InvertedInputs911_W = SV_MACHINE_PARAMETER_911,
			 InvertedInputs913_W = SV_MACHINE_PARAMETER_913,
			 InvertedInputs914_W = SV_MACHINE_PARAMETER_914,
			 InvertedInputs915_W = SV_MACHINE_PARAMETER_915
IF (SV_MACHINE_PARAMETER_406 != 0) THEN (ProbeNO_M)
IF (SV_MACHINE_PARAMETER_407 != 0) THEN (TTNO_M)

IF DisableKbInput_M THEN RST AllowKbInput_M
IF JogOverOnly_M && KbOverOnly_M THEN RST KbOverOnly_M

IF SV_MACHINE_PARAMETER_153 == 0 THEN  RST ProbeProtectionEnable_M
IF SV_MACHINE_PARAMETER_153 > 0 THEN  SET ProbeProtectionEnable_M

IF True THEN OverrideLimitTimer = 5000
IF (SV_MACHINE_PARAMETER_941 > 0 || SV_MACHINE_PARAMETER_942 > 0 || SV_MACHINE_PARAMETER_943 > 0
  || SV_MACHINE_PARAMETER_944 > 0 || SV_MACHINE_PARAMETER_945 > 0 || SV_MACHINE_PARAMETER_946 > 0)
  && SV_LIMIT_TRIPPED && SkinLimitDefeat_M && !WTF_Flag
  THEN SET OverrideLimitTimer, (LimitOverridePD), SET WTF_Flag, SET LimitOverrideEnabled

If LimitOverrideEnabled THEN SET LimitOverrideStage
If !LimitOverrideEnabled
  THEN RST LimitOverrideStage, SV_INVERT_INP1_16_BITS = SV_MACHINE_PARAMETER_911, SV_INVERT_INP33_48_BITS = SV_MACHINE_PARAMETER_913,
							   SV_INVERT_INP49_64_BITS = SV_MACHINE_PARAMETER_914, SV_INVERT_INP65_80_BITS = SV_MACHINE_PARAMETER_915

IF OverrideLimitTimer || !EStopOk || SkinResetSet_M
  THEN SV_INVERT_INP1_16_BITS = SV_MACHINE_PARAMETER_911, SV_INVERT_INP33_48_BITS = SV_MACHINE_PARAMETER_913,
	   SV_INVERT_INP49_64_BITS = SV_MACHINE_PARAMETER_914, SV_INVERT_INP65_80_BITS = SV_MACHINE_PARAMETER_915,
	   RST OverrideLimitTimer, RST WTF_Flag, RST LimitOverrideEnabled

IF True THEN P419Value_W = SV_MACHINE_PARAMETER_419
IF True THEN BITTST P419Value_W 0 WorkLightDisabled_M,
			BITTST P419Value_W 1 PopUpPinsCycleStart_M

IF WTF_Flag THEN (Aux14LED)

;Determine what type of tool changer is installed
IF TRUE THEN ATCType_W = SV_MACHINE_PARAMETER_830

;Get word values of tool parameters
IF TRUE THEN P831Value_W = SV_MACHINE_PARAMETER_831
IF TRUE THEN P832Value_W = SV_MACHINE_PARAMETER_832
IF TRUE THEN P833Value_W = SV_MACHINE_PARAMETER_833
IF TRUE THEN P834Value_W = SV_MACHINE_PARAMETER_834
IF TRUE THEN P835Value_W = SV_MACHINE_PARAMETER_835
IF TRUE THEN P836Value_W = SV_MACHINE_PARAMETER_836
IF TRUE THEN P837Value_W = SV_MACHINE_PARAMETER_837
IF TRUE THEN P838Value_W = SV_MACHINE_PARAMETER_838
IF TRUE THEN P839Value_W = SV_MACHINE_PARAMETER_839
IF TRUE THEN P840Value_W = SV_MACHINE_PARAMETER_840
IF TRUE THEN P841Value_W = SV_MACHINE_PARAMETER_841
IF TRUE THEN P842Value_W = SV_MACHINE_PARAMETER_842
IF TRUE THEN P843Value_W = SV_MACHINE_PARAMETER_843
IF TRUE THEN P844Value_W = SV_MACHINE_PARAMETER_844
IF TRUE THEN P845Value_W = SV_MACHINE_PARAMETER_845
IF TRUE THEN P846Value_W = SV_MACHINE_PARAMETER_846

;Set memory bits according to parameter value
IF TRUE THEN WTB P831Value_W P831Bit0 4
IF TRUE THEN WTB P832Value_W P832Bit0 4
IF TRUE THEN WTB P833Value_W P833Bit0 4
IF TRUE THEN WTB P834Value_W P834Bit0 4
IF TRUE THEN WTB P835Value_W P835Bit0 4
IF TRUE THEN WTB P836Value_W P836Bit0 4
IF TRUE THEN WTB P837Value_W P837Bit0 4
IF TRUE THEN WTB P838Value_W P838Bit0 4
IF TRUE THEN WTB P839Value_W P839Bit0 4
IF TRUE THEN WTB P840Value_W P840Bit0 4
IF TRUE THEN WTB P841Value_W P841Bit0 4
IF TRUE THEN WTB P842Value_W P842Bit0 4
IF TRUE THEN WTB P843Value_W P843Bit0 4
IF TRUE THEN WTB P844Value_W P844Bit0 4
IF TRUE THEN WTB P845Value_W P845Bit0 4
IF TRUE THEN WTB P846Value_W P846Bit0 4

;Get timer value from P848 to determine how long the motor is in reverse before shutting off
IF (SV_MACHINE_PARAMETER_848 != 0) THEN TurretReverseTimer = SV_MACHINE_PARAMETER_848 * 1000 ;convert s to ms
IF (SV_MACHINE_PARAMETER_848 == 0) THEN TurretReverseTimer = 1500 ; Default to 1.5s if P848 is 0

;Get timer value from P849 to determine how long to wait before system errors out
IF (SV_MACHINE_PARAMETER_849 != 0) THEN ToolChangeTimeOutTimer = SV_MACHINE_PARAMETER_849 * 1000 ;convert s to ms
IF (SV_MACHINE_PARAMETER_849 == 0) THEN ToolChangeTimeOutTimer = 10000 ; Default to 10s if P849 is 0

;Get timer value from P850 in order to skip the first count once the motor is moving
IF (SV_MACHINE_PARAMETER_850 != 0) THEN CountSkipTimer = SV_MACHINE_PARAMETER_850 * 1000 ;convert s to ms
IF (SV_MACHINE_PARAMETER_850 == 0) THEN CountSkipTimer = 2500 ; Default to 2.5s if P850 is 0

;Get timer value from P851 to determine how long to go past when desired location is reached
;which allows the turret to lock into correct tool location
IF (SV_MACHINE_PARAMETER_851 != 0) THEN ToolTurretOffCurrentToolTimer = SV_MACHINE_PARAMETER_851 * 1000 ;convert s to ms
IF (SV_MACHINE_PARAMETER_851 == 0) THEN ToolTurretOffCurrentToolTimer = 750 ; Default to 0.75s if P851 is 0
;-----DOOR INTERLOCK-----------------------------------------------------------
; Door Interlock - If 1 then set door interlock logic with slowjog, if 2 then stop all motion
IF True THEN P985Value_W = SV_MACHINE_PARAMETER_985

; Check Door Interlock Settings:
; IF Parameter 985 is = 2 then fault system when doors are open prohibiting any movement
IF (P985Value_W == 2) THEN SET DoorInterlockShutdown_M, RST DoorInterlockMode_M,
    SET DoorInterlockStage
;IF Parameter 985 is = 1 then activate Door interlock, allow slow jog with doors open.
IF (P985Value_W == 1) THEN SET DoorInterlockMode_M, RST DoorInterlockShutdown_M,
    SET DoorInterlockStage
;IF Parameter 985 is = 0 then deactivate door interlock
IF (P985Value_W == 0) THEN RST DoorInterlockMode_M,
    RST DoorInterlockStage, RST DoorOpenSlowJog_M,
    RST DoorInterlockShutdown_M
;If anything else, default to active door interlock with slow jog.
IF (P985Value_W < 0 || P985Value_W > 2) THEN SET DoorInterlockMode_M,
    SET DoorInterlockStage
;-----DOOR INTERLOCK-----------------------------------------------------------

;Determine Plasma Settings from P523.
IF True THEN P523Value_W = SV_MACHINE_PARAMETER_523
IF True THEN WTB P523Value_W THCAutomaticBit_M 7

;Enable TorchStage
IF SV_MACHINE_PARAMETER_820 == 3 THEN SET TorchStage, SET TorchSectionStage
IF SV_MACHINE_PARAMETER_820 != 3 THEN RST TorchStage, RST TorchSectionStage

;Determine if Plasma Wireless is Used
IF SV_MACHINE_PARAMETER_411 == 3 THEN (PlasmaWMPG_M)

;==============================================================================
                               TorchStage
;==============================================================================
;Plasma Torch Height Control
IF True THEN TorchTHCEnable_T = SV_MACHINE_PARAMETER_519
IF True THEN Velocity_Threshold_FW = (SV_MACHINE_PARAMETER_520 / 100)
IF True THEN FeedRate_FW = SV_MACHINE_PARAMETER_521

;Determine Voltage, only take reading when Torch is actively on.
IF TorchOn THEN TorchVoltage_W = SV_THC_VOLTAGE
IF !TorchOn THEN TorchVoltage_W = 0

;Determine ArcOK
IF ((TorchVoltage_W >= SV_MACHINE_PARAMETER_522) && TorchArcOkDisabled_M) || (TorchArcOk_I && !TorchArcOkDisabled_M) || 
	(THCNotInstalledBit_M && TorchArcOkDisabled_M) THEN (TorchArcOk_M)
	
;Monitor ArcOK
IF TorchOn && TorchArcOk_M THEN SET TorchArcMonitor_M
IF !TorchOn THEN RST TorchArcMonitor_M, RST TorchArcLost_T

IF TorchArcMonitor_M && !TorchArcOk_M THEN SET TorchArcLost_T
IF TorchArcMonitor_M && TorchArcOk_M THEN RST TorchArcLost_T

IF TorchOn && TorchArcLost_T THEN SET ActivateFeedHold_M, SET TorchRestartModeLED, KbOverride_W = 25

;Set Marking Timer
IF True THEN TorchMarking_T = SV_MACHINE_PARAMETER_532
IF TorchOn && TorchArcOk_M THEN SET TorchMarking_T
IF !TorchOn THEN RST TorchMarking_T

;Set THC on
IF M35P_SV && SV_PROGRAM_RUNNING && TorchArcOk_M && !DryRunLED THEN SET TorchTHCEnable_T
IF TorchTHCEnable_T THEN (TorchTHCEnabled_PD)

;Determine Target Voltage (Further Modified by SV_PLC_SPINDLE_KNOB, See "TorchSectionStage")
;If "AutoSense" Enabled (P523 Bit 1) then determine target voltage on activation of THC first time during Job.
;If Sense on Every cut is enabled (P523 Bit 7) then allow sense every time on THC Activation.
IF THCAutoSenseBit_M && TorchTHCEnabled_PD && !VCalibration_SV && !THCAutoSenseOnce_M THEN TargetVoltage_W = TorchVoltage_W, SET THCAutoSenseOnce_M
IF !SV_JOB_IN_PROGRESS || THCAutoSenseOnCutBit_M THEN RST THCAutoSenseOnce_M

;Ensure THC gets a chance to turn on and correct error before Anti-Dive happens.
; Also Ensure Anti-Dive does not activate if Target Voltage knob was adjusted recently (last 20ms)
IF SV_THC_DIVE_DETECTED && !TorchTHCEnable_T && SV_PROGRAM_RUNNING || TorchKnobChanged_M THEN SET DiveDetectHold_M, RST TorchDiveReset_T
IF (!SV_THC_DIVE_DETECTED && TorchTHCEnable_T) || !SV_PROGRAM_RUNNING THEN SET TorchDiveReset_T
IF TorchDiveReset_T THEN RST DiveDetectHold_M, RST TorchDiveReset_T

;Set Dive Detection if THC is on
IF SV_THC_DIVE_DETECTED && TorchTHCEnable_T && !DiveDetectHold_M THEN SET DiveDetected_M
IF (!SV_THC_DIVE_DETECTED && TorchTHCEnable_T) || !TorchTHCEnable_T THEN RST DiveDetected_M

;Handle Torch Velocity Anti Dive.
; When Velocity Ratio drops below value, turn off THC to prohibit Z moving down on Decell.
; If Smoothing is Enabled (P220 = 1), PLC must calculate the Ratio to use for Velocity Anti-Dive.
IF FeedRate_FW <= 0 THEN FeedRate_FW = 1
IF True THEN XYVelocity_Ratio_FW = SV_THC_VELOCITY_XY / FeedRate_FW

IF (((SV_VELOCITY_RATIO <= Velocity_Threshold_FW) && (SV_MACHINE_PARAMETER_220 == 0)) ||
	((XYVelocity_Ratio_FW <= Velocity_Threshold_FW) && (SV_MACHINE_PARAMETER_220 == 1)))
	&& TorchTHCEnable_T THEN SET VelocityDive_M
IF (((SV_VELOCITY_RATIO > Velocity_Threshold_FW) && (SV_MACHINE_PARAMETER_220 == 0)) ||
	((XYVelocity_Ratio_FW > Velocity_Threshold_FW) && (SV_MACHINE_PARAMETER_220 == 1)))
	&& TorchTHCEnable_T THEN RST VelocityDive_M
IF !TorchTHCEnable_T THEN RST VelocityDive_M

;Disable THC if M35P_SV, Velocity, or DiveDetected is seen.
IF !M35P_SV || SV_STOP || !SV_PROGRAM_RUNNING THEN RST TorchTHCEnable_T, RST M35P_SV

IF TorchTHCEnable_T && !DiveDetected_M && !VelocityDive_M && THCAutoLED && !VCalibration_SV && !THCNotInstalledBit_M THEN (SV_THC_CONTROL_ENABLE)

;IF DiveDetected_M THEN ErrorMsg_W = DIVE_DETECTED_MSG

;TorchTouch
; Determine if float switch activated first
IF TorchFloatSwitch_I && (!TorchTipTouchOff_I || THCNotInstalledBit_M) && !Ohmic_Sensor THEN SET TorchFloatFirst_M

; If TorchTip and Float used in Conjunction then ignore tip if it was tripped
;  when performing the z-zero macro (Determined by DisableTouchFault_SV)
IF DisableTouchFault_SV THEN (TouchOffStarted_PD), (Ohmic_Enable)
IF TouchOffStarted_PD && ((TorchTipTouchOff_I && !THCNotInstalledBit_M) || Ohmic_Sensor) && FloatWithSwitchBit_M && !TorchFloatSwitchDisabled_M THEN SET TorchIgnoreTip_M
IF !DisableTouchFault_SV THEN RST TorchIgnoreTip_M

; Set TorchTouched_M for either Float or TorchTip for macro use.
IF ((TorchTipTouchOff_I && !THCNotInstalledBit_M) || Ohmic_Sensor) && FloatWithSwitchBit_M && !TorchIgnoreTip_M || TorchFloatSwitch_I THEN (TorchTouched_M), (TorchTouchLED)
IF !TorchTouched_M THEN RST TorchFloatFirst_M

; Echo Float and Tip to Memory for Macro use.
IF (TorchTipTouchOff_I && !THCNotInstalledBit_M) || Ohmic_Sensor THEN (TorchOhmicTouch_M)
IF TorchFloatSwitch_I THEN (TorchFloatTouch_M)

;Offset Reset
IF !M35P_SV || !SV_PROGRAM_RUNNING THEN (OffsetReset_PD)

IF OffsetReset_PD THEN (SV_THC_RESET_REQUEST)

;Calibration
IF !SV_PROGRAM_RUNNING THEN RST VCalibration_SV
IF VCalibration_SV && TorchTHCEnabled_PD THEN TargetVoltage_W = TorchVoltage_W, SV_THC_TARGET_VOLTAGE = TorchVoltage_W

;==============================================================================
                              LimitOverrideStage
;==============================================================================
IF LimitOverrideStage THEN Inputs1_16_W = SV_MACHINE_PARAMETER_941,
						   Inputs33_48_W = SV_MACHINE_PARAMETER_942,
						   Inputs49_64_W = SV_MACHINE_PARAMETER_943,
						   Inputs65_80_W = SV_MACHINE_PARAMETER_944
						   ;Inputs81_96_W = SV_MACHINE_PARAMETER_945,
						   ;Inputs97_112_W = SV_MACHINE_PARAMETER_946
;---------------------------------------------------------------------------------------------------------------------------------------
;					Acorn Inputs 1-8 Limits
;---------------------------------------------------------------------------------------------------------------------------------------
IF LimitOverridePD THEN Limit_Invert_W = SV_MACHINE_PARAMETER_911
;----Check Input 1
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs1_16_W 0 Input_IsLimit_M, BITTST InvertedInputs911_W 0 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP1 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 0
IF LimitOverridePD && Input_IsLimit_M && (INP1 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 0
;----Check Input 2
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs1_16_W 1 Input_IsLimit_M, BITTST InvertedInputs911_W 1 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP2 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 1
IF LimitOverridePD && Input_IsLimit_M && (INP2 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 1
;----Check Input 3
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs1_16_W 2 Input_IsLimit_M, BITTST InvertedInputs911_W 2 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP3 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 2
IF LimitOverridePD && Input_IsLimit_M && (INP3 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 2
;----Check Input 4
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs1_16_W 3 Input_IsLimit_M, BITTST InvertedInputs911_W 3 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP4 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 3
IF LimitOverridePD && Input_IsLimit_M && (INP4 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 3
;----Check Input 5
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs1_16_W 4 Input_IsLimit_M, BITTST InvertedInputs911_W 4 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP5 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 4
IF LimitOverridePD && Input_IsLimit_M && (INP5 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 4
;----Check Input 6
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs1_16_W 5 Input_IsLimit_M, BITTST InvertedInputs911_W 5 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP6 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 5
IF LimitOverridePD && Input_IsLimit_M && (INP6 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 5
;----Check Input 7
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs1_16_W 6 Input_IsLimit_M, BITTST InvertedInputs911_W 6 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP7 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 6
IF LimitOverridePD && Input_IsLimit_M && (INP7 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 6
;----Check Input 8
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs1_16_W 7 Input_IsLimit_M, BITTST InvertedInputs911_W 7 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP8 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 7
IF LimitOverridePD && Input_IsLimit_M && (INP8 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 7

;Invert Limit Inputs
IF LimitOverridePD THEN SV_INVERT_INP1_16_BITS = Limit_Invert_W

;---------------------------------------------------------------------------------------------------------------------------------------
;					Ether1616 A0 Inputs 33-48 Limits
;---------------------------------------------------------------------------------------------------------------------------------------
IF LimitOverridePD THEN Limit_Invert_W = SV_MACHINE_PARAMETER_913
;----Check Input 33
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 0 Input_IsLimit_M, BITTST InvertedInputs913_W 0 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP33 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 0
IF LimitOverridePD && Input_IsLimit_M && (INP33 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 0
;----Check Input 34
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 1 Input_IsLimit_M, BITTST InvertedInputs913_W 1 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP34 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 1
IF LimitOverridePD && Input_IsLimit_M && (INP34 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 1
;----Check Input 35
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 2 Input_IsLimit_M, BITTST InvertedInputs913_W 2 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP35 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 2
IF LimitOverridePD && Input_IsLimit_M && (INP35 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 2
;----Check Input 36
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 3 Input_IsLimit_M, BITTST InvertedInputs913_W 3 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP36 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 3
IF LimitOverridePD && Input_IsLimit_M && (INP36 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 3
;----Check Input 37
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 4 Input_IsLimit_M, BITTST InvertedInputs913_W 4 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP37 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 4
IF LimitOverridePD && Input_IsLimit_M && (INP37 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 4
;----Check Input 38
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 5 Input_IsLimit_M, BITTST InvertedInputs913_W 5 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP38 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 5
IF LimitOverridePD && Input_IsLimit_M && (INP38 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 5
;----Check Input 39
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 6 Input_IsLimit_M, BITTST InvertedInputs913_W 6 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP39 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 6
IF LimitOverridePD && Input_IsLimit_M && (INP39 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 6
;----Check Input 40
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 7 Input_IsLimit_M, BITTST InvertedInputs913_W 7 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP40 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 7
IF LimitOverridePD && Input_IsLimit_M && (INP40 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 7
;----Check Input 41
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 8 Input_IsLimit_M, BITTST InvertedInputs913_W 8 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP41 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 8
IF LimitOverridePD && Input_IsLimit_M && (INP41 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 8
;----Check Input 42
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 9 Input_IsLimit_M, BITTST InvertedInputs913_W 9 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP42 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 9
IF LimitOverridePD && Input_IsLimit_M && (INP42 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 9
;----Check Input 43
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 10 Input_IsLimit_M, BITTST InvertedInputs913_W 10 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP43 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 10
IF LimitOverridePD && Input_IsLimit_M && (INP43 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 10
;----Check Input 44
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 11 Input_IsLimit_M, BITTST InvertedInputs913_W 11 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP44 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 11
IF LimitOverridePD && Input_IsLimit_M && (INP44 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 11
;----Check Input 45
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 12 Input_IsLimit_M, BITTST InvertedInputs913_W 12 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP45 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 12
IF LimitOverridePD && Input_IsLimit_M && (INP45 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 12
;----Check Input 46
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 13 Input_IsLimit_M, BITTST InvertedInputs913_W 13 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP46 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 13
IF LimitOverridePD && Input_IsLimit_M && (INP46 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 13
;----Check Input 47
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 14 Input_IsLimit_M, BITTST InvertedInputs913_W 14 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP47 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 14
IF LimitOverridePD && Input_IsLimit_M && (INP47 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 14
;----Check Input 48
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs33_48_W 15 Input_IsLimit_M, BITTST InvertedInputs913_W 15 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP48 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 15
IF LimitOverridePD && Input_IsLimit_M && (INP48 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 15

;Invert Limit Inputs
IF LimitOverridePD THEN SV_INVERT_INP33_48_BITS = Limit_Invert_W

;---------------------------------------------------------------------------------------------------------------------------------------
;					Ether1616 A1 Inputs 49-64 Limits
;---------------------------------------------------------------------------------------------------------------------------------------
IF LimitOverridePD THEN Limit_Invert_W = SV_MACHINE_PARAMETER_914
;----Check Input 49
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 0 Input_IsLimit_M, BITTST InvertedInputs914_W 0 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP49 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 0
IF LimitOverridePD && Input_IsLimit_M && (INP49 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 0
;----Check Input 50
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 1 Input_IsLimit_M, BITTST InvertedInputs914_W 1 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP50 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 1
IF LimitOverridePD && Input_IsLimit_M && (INP50 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 1
;----Check Input 51
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 2 Input_IsLimit_M, BITTST InvertedInputs914_W 2 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP51 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 2
IF LimitOverridePD && Input_IsLimit_M && (INP51 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 2
;----Check Input 52
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 3 Input_IsLimit_M, BITTST InvertedInputs914_W 3 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP52 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 3
IF LimitOverridePD && Input_IsLimit_M && (INP52 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 3
;----Check Input 53
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 4 Input_IsLimit_M, BITTST InvertedInputs914_W 4 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP53 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 4
IF LimitOverridePD && Input_IsLimit_M && (INP53 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 4
;----Check Input 54
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 5 Input_IsLimit_M, BITTST InvertedInputs914_W 5 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP54 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 5
IF LimitOverridePD && Input_IsLimit_M && (INP54 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 5
;----Check Input 55
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 6 Input_IsLimit_M, BITTST InvertedInputs914_W 6 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP55 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 6
IF LimitOverridePD && Input_IsLimit_M && (INP55 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 6
;----Check Input 56
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 7 Input_IsLimit_M, BITTST InvertedInputs914_W 7 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP56 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 7
IF LimitOverridePD && Input_IsLimit_M && (INP56 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 7
;----Check Input 57
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 8 Input_IsLimit_M, BITTST InvertedInputs914_W 8 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP57 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 8
IF LimitOverridePD && Input_IsLimit_M && (INP57 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 8
;----Check Input 58
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 9 Input_IsLimit_M, BITTST InvertedInputs914_W 9 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP58 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 9
IF LimitOverridePD && Input_IsLimit_M && (INP58 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 9
;----Check Input 59
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 10 Input_IsLimit_M, BITTST InvertedInputs914_W 10 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP59 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 10
IF LimitOverridePD && Input_IsLimit_M && (INP59 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 10
;----Check Input 60
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 11 Input_IsLimit_M, BITTST InvertedInputs914_W 11 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP60 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 11
IF LimitOverridePD && Input_IsLimit_M && (INP60 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 11
;----Check Input 61
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 12 Input_IsLimit_M, BITTST InvertedInputs914_W 12 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP61 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 12
IF LimitOverridePD && Input_IsLimit_M && (INP61 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 12
;----Check Input 62
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 13 Input_IsLimit_M, BITTST InvertedInputs914_W 13 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP62 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 13
IF LimitOverridePD && Input_IsLimit_M && (INP62 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 13
;----Check Input 63
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 14 Input_IsLimit_M, BITTST InvertedInputs914_W 14 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP63 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 14
IF LimitOverridePD && Input_IsLimit_M && (INP63 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 14
;----Check Input 64
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs49_64_W 15 Input_IsLimit_M, BITTST InvertedInputs914_W 15 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP64 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 15
IF LimitOverridePD && Input_IsLimit_M && (INP64 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 15

;Invert Limit Inputs
IF LimitOverridePD THEN SV_INVERT_INP49_64_BITS = Limit_Invert_W

;---------------------------------------------------------------------------------------------------------------------------------------
;					Ether1616 A2 Inputs 65-80 Limits
;---------------------------------------------------------------------------------------------------------------------------------------
IF LimitOverridePD THEN Limit_Invert_W = SV_MACHINE_PARAMETER_914
;----Check Input 65
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 0 Input_IsLimit_M, BITTST InvertedInputs915_W 0 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP65 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 0
IF LimitOverridePD && Input_IsLimit_M && (INP65 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 0
;----Check Input 66
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 1 Input_IsLimit_M, BITTST InvertedInputs915_W 1 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP66 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 1
IF LimitOverridePD && Input_IsLimit_M && (INP66 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 1
;----Check Input 67
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 2 Input_IsLimit_M, BITTST InvertedInputs915_W 2 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP67 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 2
IF LimitOverridePD && Input_IsLimit_M && (INP67 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 2
;----Check Input 68
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 3 Input_IsLimit_M, BITTST InvertedInputs915_W 3 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP68 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 3
IF LimitOverridePD && Input_IsLimit_M && (INP68 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 3
;----Check Input 69
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 4 Input_IsLimit_M, BITTST InvertedInputs915_W 4 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP69 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 4
IF LimitOverridePD && Input_IsLimit_M && (INP69 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 4
;----Check Input 70
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 5 Input_IsLimit_M, BITTST InvertedInputs915_W 5 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP70 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 5
IF LimitOverridePD && Input_IsLimit_M && (INP70 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 5
;----Check Input 71
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 6 Input_IsLimit_M, BITTST InvertedInputs915_W 6 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP71 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 6
IF LimitOverridePD && Input_IsLimit_M && (INP71 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 6
;----Check Input 72
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 7 Input_IsLimit_M, BITTST InvertedInputs915_W 7 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP72 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 7
IF LimitOverridePD && Input_IsLimit_M && (INP72 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 7
;----Check Input 73
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 8 Input_IsLimit_M, BITTST InvertedInputs915_W 8 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP73 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 8
IF LimitOverridePD && Input_IsLimit_M && (INP73 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 8
;----Check Input 74
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 9 Input_IsLimit_M, BITTST InvertedInputs915_W 9 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP74 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 9
IF LimitOverridePD && Input_IsLimit_M && (INP74 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 9
;----Check Input 75
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 10 Input_IsLimit_M, BITTST InvertedInputs915_W 10 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP75 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 10
IF LimitOverridePD && Input_IsLimit_M && (INP75 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 10
;----Check Input 76
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 11 Input_IsLimit_M, BITTST InvertedInputs915_W 11 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP76 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 11
IF LimitOverridePD && Input_IsLimit_M && (INP76 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 11
;----Check Input 77
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 12 Input_IsLimit_M, BITTST InvertedInputs915_W 12 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP77 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 12
IF LimitOverridePD && Input_IsLimit_M && (INP77 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 12
;----Check Input 78
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 13 Input_IsLimit_M, BITTST InvertedInputs915_W 13 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP78 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 13
IF LimitOverridePD && Input_IsLimit_M && (INP78 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 13
;----Check Input 79
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 14 Input_IsLimit_M, BITTST InvertedInputs915_W 14 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP79 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 14
IF LimitOverridePD && Input_IsLimit_M && (INP79 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 14
;----Check Input 80
IF (LimitOverridePD) && !OverrideLimitTimer THEN BITTST Inputs65_80_W 15 Input_IsLimit_M, BITTST InvertedInputs915_W 15 Input_IsInverted_M

IF LimitOverridePD && Input_IsLimit_M && (!INP80 ^ Input_IsInverted_M) THEN BITSET Limit_Invert_W 15
IF LimitOverridePD && Input_IsLimit_M && (INP80 ^ Input_IsInverted_M) THEN BITRST Limit_Invert_W 15

;Invert Limit Inputs
IF LimitOverridePD THEN SV_INVERT_INP65_80_BITS = Limit_Invert_W

;=============================================================================
                        LubeUsePumpTimersStage
;=============================================================================

; METHOD 1 (SS == 0) For lube pumps with internal timers.
;
; When using this method, P179 should be set such that MMM is a
; value that is greater than the cycle time set on the internal timers and
; SS should be set to zero. How much greater MMM needs to be depends on the
; accuracy of the lube pump timers, but it is better to be on the long side
; to ensure proper operation.
;
; Example 1. The internal lube cycle interval is set to 60 minutes.
;            Set P179 = 7500. In this example, as long as the accuracy
;            of the lube timer interval causes the lube to turn on
;            within 75 minutes, it will work. Note that the amount of time
;            that lube is output is usually set with another timer control
;            on the lube pump and it does not factor into the setting of P179.
;
; It should be noted that lube pumps with internal timers may differ on how
; they operate.
;
; (a) For pumps that lube immediately when power is applied and then start timing
; until the next cycle, it is possible to run out of lube quickly on short job
; runs if, after the program has been run, lube power is removed.
;
; (b) For pumps that do not lube until it has been turned on for the interval time,
; it is possible that lube never gets applied if, after the short program has been run,
; lube power is removed.
;
; A short program or job run is defined as a job that finishes before
; the interval setting (60 minutes in the above example).
;
; For the above mentioned reasons, we want the power to be applied for at least
; the amount of time set by the interval timer, noting that if the user decides
; to engage the E-stop to remove power after short jobs, then they risk the
; above mentioned problems according to the type of pump.
;
; On the start of SV_PROGRAM_RUNNING, the lube pump turns on.
; The lube pump is turned off when a program has NOT been
; running continuously for MMM minutes or E-stop is engaged.
; The reason the lube pump is turned off after a program has NOT been
; running for MMM minutes is to prevent lubing when the user leaves for the
; weekend, leaving the machine on and E-stop disengaged.

IF SV_PROGRAM_RUNNING THEN SET LubePump, RST LubeM_T
IF !SV_PROGRAM_RUNNING THEN LubeM_T = LubeM_W, SET LubeM_T
IF LubeM_T || SV_STOP THEN RST LubePump

;=============================================================================
                        LubeUsePLCTimersStage
;=============================================================================
;
; METHOD 2 (SS != 0) For lube pumps that do not have internal timers.
;
;  When using this method P179 should be set so the lube turns on
;  every MMM minutes for SS seconds.
;
;  Example 1.
;    To set the lube pump power to come on for 5 seconds
;    every 10 minutes, set P179 =  1005.
;                                 MMMSS
;  Example 2.
;    To set the lube pump power to come on for 30 seconds
;    every 2 hours, set P179 = 12030
;                              MMMSS
;
; This method will accumulate time while a program is running until
; it reaches MMM minutes, at which time it will apply power
; for SS seconds (unless E-stop is engaged) and then start over. It is
; possible with frequent use of E-stop that a lube cycle is cut short.
;
IF SkinManualLube_M && !LubePump THEN (ManualLubePD)
IF SV_PROGRAM_RUNNING  THEN LubeM_T = LubeM_W, SET LubeM_T
IF !SV_PROGRAM_RUNNING THEN (StopRunningPD)
IF StopRunningPD THEN LubeAccumTime_W = LubeAccumTime_W + LubeM_T, RST LubeM_T
IF LubeM_T || ManualLubePump_SV || ManualLubePD || (LubeAccumTime_W + LubeM_T > LubeM_W)
  THEN SET LubePump, LubeS_T = LubeS_W, SET LubeS_T, RST LubeM_T, LubeAccumTime_W = 0
IF LubeS_T || SV_STOP THEN RST LubePump, RST LubeS_T, RST ManualLubePump_SV
IF LubePump THEN (ManualLubeLED)

;==============================================================================
                        KeyboardEventsStage
;==============================================================================
; This stage handles functions that are required for menu navigation
; by CNC12, require multiple keypresses and/or need to be interlocked
; with SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  Regarding
; "AllowKbInput_M": This PLC program reads a bit from a system parameter,
; in this case bit 0 of SV_MACHINE_PARAMETER_170, and sets "AllowKbInput_M"
; if the bit is a "0".  If the operator wishes to allow keyboard input
; to trigger PLC events, they must set parameter 170 to a "1"
; (or any odd number for that matter).  It should be mentioned that
; the programmer will not want to interlock all keyboard keys with
; SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  For example:
; The "escape" key must be echoed by the PLC to CNC12 to aid in menu
; navigation.  NOTE: For backward compatibility with CNC10, setting bit 1
; of SV_MACHINE_PARAMETER_148 OR clearing bit 0 of SV_MACHINE_PARAMETER_170
; will disable keyboard jogging.

;-------------------------Not interlocked--------------------------------------
; The code for cycle cancel has been moved to the main stage.
; It is commented out below but remains for reference
;Cycle Cancel
;IF Kb_Escape THEN (KbCycleCancel_M)

;Rapidoverride: Ctrl-r
IF Kb_r && (Kb_L_Ctrl || Kb_R_Ctrl) THEN (KbTogRapidOver_M)

;----------------Interlocked with AllowKbInput_M-------------------------------
;KbCycle Start: alt-s
IF  (Kb_s && (Kb_R_Alt || Kb_L_Alt) || (Kb_Num_Enter || Kb_Enter) && SV_MACHINE_PARAMETER_418 == 1) && AllowKbInput_M THEN (KbCycleStart_M)

;KbToolCheck_M: Ctrl-t
IF Kb_t && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbToolCheck_M)

;KbTogSingleBlock_M: ctrl-b
IF Kb_b && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogSingleBlock_M)

;KbTogSpinAutoMan_M: ctrl-a
IF Kb_a && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogSpinAutoMan_M)

;KbSpinCW_M: ctrl-c
IF Kb_c && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN SET KbSpinCW_M,
    RST KbSpinCCW_M

;KbSpinCCW_M: ctrl-w
IF Kb_w && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN SET KbSpinCCW_M,
    RST KbSpinCW_M

;KbSpinStart_M:  ctrl-s
IF Kb_s && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStart_M)

;KbSpindle stop: Ctrl-q
IF Kb_q && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStop_M)

;KbIncSpinOver_M: ctrl (">")
IF Kb_Period && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbIncSpinOver_M)

;KbDecSpinOver_M: ctrl ("<")
IF Kb_Comma && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbDecSpinOver_M)

;KbSpinOver100_M: ctrl + /
IF Kb_Slash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbSpinOver100_M)

;KbTogCoolAutoMan_M: Ctrl-m
IF Kb_m && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogCoolAutoMan_M)

;KbFloodOnOff_M: Ctrl-n
IF Kb_n && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbFloodOnOff_M)

;KbMistOnOff_M: Ctrl-k
IF Kb_k && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbMistOnOff_M)

;KbAux1Key_M: "ctrl" + "F1"
IF Kb_F1 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux1Key_M)

;KbAux2Key_M: "ctrl" + "F2"
IF Kb_F2 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux2Key_M)

;KbAux3Key_M: "ctrl" + "F3"
IF Kb_F3 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux3Key_M)

;KbAux4Key_M: "ctrl" + "F4"
IF Kb_F4 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux4Key_M)

;KbAux5Key_M: "ctrl" + "F5"
IF Kb_F5 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux5Key_M)

;KbAux6Key_M: "ctrl" + "F6"
IF Kb_F6 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux6Key_M)

;KbAux7Key_M: "ctrl" + "F7"
IF Kb_F7 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux7Key_M)

;KbAux8Key_M: "ctrl" + "F8"
IF Kb_F8 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux8Key_M)

;KbAux9Key_M: "ctrl" + "F9"
IF Kb_F9 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux9Key_M)

;KbAux10Key_M: "ctrl" + "F10"
IF Kb_F10 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux10Key_M)

;KbAux11Key_M: "ctrl" + "F11"
IF Kb_F11 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux11Key_M)

;KbAux12Key_M: "ctrl" + "F12"
IF Kb_F12 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux12Key_M)

;KbIncFeedOver_M: "ctrl" + "keyboard +" (actually "=")
IF (Kb_Equals || Kb_10_Key_Plus) && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbIncFeedOver_M)

;KbDecFeedOver_M: "ctrl" + "keyboard -"
IF (Kb_Hyphen || Kb_10_Key_Sub) && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbDecFeedOver_M)

;KbFeedOver100_M: "ctrl" + "keyboard \"
IF Kb_Backslash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbFeedOver100_M)

;--------Interlocked with AllowKbInput_M && KbJpActive_M-----------------------

;KbIncreaseJogInc_M: "insert"
IF (Kb_Ins || ShuttleIncJogInc) && AllowKbInput_M && KbJpActive_M
  THEN (KbIncreaseJogIncPD)
IF KbIncreaseJogIncPD && x1JogLED
  THEN SET X10_M, RST x1JogLED, SET x10JogLED, RST x100JogLED
IF KbIncreaseJogIncPD && x10JogLED
  THEN SET X100_M, RST x1JogLED, RST x10JogLED, SET x100JogLED

;KbTogIncContJog_M: "ctrl" +  "i"
IF Kb_i &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M && KbJpActive_M
  THEN (KbTogIncContJog_M)

;KbTogFastSlowJog_M: "ctrl" + "f"
IF Kb_f &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M && KbJpActive_M
  THEN (KbTogFastSlowJog_M)

;KbDecreaseJogInc_M: "delete"
IF Kb_Del && AllowKbInput_M && KbJpActive_M
  THEN (KbDecreaseJogIncPD)
IF KbDecreaseJogIncPD && x10JogLED
  THEN SET X1_M, SET x1JogLED, RST x10JogLED, RST x100JogLED
IF KbDecreaseJogIncPD && x100JogLED
  THEN SET X10_M, RST x1JogLED, SET x10JogLED, RST x100JogLED
IF Kb_Del THEN (ShuttleIncJogDec)

;KbJogAx1Plus_M: Right arrow
IF Kb_Right && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Plus_M)

;KbJogAx1Minus_M: Left arrow
IF Kb_Left && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Minus_M)

;KbJogAx2Plus_M: Up arrow
IF Kb_Up && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Plus_M)

;KbJogAx1Minus_M: Down arrow
IF Kb_Down && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Minus_M)

;KbJogAx3Plus_M: Page up
IF Kb_PgUp && AllowKbInput_M && KbJpActive_M && !ShuttleExpressUsb_M THEN (KbJogAx3Plus_M)

;KbJogAx3Minus_M: Page Down
IF Kb_PgDown && AllowKbInput_M && KbJpActive_M && !ShuttleExpressUsb_M THEN (KbJogAx3Minus_M)

;KbAx4PlusJog: "home"
IF Kb_Home && AllowKbInput_M && KbJpActive_M
  THEN (KbJogAx4Plus_M)

;KbAx4MinusJog: "end"
IF Kb_End && AllowKbInput_M && KbJpActive_M
  THEN (KbJogAx4Minus_M)

IF True THEN RST KeyboardEventsStage

;==============================================================================
                           MPGStage
;==============================================================================
;                        MPG Functions
;       Turn on/off Jog Panel MPG LED & on the MPG

; Turn off the MPG LED if this is first time run.
IF OnAtPowerUp_M THEN RST MPGLED

; Read in the axes set in Parameter 218.
IF True THEN UsbMpgActiveAxes_W = SV_MACHINE_PARAMETER_218

; Translate UsbMpgActiveAxes_W to 4 consecutive memory locations starting at UsbMpgAxis1Active_M
IF True THEN WTB UsbMpgActiveAxes_W UsbMpgAxis1Active_M 4

; Read in the Axis select knob value.
IF True THEN UsbAxisMonitor_W = SV_USB_MPG_AXIS_SELECT

;Use echoed word value for usb mpg axis select so it can be explicitly set to 0 for invalid axes.
IF (SV_USB_MPG_SCALE_SELECT > 100) ||
  ((UsbAxisMonitor_W == 1) && !UsbMpgAxis1Active_M) ||
  ((UsbAxisMonitor_W == 2) && !UsbMpgAxis2Active_M) ||
  ((UsbAxisMonitor_W == 3) && !UsbMpgAxis3Active_M) ||
  ((UsbAxisMonitor_W == 4) && !UsbMpgAxis4Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 0, UsbAxisMonitor_W = 0

; Make sure the axis selector knob is set to something other than "OFF".
IF UsbAxisMonitor_W > 0 THEN SET IsUsbMpgAxisSelected_M
IF UsbAxisMonitor_W == 0 THEN RST IsUsbMpgAxisSelected_M

; Read in the scale selector knob value.
IF True THEN UsbScaleMonitor_W = SV_USB_MPG_SCALE_SELECT

; Enable usb mpg handwheel jogging.
IF SV_USB_MPG_POWER && ((UsbAxisMonitor_W > 0) && UsbScaleMonitor_W <= 100) THEN (UsbMpgWheelJoggingEnabled_M)
IF UsbMpgWheelJoggingEnabled_M THEN UsbWheelCurrent = SV_MPU11_ABS_POS_5
IF UsbMpgWheelJoggingEnabled_M THEN UsbWheelDelta = (UsbWheelCurrent - UsbWheelLast)
IF UsbMpgWheelJoggingEnabled_M THEN UsbWheelLast = UsbWheelCurrent

; Turn the MPG LED on.
IF (IsUsbMpgAxisSelected_M && SV_USB_MPG_POWER) || ShuttleEnabled
  THEN SET MPG_LED_OUT, SET MPGLED

; Turn the MPG LED off.
IF !IsUsbMpgAxisSelected_M || (!ShuttleEnabled && ShuttlePresent)
  THEN RST MPG_LED_OUT, RST MPGLED
  
;Lockout X100 Z-Axis if Selected by MPG
IF MpgX100LockOut_M && MPGLED &&
  ((SV_MPG_1_AXIS_SELECT == 3 && SV_MACHINE_PARAMETER_820 != 1) ||
  (SV_MPG_1_AXIS_SELECT == 1 && SV_MACHINE_PARAMETER_820 == 1))
  THEN (MpgZAxisLocked_M)

;x1, x10, x100 functions
;--X1
IF x1JogKey || SkinX1_M THEN (x1JogPD)
IF x1JogPD || OnAtPowerUp_M ||
  (IsUsbMpgAxisSelected_M && (UsbScaleMonitor_W == 1) && UsbMpgWheelJoggingEnabled_M)
  THEN SET x1JogLED, RST x10JogLED, RST x100JogLED

;--X10
IF x10JogKey || SkinX10_M THEN (x10JogPD)
IF x10JogPD ||
  (IsUsbMpgAxisSelected_M && ((UsbScaleMonitor_W == 10) ||
  ((UsbScaleMonitor_W == 100) && MpgZAxisLocked_M)) && UsbMpgWheelJoggingEnabled_M)
  THEN RST x1JogLED, SET x10JogLED, RST x100JogLED

;--X100
IF x100JogKey || SkinX100_M THEN (x100JogPD)
IF x100JogPD ||
  (IsUsbMpgAxisSelected_M && (UsbScaleMonitor_W == 100) && UsbMpgWheelJoggingEnabled_M &&
  !MpgZAxisLocked_M)
  THEN RST x1JogLED, RST x10JogLED, SET x100JogLED

;--MPG 1 Enable
; SV_MPG_1_ENABLED must be set for CNC12 to allow handwheel jogging.
IF ((ShuttleAxis1Selected || (UsbAxisMonitor_W == 1)) && SV_AXIS_VALID_1) ||
   ((ShuttleAxis2Selected || (UsbAxisMonitor_W == 2)) && SV_AXIS_VALID_2) ||
   ((ShuttleAxis3Selected || (UsbAxisMonitor_W == 3)) && SV_AXIS_VALID_3) ||
   ((ShuttleAxis4Selected || (UsbAxisMonitor_W == 4)) && SV_AXIS_VALID_4)
   THEN (ValidMpgAxisSelected_M)

; Enable the Software to read the Wireless MPG.
IF (IsUsbMpgAxisSelected_M && SV_USB_MPG_POWER) && ValidMpgAxisSelected_M
   THEN (SV_MPG_1_ENABLED)

;                     Select axis to move
;IF MPG_AXIS_1 THEN SV_MPG_1_AXIS_SELECT = 1
;IF MPG_AXIS_2 || MEM71 THEN SV_MPG_1_AXIS_SELECT = 2
;IF MPG_AXIS_3 THEN SV_MPG_1_AXIS_SELECT = 3
;IF MPG_AXIS_4 THEN SV_MPG_1_AXIS_SELECT = 4
;IF MPG_AXIS_5 THEN SV_MPG_1_AXIS_SELECT = 5
IF (SV_USB_MPG_SCALE_SELECT <= 100) && ((UsbAxisMonitor_W == 1) && UsbMpgAxis1Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 1

IF (SV_USB_MPG_SCALE_SELECT <= 100) && ((UsbAxisMonitor_W == 2) && UsbMpgAxis2Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 2

IF (SV_USB_MPG_SCALE_SELECT <= 100) && ((UsbAxisMonitor_W == 3) && UsbMpgAxis3Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 3

IF (SV_USB_MPG_SCALE_SELECT <= 100) && ((UsbAxisMonitor_W == 4) && UsbMpgAxis4Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 4

IF UsbAxisMonitor_W == 0 THEN SV_MPG_1_AXIS_SELECT = 0

;                   Select MPG 1 Multiplier
IF x100JogLED THEN SV_MPG_1_MULTIPLIER = 100
IF x10JogLED THEN SV_MPG_1_MULTIPLIER = 10
IF x1JogLED THEN SV_MPG_1_MULTIPLIER = 1

;            Disable "Windup" mode IF anything above x1 selected
IF (SV_MPG_1_MULTIPLIER < 10) THEN (SV_MPG_1_WINDUP_MODE)

;			Set Data to be seen by set axis Macro 0
IF (SV_USB_MPG_AXIS_SELECT == 0)
	THEN RST MpgAxis1Selected_M, RST MpgAxis2Selected_M, RST MpgAxis3Selected_M, RST MpgAxis4Selected_M

IF ((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgAxis1Active_M)
	THEN SET MpgAxis1Selected_M, RST MpgAxis2Selected_M, RST MpgAxis3Selected_M, RST MpgAxis4Selected_M

IF ((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgAxis2Active_M)
	THEN RST MpgAxis1Selected_M, SET MpgAxis2Selected_M, RST MpgAxis3Selected_M, RST MpgAxis4Selected_M

IF ((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgAxis3Active_M)
	THEN RST MpgAxis1Selected_M, RST MpgAxis2Selected_M, SET MpgAxis3Selected_M, RST MpgAxis4Selected_M

IF ((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgAxis4Active_M)
	THEN RST MpgAxis1Selected_M, RST MpgAxis2Selected_M, RST MpgAxis3Selected_M, SET MpgAxis4Selected_M

;==============================================================================
                                  G540SpindleStage
;The Gecko G540 requires that the spindle outputs for Fwd and Rev are inverted
;==============================================================================

IF OnAtPowerUp_M || SV_STOP || SpinStop_M || M51_SV THEN SET SpindleDisable_M

IF SpinStart_M && !SpinStop_M THEN RST SpindleDisable_M

IF SpindleDisable_M || SpinStop_M
  THEN SET SpindleDisable_M, RST SpindleForward_M, RST SpindleReverse_M

;Outputs must be OFF for spindle to run on G540
;Set some MEM bits if spindle should be on in forward or reverse direction
IF !SpindleDisable_M && !SpindleDirectionOut_M THEN SET SpindleForward_M, RST SpindleReverse_M
IF !SpindleDisable_M && SpindleDirectionOut_M THEN SET SpindleReverse_M, RST SpindleForward_M

;Set state of spindle direction outputs to the inverse of mem bits
;Set state of spindle direction outputs to the inverse of mem bits
IF SpindleForward_M && SpindleBrakeTimer THEN RST G540SpinFwdOff, SET G540SpinRevOff
IF SpindleReverse_M && SpindleBrakeTimer THEN RST G540SpinRevOff, SET G540SpinFwdOff

IF !SpindleForward_M || !SpindleBrakeTimer THEN SET G540SpinFwdOff
IF !SpindleReverse_M || !SpindleBrakeTimer THEN SET G540SpinRevOff

IF (!SpindleForward_M && !SpindleReverse_M) || SpindleDisable_M THEN (DoSpindleStop)

;==============================================================================
                                StandardSpindleStage
;==============================================================================
IF (SpindleEnableOut_M || SpinStart_M ) && !SpinStop_M && ChuckOpenCloseComplete_M
  THEN SET SpindleEnableOut_M
IF !((SpindleEnableOut_M || SpinStart_M ) && !SpinStop_M) THEN RST SpindleEnableOut_M
IF SpindleEnableOut_M && !M37 THEN (VFDEnable_O)
IF  SpindleEnableOut_M && !M37 && !SpindleDirectionOut_M && SpindleBrakeTimer THEN (SpinFWD)
IF  SpindleEnableOut_M && !M37 && SpindleDirectionOut_M && SpindleBrakeTimer THEN (SpinREV), (VFDDirection_O)
IF !SpindleEnableOut_M THEN (DoSpindleStop)

;==============================================================================
                           JogPanelStage
;==============================================================================
;--Select Incremental or Continuous Jog Mode
IF IncrContKey || KbTogIncContJog_M || SkinIncCont_M ||
  ((ShuttleIncJogPlus || ShuttleIncJogMinus) && !IncrContLED) ||
  ((ShuttleAxisJogContMinus || ShuttleAxisJogContPlus) && IncrContLED)
 THEN (IncrContPD)
IF (IncrContPD && !IncrContLED) || OnAtPowerUp_M || x1JogPD || x10JogPD || x100JogPD
  THEN SET IncrContLED
IF (IncrContPD && IncrContLED) THEN RST IncrContLED

;SV_MACHINE_PARAMETER_856 = Default jog behavior on startup
;0 = fast/incremental, 1 = fast/continuous,
;2 = slow/incremental, 3 = slow/continuous

IF True THEN DefaultJogging_W = SV_MACHINE_PARAMETER_856
IF OnAtPowerUp_M THEN BITTST DefaultJogging_W 0 ContinuousJog_M,
                      BITTST DefaultJogging_W 1 FastJog_M
IF OnAtPowerUp_M && ContinuousJog_M THEN RST IncrContLED
IF OnAtPowerUp_M && !ContinuousJog_M THEN SET IncrContLED
IF OnAtPowerUp_M && FastJog_M THEN RST FastSlowLED
IF OnAtPowerUp_M && !FastJog_M THEN SET FastSlowLED

;--Select Fast or Slow Jog Mode
;Store state of FastSlowLED if user is not jogging with UsbMpg
IF FastSlowLED && (!UsbMpgJogMinus_M && !UsbMpgJogPlus_M)
  THEN SET SlowLEDState_M, RST FastLEDState_M
IF !FastSlowLED && (!UsbMpgJogMinus_M && !UsbMpgJogPlus_M)
  THEN RST SlowLEDState_M, SET FastLEDState_M

IF SlowLEDState_M && FastSlowLED && (UsbAxisMonitor_W == 0) THEN RST SlowLEDState_M
IF FastLEDState_M && !FastSlowLED && (UsbAxisMonitor_W == 0) THEN RST SlowLEDState_M

;Toggle Fast/Slow jog if user presses FastSlowKey/VCPFastSlow or KbFastSlow
;Forces Slowjog if SafetyDoorInterlock is On and Door is Open
IF (FastSlowKey || KbTogFastSlowJog_M || SkinFastSlowJog_M) THEN (SlowFastPD)
IF (SlowFastPD && !FastSlowLED) || (SlowLEDState_M && !FastSlowLED && (UsbAxisMonitor_W == 0)) || DoorOpenSlowJog_M THEN SET FastSlowLED
IF (SlowFastPD && FastSlowLED) || (FastLEDState_M && FastSlowLED && (UsbAxisMonitor_W == 0)) THEN RST FastSlowLED

;If user is using Usb Mpg to jog and is in x1, set to Incr (IncrContLED On)
IF ((SV_MPG_1_AXIS_SELECT != 0) && ((SV_USB_MPG_SCALE_SELECT == 1) ))
  THEN SET IncrContLED, SET FastSlowLED

;If user is using Usb Mpg to jog and is in x10, set to slow jog (FastSlowLED On)
IF ((SV_MPG_1_AXIS_SELECT != 0) && (SV_USB_MPG_SCALE_SELECT == 10))
  THEN SET FastSlowLED, RST IncrContLED

;If user is using Usb Mpg to jog and is in x100, set to fast jog (FastSlowLED Off)
IF ((SV_MPG_1_AXIS_SELECT != 0) && (SV_USB_MPG_SCALE_SELECT == 100))
  THEN RST FastSlowLED, RST IncrContLED

;Displays Message for selecting fast and slow jog
IF (FastSlowLED && SlowFastPD) && !DoorOpenSlowJog_M THEN InfoMsg_W = FAST_JOG_SELECTED
IF !FastSlowLED && SlowFastPD THEN InfoMsg_W = SLOW_JOG_SELECTED

;Set or restore FastSlow jog state on keypress or UsbMpg release
IF (SlowFastPD && !FastSlowLED && !UsbMpgJogMinus_M && !UsbMpgJogPlus_M && SlowLEDState_M && (UsbAxisMonitor_W == 0))
  THEN SET FastSlowLED, RST SlowLEDState_M

IF (SlowFastPD && FastSlowLED && !UsbMpgJogMinus_M && !UsbMpgJogPlus_M && FastLEDState_M && (UsbAxisMonitor_W == 0))
  THEN RST FastSlowLED, RST FastLEDState_M

;--Single Block Mode
IF SingleBlockKey || KbTogSingleBlock_M || SkinSingleBlock_M THEN (SingleBlockPD)
IF SingleBlockPD && !SingleBlockLED && !SV_PROGRAM_RUNNING
  THEN SET SingleBlockLED
IF SingleBlockPD && SingleBlockLED THEN RST SingleBlockLED
IF SingleBlockLED THEN (SelectSingleBlock)

;--Toolcheck
;Perform standard Toolcheck unless Plasma Software
IF (ToolCheckKey || KbToolCheck_M || SkinToolCheck_M || MpgToolCheck_M || ToolCheck2) && EStopOk
 && (SV_MACHINE_PARAMETER_820 != 3) THEN (ToolCheckPD)
IF ToolCheckPD THEN (DoToolCheck)

;--Feed Hold Mode
; Note: the feedrate override values used here for testing against P146
; are those calculated in the previous scan.  There is no problem with that.
IF (FeedHoldKey || KbFeedHold_M || SkinFeedHold_M || (MpgFeedHold_M && !PlasmaWMPG_M) || FeedHold2) && SV_PROGRAM_RUNNING THEN (FeedHoldPD)
IF FeedHoldPD || ActivateFeedHold_M ||
   (FinalFeedOverride_W < P146Value_W && !OnAtPowerUp_M)
  THEN SET FeedHoldLED
IF DoCycleStart || DoCycleCancel || DoToolCheck ||
   (FinalFeedOverride_W >= P146Value_W &&
    PrevFeedOverride_W < P146Value_W)
  THEN RST FeedHoldLED
IF True THEN PrevFeedOverride_W = FinalFeedOverride_W
; (FeedHoldLED will be used later to signal MPU11 to do Feed Hold)

;--Feedrate Override Section
;------------------------------------------------------------------------------
; Feedrate override works as follows:
;
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; 2. The PLC scales this value to a 0-200 value (0-200%) by dividing by
;    the knob value by 127.5 and then multiplying the result by 100
; 3. If keyboard jogging is enabled, the PLC
;    determines whether the operator is using the keyboard override or
;    the FeedrateKnob_W to override the feedrate by watching which was changed
;    most recently.  The most recently changed value is saved as
;    "FinalFeedOverride_W"
; 4. Parameter 39 in (From the "params" screen in CNC12 software) stores
;    a value which the PLC program must use to limit the amount
;    of override applied to the programmed feedrate. This value is specified
;    as a percentage.
; 5. The PLC limits the override percentage by reading parameter 39 and, if
;    the feedrate override percentage as read from the knob is greater than
;    parameter 39, it sets the FinalFeedOverride_W value to the value of
;    parameter 39.
; 6. Once the override percentage has been determined and limited (if needed)
;    The PLC send this value up to the CNC12 software by setting
;    SV_PLC_FEEDRATE_KNOB = FinalFeedOverride_W
; 7. CNC12 reads SV_PLC_FEEDRATE_KNOB, factors in its own override based
;    on parameter 78 (see operators manual for more info on parm 78) and then
;    returns an override value to the PLC in the system variable
;    SV_PC_FEEDRATE_PERCENTAGE
; 8. The PLC reads SV_PC_FEEDRATE_PERCENTAGE and (typically) echoes the system
;    variable to SV_PLC_FEEDRATE_OVERRIDE which the MPU11 uses as the final
;    determination of the feedrate override percentage.
;------------------------------------------------------------------------------
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; NOTE: BTW = Bit To Word
; BTW reads the specified number of bits (if none is specified it defaults to 8)
; starting from a bit location and writes them to a word with the starting bit
; location being written to the LSB of the word used.  Below, BTW reads the bit
; values from JpFeedOrKnobBit0 to JpFeedOrKnobBit7 and writes them into to the
; word "FeedrateKnob_W" which sets FeedrateKnob_W to a value of 0-255
;------------------------------------------------------------------------------
IF OnAtPowerUp_M THEN KbOverride_W = 100, FinalFeedOverride_W = 100, SET UsingVirtualOverride_M
;------------------------------------------------------------------------------
; 2. Scale this value to a 0-200 value (0-200%)
;------------------------------------------------------------------------------
IF True THEN SkinFeedOverTimer = 200
IF SkinFeedOverMinus_M THEN (SkinFeedOverMinusPD), SET SkinFeedOverTimer
IF SkinFeedOverPlus_M THEN (SkinFeedOverPlusPD), SET SkinFeedOverTimer

IF !SkinFeedOverPlus_M && !SkinFeedOverMinus_M THEN RST SkinFeedOverTimer

IF !WaitingForSleepTimer_M && ((KbIncFeedOver_M || SkinFeedOverPlusPD) || (SkinFeedOverTimer && SkinFeedOverPlus_M))
  THEN KbOverride_W = KbOverride_W + 1,
       RST UsingFeedrateKnob_M,
       SET WaitingForSleepTimer_M,
       SleepTimer = 30, SET SleepTimer

IF !WaitingForSleepTimer_M && ((KbDecFeedOver_M || SkinFeedOverMinusPD) || (SkinFeedOverTimer && SkinFeedOverMinus_M))
  THEN KbOverride_W = KbOverride_W - 1,
		RST UsingFeedrateKnob_M,
		SET WaitingForSleepTimer_M,
		SleepTimer = 30, SET SleepTimer

IF SleepTimer THEN RST WaitingForSleepTimer_M, RST SleepTimer

;MPG Feedrate Override Logic
IF !MpgFeedWheelSelect_M THEN RST MpgFeedWheelSet_M
IF (MpgFeedWheelSelect_M && !MpgFeedWheelSet_M) THEN  UsbWheelLast = SV_MPU11_ABS_POS_5, SET MpgFeedWheelSet_M
IF MpgFeedWheelSet_M THEN UsbWheelCurrent = SV_MPU11_ABS_POS_5
IF MpgFeedWheelSet_M THEN UsbWheelDelta = (UsbWheelCurrent - UsbWheelLast)
IF MpgFeedWheelSet_M THEN UsbWheelLast = UsbWheelCurrent
IF MpgFeedWheelSet_M THEN KbOverride_W = (KbOverride_W + UsbWheelDelta)

IF SkinFeedOver100 || KbFeedOver100_M THEN KbOverride_W = 100
IF SkinFeedOver75_M THEN KbOverride_W = 75, RST UsingFeedrateKnob_M
IF SkinFeedOver50_M THEN KbOverride_W = 50, RST UsingFeedrateKnob_M
IF SkinFeedOver25_M THEN KbOverride_W = 25, RST UsingFeedrateKnob_M
IF KbOverride_W < 100 THEN(FeedOverLT100)
IF KbOverride_W == 100 THEN(FeedOverEQ100)
IF KbOverride_W > 100 THEN(FeedOverGT100)

;IF !OnAtPowerUp_M && (ABS(KbOverride_W - LastKbOverride_W) >=2)
;  THEN FinalFeedOverride_W = KbOverride_W, (UsingKbOverride_M), LastKbOverride_W = KbOverride_W
;
;IF !OnAtPowerUp_M && !UsingKbOverride_M && VirtualJpRunning_M
;  THEN (UsingVirtualOverride_M)
;
;IF UsingVirtualOverride_M && (ABS(SkinFeedOverride_W1 - LastSkinFeedOverride_W) > 0)
;  THEN FinalFeedOverride_W = SkinFeedOverride_W1
;
;IF True THEN LastSkinFeedOverride_W = SkinFeedOverride_W1

;Limit keyboard override to parm 39.  Allowing the FeedrateKnob_W to go past
;parm 39, but keeping the KbOverride_W limited keeps the "dead space"
;down and allows the PLC to respond to changes in the FeedrateKnob_W even if
;above 120. Overall override is still limited later but this gives better
;response in changing between KbOverride_W & the FeedrateKnob_W
IF KbOverride_W > SV_MACHINE_PARAMETER_39
  THEN KbOverride_W = SV_MACHINE_PARAMETER_39

IF KbOverride_W < MIN_FROR_PCT THEN KbOverride_W = MIN_FROR_PCT

IF True THEN FinalFeedOverride_W = KbOverride_W

;------------------------------------------------------------------------------
; 4 & 5. Limit override percentage to value set in Parameter 39
;------------------------------------------------------------------------------
;------------------Limit final override percentage to parm 39-------------------
IF FinalFeedOverride_W > SV_MACHINE_PARAMETER_39
  THEN FinalFeedOverride_W = SV_MACHINE_PARAMETER_39

IF FinalFeedOverride_W <= 1 THEN FinalFeedOverride_W = 1

;------------------------------------------------------------------------------
;  Override Controls
;  It is important that the plc program only writes to SV_PLC_FEEDRATE_KNOB once per pass
;------------------------------------------------------------------------------
; Override control bit for the feedrate override
; 1 == feedrate override knob will affect feedrate
; 0 == override knob has NO effect on feedrate
IF  !SV_PC_OVERRIDE_CONTROL_FEEDRATE_OVERRIDE THEN FinalFeedOverride_W = 100

;------------------------------------------------------------------------------
; 6. Send override percentage to CNC12
;------------------------------------------------------------------------------
;----------------Send override to PC for modification if needed---------------
IF True THEN SV_PLC_FEEDRATE_KNOB = FinalFeedOverride_W

;Activate LED's
IF FinalFeedOverride_W == 100 THEN (FeedOver100LED)
IF FinalFeedOverride_W == 75 THEN (FeedOver75LED)
IF FinalFeedOverride_W == 50 THEN (FeedOver50LED)
IF FinalFeedOverride_W == 25 THEN (FeedOver25LED)

;------------------------------------------------------------------------------
; 7. Copy the feedrate override sent from the PC to the MPU11.
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; Normally a number from 0.0-2.0, no limitations although V will not exceed
; Vmax. A negative number in here would be extremely bad.
;------------------------------------------------------------------------------
IF True THEN SV_PLC_FEEDRATE_OVERRIDE = SV_PC_FEEDRATE_PERCENTAGE/100.0

;--MPU11 Jog Panel Key Functions
IF KbTogRapidOver_M || SV_PC_TOGGLE_RAPID_OVERRIDE || RapidOver_M
  THEN (RapidOverPD), RST SV_PC_TOGGLE_RAPID_OVERRIDE
IF (RapidOverPD ^ SelectRapidOverride) || OnAtPowerUp_M THEN (SelectRapidOverride)

IF RapidOverPD THEN OverrideMsgTimer = 100, SET OverrideMsgTimer

IF SelectRapidOverride THEN (RapidOverLED), (OverrideRapidsEnabled_M)
IF !SelectRapidOverride THEN (OverrideRapidsDisabled_M)

IF RapidOverPD && OverrideRapidsEnabled_M THEN InfoMsg_W = RAPID_OVERRIDE_ENABLED
IF RapidOverPD && OverrideRapidsDisabled_M THEN InfoMsg_W = RAPID_OVERRIDE_DISABLED

IF ((InfoMsg_W == RAPID_OVERRIDE_ENABLED) || (InfoMsg_W == RAPID_OVERRIDE_DISABLED)) && 
  OverrideMsgTimer THEN InfoMsg_W = 0, RST OverrideMsgTimer, RST ShowInfoStage

IF (CycleCancelKey || KbCycleCancel_M || SkinCycleCancel_M || MpgResetKey_M || CycleCancel2 || SkinRestartCycleCancel_M) || ErrorFlag_M
  THEN (DoCycleCancel)
IF SV_STOP THEN RST SkinRestartCycleStart_M
IF SkinRestartCycleStart_M THEN (RestartCycleStart_PD)
IF ((CycleStartKey || KbCycleStart_M || SkinCycleStart_M || MpgCycleStart_M || CycleStart2) && !DoorFeedHold_M && !TorchRestartModeLED) || RestartCycleStart_PD THEN (DoCycleStart)

IF True THEN RST JogKeysNormalStage,
             RST JogKeysInvert2Stage,
             RST JogKeysSwappedStage,
             RST JogKeysSwapAndInvert2Stage

IF TRUE THEN JogKeyCfg_W = SV_MACHINE_PARAMETER_1
IF TRUE THEN BITTST JogKeyCfg_W 0 InvertXJogKeys_M
IF TRUE THEN BITTST JogKeyCfg_W 3 SwapAxes_M

IF !(InvertXJogKeys_M || SwapAxes_M) THEN SET JogKeysNormalStage
IF InvertXJogKeys_M && !SwapAxes_M THEN SET JogKeysInvert2Stage
IF !InvertXJogKeys_M && SwapAxes_M THEN SET JogKeysSwappedStage
IF InvertXJogKeys_M && SwapAxes_M THEN SET JogKeysSwapAndInvert2Stage

; First and second axis jogging is in configuration-specific
; stages following JogPanelStage

IF (Ax3PlusJogKey  || KbJogAx3Plus_M || SkinJogAx3Plus_M || MpgAxis3JogPlus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis3Selected)) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3PlusJog)
IF (Ax3MinusJogKey || KbJogAx3Minus_M || SkinJogAx3Minus_M || MpgAxis3JogMinus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis3Selected)) && !Ax3MinusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3MinusJog)
IF (Ax4PlusJogKey  || KbJogAx4Plus_M || SkinJogAx4Plus_M || MpgAxis4JogPlus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis4Selected)) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4PlusJog)
IF (Ax4MinusJogKey || KbJogAx4Minus_M || SkinJogAx4Minus_M || MpgAxis4JogMinus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis4Selected)) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4MinusJog)

IF MpgSetAxisZero_M && UsbMpgAxis1Active_M && MpgAxis1Selected_M THEN (SV_PLC_SET_AXIS_1_PART_ZERO)
IF MpgSetAxisZero_M && UsbMpgAxis2Active_M && MpgAxis2Selected_M THEN (SV_PLC_SET_AXIS_2_PART_ZERO)
IF MpgSetAxisZero_M && UsbMpgAxis3Active_M && MpgAxis3Selected_M THEN (SV_PLC_SET_AXIS_3_PART_ZERO)
IF MpgSetAxisZero_M && UsbMpgAxis4Active_M && MpgAxis4Selected_M THEN (SV_PLC_SET_AXIS_4_PART_ZERO)

IF (Aux1Key  || KbAux1Key_M || SkinAux1_M) THEN (DoAux1Key)
IF (Aux2Key  || KbAux2Key_M || SkinAux2_M) THEN (DoAux2Key)
IF (Aux3Key  || KbAux3Key_M || SkinAux3_M) THEN (DoAux3Key)
IF (Aux4Key  || KbAux4Key_M || SkinAux4_M) THEN (DoAux4Key)
IF (Aux5Key  || KbAux5Key_M || SkinAux5_M) || 
	(SkinSpindleMed_M && BackGearEnabled_M) THEN (DoAux5Key)
IF (Aux6Key  || KbAux6Key_M || SkinAux6_M) THEN (DoAux6Key)
IF (Aux7Key  || KbAux7Key_M || SkinAux7_M) THEN (DoAux7Key)
IF (Aux8Key  || KbAux8Key_M  || SkinAux8_M) ||
	((SkinTorchCheck_M || MpgToolCheck_M) && !TorchRestartModeLED)  THEN (DoAux8Key)
IF (Aux9Key  || KbAux9Key_M  || SkinAux9_M)  THEN (DoAux9Key)
IF (Aux10Key || KbAux10Key_M || SkinAux10_M) THEN (DoAux10Key)
IF (Aux11Key || KbAux11Key_M || SkinAux11_M) THEN (DoAux11Key)
IF (Aux12Key || KbAux12Key_M || SkinAux12_M) THEN (DoAux12Key)
IF (Aux13Key || KbAux13Key_M || SkinAux13_M) THEN (DoAux13Key)
IF (Aux14Key || KbAux14Key_M || SkinAux14_M) THEN (DoAux14Key)
IF (Aux15Key || KbAux15Key_M || SkinAux15_M) THEN (DoAux15Key)
IF (Aux16Key || KbAux16Key_M || SkinAux16_M) THEN (DoAux16Key)

IF x1JogLED    THEN (SelectX1JogInc)
IF x10JogLED   THEN (SelectX10JogInc)
IF x100JogLED  THEN (SelectX100JogInc)
IF IncrContLED THEN (SelectIncContJog)
IF FastSlowLED THEN (SelectFastSlowJog)
IF MPGLED      THEN (SelectMpgMode)
IF FeedHoldLED && SV_PC_OVERRIDE_CONTROL_FEEDHOLD || DoorFeedHold_M THEN (DoFeedHold)

;--Coolant Functions

;--Toggle auto coolant mode
IF CoolAutoManKey || KbTogCoolAutoMan_M || SkinCoolAutoMan_M THEN (CoolantAutoManualPD)

IF (!CoolAutoModeLED && CoolantAutoManualPD) || OnAtPowerUp_M
  THEN SET CoolAutoModeLED

IF (CoolAutoModeLED && CoolantAutoManualPD)
  THEN RST CoolAutoModeLED

;--Report coolant mode to CNC12
IF CoolAutoModeLED THEN (SelectCoolAutoMan)

;--Display coolant mode message
;changing to auto coolant mode ;2050 Auto Coolant Selected 2 + 50*256
IF (!CoolAutoModeLED && CoolantAutoManualPD && AllowKbInput_M)
  THEN InfoMsg_W = AUTO_COOL_MSG

;changing to manual coolant mode ;2051 Manual Coolant Selected 2 + 51*256
IF (CoolAutoModeLED && CoolantAutoManualPD && AllowKbInput_M)
  THEN InfoMsg_W = MAN_COOL_MSG

;--Flood coolant on/off
;
;  Toggle on/off or off/on if:
;    In manual mode and a toggle key was pressed
;  Turn on if:
;    In auto mode and have M8
;  Turn off if:
;    Any fault or error
;    In auto mode and don't have M8
;    Doing tool check (?)
IF CoolFloodKey || KbFloodOnOff_M || SkinCoolFlood_M THEN (CoolantFloodPD)
IF (((Flood || RouterDustCollection) ^ (!CoolAutoModeLED && CoolantFloodPD))
   || CoolAutoModeLED && M8)
   && !(SV_STOP ||
        CoolAutoModeLED && !M8 ||
        ErrorFlag_M ||
        DoToolCheck)
  THEN (Flood), (CoolFloodLED), (SelectCoolantFlood), (RouterDustCollection)

;--Mist coolant on/off
IF (CoolMistKey || KbMistOnOff_M || SkinCoolMist_M) THEN (CoolantMistPD)
IF (((Mist || RouterVacuumHoldDown) ^ (!CoolAutoModeLED && CoolantMistPD))
   || CoolAutoModeLED && M7)
   && !(SV_STOP ||
        CoolAutoModeLED && !M7 ||
        ErrorFlag_M ||
        DoToolCheck)
  THEN (Mist), (CoolMistLED), (SelectCoolantMist), (RouterVacuumHoldDown)

;--Spindle Control
;------------------------------------------------------------------------------
; JOGBOARD SPINDLE CONTROL
; Spindle Auto Mode / Manual mode toggles via Auto/Man jog panel key
; CW/CCW jog keys determine spindle direction in manual mode
; M3/M4 system variables determine spindle direction in Auto mode
; Spindle can be stopped and restarted in auto mode using
; spin stop/start jog keys
;------------------------------------------------------------------------------
;--Select Auto or Manual Spindle Operation Mode
;Triggers to Toggle Auto/Manual Spindle Mode
IF SpinAutoManKey || KbTogSpinAutoMan_M || SkinSpinAutoMan_M || (MpgSpinAutoMan_M && !PlasmaWMPG_M)
  THEN (SpinAutoManPD)

;--Set spindle to auto mode on startup
IF (SpinAutoManPD && !SpinAutoModeLED) || OnAtPowerUp_M
  THEN SET SpinAutoModeLED

;--Set spindle to manual mode
IF SpinAutoManPD && SpinAutoModeLED THEN RST SpinAutoModeLED

;--Report the Spindle mode to CNC12
IF SpinAutoModeLED THEN (SelectManAutoSpindle)

;--Set triggers to start and stop the spindle

; NOTE: SpindlePause_M allows the operator to start and stop the
; spindle with the spin start and stop keys while in a job.  In
; this case, pressing the spindle start key will only restart
; the spindle if an M3 or M4 had previously been issued and is
; still active.

;Handling for MPG Spindle on/off button MpgSpinOnOff_M
IF MpgSpinOnOff_M && !MpgSpinOnOffPressed_M && !MpgSpinOnState_M && !PlasmaWMPG_M
	THEN SET MpgSpinOnState_M, SET MpgSpinOn_M, SET MpgSpinOnOffPressed_M, RST MpgSpinOff_M

IF MpgSpinOnOff_M && !MpgSpinOnOffPressed_M && MpgSpinOnState_M && !PlasmaWMPG_M
	THEN SET MpgSpinOff_M, RST MpgSpinOn_M, SET MpgSpinOnOffPressed_M, RST MpgSpinOnState_M

IF !MpgSpinOnOff_M && !PlasmaWMPG_M
	THEN RST MpgSpinOnOffPressed_M, RST MpgSpinOn_M, RST MpgSpinOff_M

IF (SpinAutoModeLED && (M3 || M4) && (SpinStopKey || KbSpinStop_M || SkinSpinStop_M || MpgSpinOff_M))
  THEN SET SpindlePause_M
IF ((M3 || M4) && (SpinStartKey || KbSpinStart_M || SkinSpinStart_M || MpgSpinOn_M) ||
    !(SV_PROGRAM_RUNNING || SV_MDI_MODE))
  THEN RST SpindlePause_M

IF ((SpinStartKey || KbSpinStart_M || SkinSpinStart_M || MpgSpinOn_M) && !SpinAutoModeLED) ||
  (SpinAutoModeLED && (M3 || M4) && !SpindlePause_M && !FeedHoldLED) ||
  ((SpinStartKey || KbSpinStart_M || SkinSpinStart_M || MpgSpinOn_M) && ((M3 || M4) && SpinAutoModeLED))
  THEN (SpinStart_M)

IF (ProbeDetect && !ProbeDetectDisabled_M && ((SV_MACHINE_PARAMETER_416 == 1) || SV_MACHINE_PARAMETER_416 == 3)) ||
	(ToolTouchOffDetect && !TTDetectDisabled_M && ((SV_MACHINE_PARAMETER_416 == 1) || SV_MACHINE_PARAMETER_416 == 2))
	THEN (ProbeSpindleInhibit_M)

IF (SpinStopKey || KbSpinStop_M || SkinSpinStop_M || MpgSpinOff_M) ||
	(SpinAutoModeLED && !(M3 || M4)) ||
	(SV_PC_RIGID_TAP_SPINDLE_OFF && SpinAutoModeLED) ||
	ProbeSpindleInhibit_M || SV_STOP || ErrorFlag_M || LimitTripped_M ||
	!ChuckOpenCloseComplete_M || M51_SV
   THEN (SpinStop_M)

;--Adjust spindle override when entering manual or auto spin mode
;Set the override value to 100% when spin auto mode is first selected
IF SpinAutoManPD && !SpinAutoModeLED
  THEN SV_PLC_SPINDLE_KNOB = 100,
       SET SpinAutoModeLED

;Set the override value to 10% whenever manual mode is entered
IF SpinAutoManPD && SpinAutoModeLED
  THEN SV_PLC_SPINDLE_KNOB = 10, RST SpinAutoModeLED

;--Set spindle direction
;------------------Set Clockwise direction
IF ((KbSpinCW_M || SpinCWKey || SkinSpinCW_M) && !SpinAutoModeLED) || (M3 && SpinAutoModeLED)
  THEN RST SpindleDirection_M
IF !SpindleDirection_M THEN (SpindleCWLED), (SelectSpindleCW)

;---------------Set Counterclockwise direction
IF ((KbSpinCCW_M || SpinCCWKey || SkinSpinCCW_M) && !SpinAutoModeLED) || (M4 && SpinAutoModeLED)
  THEN SET SpindleDirection_M
IF SpindleDirection_M THEN (SpindleCCWLED), (SelectSpindleCCW)

;IF (SpindleDirection_M ^ SpinRangeReversed_M) && !SpindleForwardOut THEN (SpindleDirectionOut)
IF SpindleDirection_M ^ SpinRangeReversed_M THEN (SpindleDirectionOut_M)

;-------------------------------------------------------------------------------
;                                Turn spindle on/off
;-------------------------------------------------------------------------------
IF ProbeSpindleInhibit_M && SpinStart_M THEN SET ProbeFault_M

;-----DOOR INTERLOCK-----------------------------------------------------------
;Prevent Spin if Door Open
IF (SpindleEnableOut_M || SpinStart_M) && ((DoorInterlockMode_M || DoorInterlockShutdown_M)  && !SafetyDoorSwitchClosed_I)
     THEN ErrorMsg_W = DOOR_NOT_CLOSED, RST SpindleEnableOut_M
;-----DOOR INTERLOCK-----------------------------------------------------------

;------------------------------------------------------------------------------
;          SPINDLE OVERRIDE CONTROL
;       Jogboard (-, +, and 100% keys),
; Keyboard "ctrl" + "<", "ctrl" + ">", "ctrl" + "/"
;------------------------------------------------------------------------------
IF (SpinOverPlusKey || KbIncSpinOver_M || SkinSpinOverPlus_M) THEN (SpinOverPlusPD)
IF (SpinOverMinusKey || KbDecSpinOver_M || SkinSpinOverMinus_M) THEN (SpinOverMinusPD)

IF SpinOverPlusKey || KbIncSpinOver_M || SkinSpinOverPlus_M ||
	SpinOverMinusKey || KbDecSpinOver_M || SkinSpinOverMinus_M
	THEN SET SpinOverTimer_T
	
IF !SpinOverPlusKey && !KbIncSpinOver_M && !SkinSpinOverPlus_M &&
	!SpinOverMinusKey && !KbDecSpinOver_M && !SkinSpinOverMinus_M
	THEN RST SpinOverTimer_T

IF ((SpinOverPlusKey || KbIncSpinOver_M || SkinSpinOverPlus_M) && SV_MACHINE_PARAMETER_820 != 3) ||
	((SpinOverPlusPD || ((SpinOverPlusKey || KbIncSpinOver_M || SkinSpinOverPlus_M) && SpinOverTimer_T)) &&
	SV_MACHINE_PARAMETER_820 == 3) THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB + 1

IF ((SpinOverMinusKey || KbDecSpinOver_M || SkinSpinOverMinus_M) && SV_MACHINE_PARAMETER_820 != 3) ||
	((SpinOverMinusPD || ((SpinOverMinusKey || KbDecSpinOver_M || SkinSpinOverMinus_M) && SpinOverTimer_T)) &&
	SV_MACHINE_PARAMETER_820 == 3) THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB - 1

IF SpinOver100Key || KbSpinOver100_M || OnAtPowerUp_M || SkinSpin100_M
  THEN SV_PLC_SPINDLE_KNOB = 100

;MPG Spindle Logic
IF !MpgSpinWheelSelect_M THEN RST MpgSpinWheelSet_M
IF (MpgSpinWheelSelect_M && !MpgSpinWheelSet_M) THEN  UsbWheelLast = SV_MPU11_ABS_POS_5, SET MpgSpinWheelSet_M
IF MpgSpinWheelSet_M THEN UsbWheelCurrent = SV_MPU11_ABS_POS_5
IF MpgSpinWheelSet_M THEN UsbWheelDelta = (UsbWheelCurrent - UsbWheelLast)
IF MpgSpinWheelSet_M THEN UsbWheelLast = UsbWheelCurrent
IF MpgSpinWheelSet_M THEN SV_PLC_SPINDLE_KNOB = (SV_PLC_SPINDLE_KNOB + UsbWheelDelta)

IF SV_PLC_SPINDLE_KNOB < 1  THEN SV_PLC_SPINDLE_KNOB = 1
IF SV_PLC_SPINDLE_KNOB > 200 THEN SV_PLC_SPINDLE_KNOB = 200

IF SV_PLC_SPINDLE_KNOB == 100 THEN
  (SpinOver100LED),
  (SelectSpinOr100)

IF SV_PLC_SPINDLE_KNOB < 100 THEN
  (SpinOverMinusLED),
  (DoDecreaseSpindleOr )

IF SV_PLC_SPINDLE_KNOB > 100 THEN
  (SpinOverPlusLED),
  (DoIncreaseSpindleOr)

;--Output 12-bit DAC value for spindle control
;-----------------------------------------------------------------------------
;             Read spindle range inputs and/or range M codes
;
; NOTE: SV_SPINDLE_LOW_RANGE & SV_SPINDLE_MID_RANGE M are used to report the
; selected spindle range to CNC12
;-----------------------------------------------------------------------------
;   4 hi   3 med-high  2 med-low  1 low
;    0          1         1         0   SV_SPINDLE_MID_RANGE M
;    0          0         1         1   SV_SPINDLE_LOW_RANGE

; Use input switches, M functions, or other means to determine the gear
; range number (1-4).  For basic mills, look for one low-range switch.
; Default to high range until proven otherwise (fail-safe choice)
IF Aux4Key THEN (Aux4PD)
IF Aux5Key THEN (Aux5PD)
IF Aux6Key THEN (Aux6PD)

; Toggle BackGear On and Off
IF SV_MACHINE_PARAMETER_412 > 0 THEN SET BackGearEnabled_M
IF SV_MACHINE_PARAMETER_412 == 0 THEN RST BackGearEnabled_M

; Restore the use of Aux 5 key when BackGear mode is enabled.
;IF (SkinSpindleMed_M && BackGearEnabled_M) THEN (DoAux5Key)

IF M41 || SkinSpindleLow_M || (SpindleLowRange || (!BackGear && BackGearEnabled_M))
  THEN SpindleRange_W = 1, SET SpindleLowLED, RST SpindleMedLED, RST SpindleHighLED, RST M42, RST M43

IF ((M42 || SkinSpindleMed_M || SpindleMedRange) && !BackGearEnabled_M)
  THEN SpindleRange_W = 2, RST SpindleLowLED, SET SpindleMedLED, RST SpindleHighLED, RST M41, RST M43

IF OnAtPowerUp_M || M43 || SkinSpindleHigh_M || (SpindleHighRange || (BackGear && BackGearEnabled_M))
  THEN SpindleRange_W = 3, RST SpindleLowLED, RST SpindleMedLED, SET SpindleHighLED, RST M41, RST M42

IF OnAtPowerUp_M || (SpindleRange_W == 0) THEN SpindleRange_W = 4, SET SpindleHighLED


; Use the gear range number to set the range flags and speed ratio.

IF SpindleRange_W == 1 THEN SET SV_SPINDLE_LOW_RANGE,
                            RST SV_SPINDLE_MID_RANGE,
                            SpinRangeAdjust_FW = SV_MACHINE_PARAMETER_65

IF SpindleRange_W == 2 THEN SET SV_SPINDLE_LOW_RANGE,
                            SET SV_SPINDLE_MID_RANGE,
                            SpinRangeAdjust_FW = SV_MACHINE_PARAMETER_66

IF SpindleRange_W == 3 THEN RST SV_SPINDLE_LOW_RANGE,
                            SET SV_SPINDLE_MID_RANGE,
                            SpinRangeAdjust_FW = 1.0

IF SpindleRange_W == 4 THEN RST SV_SPINDLE_LOW_RANGE,
                            RST SV_SPINDLE_MID_RANGE,
                            SpinRangeAdjust_FW = 1.0

; If the speed ratio parameter is negative, reverse the motor.
; Always use the absolute value of the parameter as the real ratio.
IF SpinRangeAdjust_FW < 0.0 THEN (SpinRangeReversed_M),
                                 SpinRangeAdjust_FW = -SpinRangeAdjust_FW

; Force the ratio to be non-zero, because we are going to divide by it later.
IF SpinRangeAdjust_FW < 0.001 THEN SpinRangeAdjust_FW = 0.001

;------------------------------------------------------------------------------
;              Read commanded spindle speed, max & min
;
; ***NOTE***  SV_PC_COMMANDED_SPINDLE_SPEED already has override
;             factored in.
;------------------------------------------------------------------------------
IF True THEN CfgMinSpeed_FW = SV_PC_CONFIG_MIN_SPINDLE_SPEED,
             CfgMaxSpeed_FW = SV_PC_CONFIG_MAX_SPINDLE_SPEED

; Calculate #RPM's per bit of resolution
IF CfgMaxSpeed_FW > 0.0 THEN RPMPerBit_FW = CfgMaxSpeed_FW/4095.0
IF CfgMaxSpeed_FW <= 0.0 THEN RPMPerBit_FW = 1.0

; In auto mode, assuming M3 or M4 present, use given RPM from CNC11/CNC12
IF SpinAutoModeLED THEN SpinSpeedCommand_FW = SV_PC_COMMANDED_SPINDLE_SPEED
IF SpinSpeedCommand_FW > 1 THEN SET MEM999
IF SpinSpeedCommand_FW < 1 THEN RST MEM999

; In manual mode, assuming spindle is on, use speed scaled from CCFG max
IF !SpinAutoModeLED THEN SpinSpeedCommand_FW = CfgMaxSpeed_FW *
                                               SV_PLC_SPINDLE_KNOB / 200.0 *
                                               SpinRangeAdjust_FW

; In manual or auto, if no M3/M4 or spindle run, then use zero instead
;;; but note that SpindleDisable_M only applies to G540....
IF SpindleDisable_M THEN SpinSpeedCommand_FW = 0.0

;------------------------------------------------------------------------------
; If commanded spindle speed is < Min Spin Speed * SpinRangeAdjust
; & commanded spindle speed > 0, force to commanded spindle speed
; = min spin speed value * SpinRangeAdjust.
;------------------------------------------------------------------------------
IF (SpinSpeedCommand_FW > 0.0) &&
   (SpinSpeedCommand_FW < (CfgMinSpeed_FW * SpinRangeAdjust_FW))
  THEN SpinSpeedCommand_FW = (CfgMinSpeed_FW * SpinRangeAdjust_FW),
       InfoMsg_W = MIN_SPEED_MSG

;------------------------------------------------------------------------------
; If SpinSpeedCommand_FW > Max Spin Speed * SpinRangeAdjust, force
; SpinSpeedCommand_FW = max spin speed value * SpinRangeAdjust.
;------------------------------------------------------------------------------
IF SpinSpeedCommand_FW > (CfgMaxSpeed_FW * SpinRangeAdjust_FW)
  THEN SpinSpeedCommand_FW = (CfgMaxSpeed_FW * SpinRangeAdjust_FW)

;------------------------------------------------------------------------------
; Convert Spindle "S" command to 12 bit value for output to DAC
;------------------------------------------------------------------------------
; Commanded Spindle speed (includes override factor) is sent down from CNC12
; in SV_PC_COMMANDED_SPINDLE_SPEED.  This value needs to be converted to a
; 12 bit value (0-4095) where full scale = SV_PC_CONFIG_MAX_SPINDLE_SPEED.

;Convert RPM to 12 bit value
IF True THEN TwelveBitSpeed_FW = SpinSpeedCommand_FW/RPMPerBit_FW

; Factor in gear range
IF True THEN TwelveBitSpeed_FW = (TwelveBitSpeed_FW/SpinRangeAdjust_FW)

;Convert to integer word for DAC & I/O display
IF True THEN TwelveBitSpeed_W = TwelveBitSpeed_FW

; Bound min to 0, max to 4095
IF TwelveBitSpeed_W < 0 THEN TwelveBitSpeed_W = 0
IF TwelveBitSpeed_W > 4095 THEN TwelveBitSpeed_W = 4095

If !SpinAutoModeLED && G540SpindleStage && SpindleDisable_M THEN TwelveBitSpeed_W = 0
If !SpinAutoModeLED && !G540SpindleStage && !SpindleEnableOut_M THEN TwelveBitSpeed_W = 0

;Divide Analog by 2 if Set to 0-5V Range by Parameter 420
IF SV_MACHINE_PARAMETER_420 > 0 THEN TwelveBitSpeed_W = TwelveBitSpeed_W / 2

; Output to DAC
IF True THEN WTB TwelveBitSpeed_W SpinAnalogOutBit0 12

;Display calculated RPM value on PC
IF RPMSensorDisabled_M THEN SV_PLC_SPINDLE_SPEED = SpinSpeedCommand_FW
;IF True THEN SV_SPINDLE_DAC = SpinSpeedCommand_FW, SET SV_SPINDLE_RPM_MODE

;Display Calculated RPM Value from Sensor
IF SpinSensorTimer_FW <= 0 THEN SpinSensorTimer_FW = 60000
IF True then SpinSensorSpeed_FW = ((1/SpinSensorTimer_FW) * 60000)
IF SpinSensorSpeed_FW <=20 THEN SpinSensorSpeed_FW = 0

IF !RPMSensorDisabled_M THEN SV_PLC_SPINDLE_SPEED = SpinSensorSpeed_FW

;Display Calculated Voltage
IF SV_MACHINE_PARAMETER_820 == 3 THEN SV_PLC_SPINDLE_SPEED = TorchVoltage_W * SV_MACHINE_PARAMETER_518 * SV_MACHINE_PARAMETER_525

;=============================================================================
   JogKeysNormalStage
;=============================================================================
;        X+  LATHE                     MILL   Y+       Z+
;        |                           4+       |
;   Z- -- -- Z+                          X- -- -- X+
;        |                                    |
;        X-                          4-       Y-       Z-
IF (Ax1PlusJogKey  || KbJogAx1Plus_M || SkinJogax1Plus_M || MpgAxis1JogPlus_M || 
  SkinJogAx1Ax2Plus_M || SkinJogAx1PlusAx2Minus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis1Selected)) && !Ax1PlusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1PlusJog)
IF (Ax1MinusJogKey || KbJogAx1Minus_M || SkinJogAx1Minus_M || MpgAxis1JogMinus_M ||
  SkinJogAx1Ax2Minus_M || SkinJogAx1MinusAx2Plus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis1Selected)) && !Ax1MinusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1MinusJog)
IF (Ax2PlusJogKey  || KbJogAx2Plus_M || SkinJogAx2Plus_M || MpgAxis2JogPlus_M ||
  SkinJogAx1Ax2Plus_M || SkinJogAx1MinusAx2Plus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis2Selected)) && !Ax2PlusJogDisabled_M  &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2PlusJog)
IF (Ax2MinusJogKey || KbJogAx2Minus_M || SkinJogAx2Minus_M || MpgAxis2JogMinus_M ||
  SkinJogAx1Ax2Minus_M || SkinJogAx1PlusAx2Minus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis2Selected)) && !Ax2MinusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2MinusJog)

;=============================================================================
   JogKeysInvert2Stage
;=============================================================================
;        X-  LATHE                    MILL   Y-       Z+
;        |                          4+       |
;   Z- -- -- Z+                         X- -- -- X+
;        |                                   |
;        X+                         4-       Y+       Z-
IF (Ax1PlusJogKey  || KbJogAx1Plus_M || SkinJogAx1Plus_M || MpgAxis1JogPlus_M ||
  SkinJogAx1Ax2Plus_M || SkinJogAx1PlusAx2Minus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis1Selected)) && !Ax1PlusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1PlusJog)
IF (Ax1MinusJogKey || KbJogAx1Minus_M || SkinJogAx1Minus_M || MpgAxis1JogMinus_M ||
  SkinJogAx1Ax2Minus_M || SkinJogAx1MinusAx2Plus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis1Selected) ) && !Ax1MinusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1MinusJog)
IF (Ax2MinusJogKey  || KbJogAx2Minus_M || SkinJogAx2Minus_M || MpgAxis2JogPlus_M ||
  SkinJogAx1Ax2Minus_M || SkinJogAx1PlusAx2Minus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis2Selected)) && !Ax2PlusJogDisabled_M  &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2PlusJog)
IF (Ax2PlusJogKey || KbJogAx2Plus_M || SkinJogAx2Plus_M || MpgAxis2JogMinus_M ||
  SkinJogAx1Ax2Plus_M || SkinJogAx1MinusAx2Plus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis2Selected)) && !Ax2MinusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2MinusJog)

;=============================================================================
   JogKeysSwappedStage
;=============================================================================
;        Z+  LATHE                       MILL   X+       Z+
;        |                             4+       |
;   X- -- -- X+                            Y- -- -- Y+
;        |                                      |
;        Z-                            4-       X-       Z-
IF (Ax2PlusJogKey  || KbJogAx2Plus_M || SkinJogAx2Plus_M || MpgAxis2JogPlus_M ||
  SkinJogAx1Ax2Plus_M || SkinJogAx1MinusAx2Plus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis2Selected)) && !Ax1PlusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1PlusJog)
IF (Ax2MinusJogKey || KbJogAx2Minus_M || SkinJogAx2Minus_M || MpgAxis2JogMinus_M ||
  SkinJogAx1Ax2Minus_M || SkinJogAx1PlusAx2Minus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis2Selected)) && !Ax1MinusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1MinusJog)
IF (Ax1PlusJogKey  || KbJogAx1Plus_M || SkinJogAx1Plus_M || MpgAxis1JogPlus_M ||
  SkinJogAx1Ax2Plus_M || SkinJogAx1PlusAx2Minus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis1Selected)) && !Ax2PlusJogDisabled_M  &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2PlusJog)
IF (Ax1MinusJogKey || KbJogAx1Minus_M || SkinJogAx1Minus_M || MpgAxis1JogMinus_M ||
  SkinJogAx1Ax2Minus_M || SkinJogAx1MinusAx2Plus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis1Selected)) && !Ax2MinusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2MinusJog)

;=============================================================================
   JogKeysSwapAndInvert2Stage
;=============================================================================
;        Z+                             MILL   Y+       Z+
;        |                            4+       |
;   X+ -- -- X-                           X+ -- -- X-
;        |                                     |
;        Z-                           4-       Y-       Z-
IF (Ax2PlusJogKey  || KbJogAx2Plus_M || SkinJogAx2Plus_M || MpgAxis2JogPlus_M ||
  SkinJogAx1Ax2Plus_M || SkinJogAx1MinusAx2Plus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis2Selected)) && !Ax1PlusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1PlusJog)
IF (Ax2MinusJogKey || KbJogAx2Minus_M || SkinJogAx2Minus_M || MpgAxis2JogMinus_M ||
  SkinJogAx1Ax2Minus_M || SkinJogAx1PlusAx2Minus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis2Selected)) && !Ax1MinusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1MinusJog)
IF (Ax1MinusJogKey  || KbJogAx1Minus_M || SkinJogAx1Minus_M || MpgAxis1JogPlus_M ||
  SkinJogAx1Ax2Minus_M || SkinJogAx1MinusAx2Plus_M ||
  (ShuttleAxisJogPlusKey && ShuttleAxis1Selected)) && !Ax2PlusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2PlusJog)
IF (Ax1PlusJogKey || KbJogAx1Plus_M || SkinJogAx1Plus_M || MpgAxis1JogMinus_M ||
  SkinJogAx1Ax2Plus_M || SkinJogAx1PlusAx2Minus_M ||
  (ShuttleAxisJogMinusKey && ShuttleAxis1Selected)) && !Ax2MinusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2MinusJog)

;=============================================================================
                     AxesEnableStage
;=============================================================================

;allow MPU11 to turn on drives if no drive or drive fiber errors
IF !DriveComFltIn_M && !DriveComFltOut_M THEN SET SV_MASTER_ENABLE

;Report external drive faults
IF SV_AXIS_VALID_1 && SV_PC_POWER_AXIS_1 && (!Axis1DriveOk && DriveFaultTimer)
  THEN FaultMsg_W = AXIS1_DRIVE_FAULT_MSG, ; 6401(1+256*25)
    SET AxisFault_M
IF SV_AXIS_VALID_2 && SV_PC_POWER_AXIS_2 && (!Axis2DriveOk && DriveFaultTimer)
  THEN FaultMsg_W = AXIS2_DRIVE_FAULT_MSG, ; 6655(1+256*26)
    SET AxisFault_M
IF SV_AXIS_VALID_3 && SV_PC_POWER_AXIS_3 && (!Axis3DriveOk && DriveFaultTimer)
  THEN FaultMsg_W = AXIS3_DRIVE_FAULT_MSG, ; 6913(1+256*27)
    SET AxisFault_M
IF SV_AXIS_VALID_4 && SV_PC_POWER_AXIS_4 && (!Axis4DriveOk && DriveFaultTimer)
  THEN FaultMsg_W = AXIS4_DRIVE_FAULT_MSG, ; 7169(1+256*28)
    SET AxisFault_M
;IF SV_AXIS_VALID_5 && SV_PC_POWER_AXIS_5 && (!Axis5DriveOk_M && DriveFaultTimer)
;  THEN FaultMsg_W = AXIS5_DRIVE_FAULT_MSG, ; 7425(1+256*29)
;    SET AxisFault_M

; Axis Brake Logic
IF (SV_PC_POWER_AXIS_1) THEN (Axis1BrakeRelease)
IF (SV_PC_POWER_AXIS_2) THEN (Axis2BrakeRelease)
IF (SV_PC_POWER_AXIS_3) THEN (Axis3BrakeRelease)
IF (SV_PC_POWER_AXIS_4) THEN (Axis4BrakeRelease)

;clear axis fault errors
IF !EStopOk || SkinResetSet_M THEN RST AxisFault_M

; (SV_MASTER_ENABLE will be turned off by stalls and other
;  errors in the Fault-handling section of MainStage, below.)

;(If there is any drive or drive fiber error, then AxisFault_M will have
; been set previously, which will cause SV_STOP to be set, and SV_MASTER_ENABLE
; to be reset, later in MainStage)

;=============================================================================
                           MainStage
;=============================================================================
;------------------------------------------------------------------------------
;                           Configurable IO Section
;------------------------------------------------------------------------------

; These I/O used to be in the wizard section below but are not
; selectable in the Wizard itself.
IF True THEN RST Custom         ; M35
IF True THEN RST LockSpindle

; DO NOT MODIFY
; #wizardregion Configuration
IF True THEN SET FirstAxisHomeLimitOk
IF True THEN SET FirstAxisHomeOk
IF True THEN SET SecondAxisHomeLimitOk
IF True THEN SET SecondAxisHomeOk
IF True THEN RST BackGear
IF True THEN RST ProbeTripped
IF True THEN SET ProbeDetect, SET ProbeDetectDisabled_M
IF True THEN SET DriveOk
IF True THEN SET LubeOk
IF True THEN RST ChuckIsOpen, SET ChuckIsOpenIs_M
IF True THEN RST ChuckIsClosed, SET ChuckIsClosedIs_M
IF True THEN SET SpindleOk
IF True THEN RST SpindleLowRange
IF True THEN RST SpindleMedRange
IF True THEN RST SpindleHighRange
IF True THEN RST ChuckFootPedal_I
IF True THEN RST CutOffIsDown, SET CutOffIsDownIs_M
IF True THEN RST PartChuteIsIn, SET PartChuteIsInIs_M
IF True THEN RST ToolTurretPosBit1
IF True THEN RST ToolTurretPosBit2
IF True THEN RST ToolTurretPosBit3
IF True THEN RST ToolTurretPosBit4
IF True THEN RST ToolTurretCounter
IF True THEN RST ToolTurretSyncBit
IF True THEN SET ToolIsUnclamped, SET ToolIsUnclampedDisable_M
IF True THEN SET SpindleIsOriented
IF True THEN SET HomeAll
IF True THEN SET SlavedHomeInput
IF True THEN RST ToolTouchOffTriggered
IF True THEN SET ToolTouchOffDetect, SET TTDetectDisabled_M
IF True THEN SET SafetyDoorSwitchClosed_I
IF True THEN SET SafetyDoorLockConfirmed_I
IF True THEN RST CycleStart2
IF True THEN RST CycleCancel2
IF True THEN RST FeedHold2
IF True THEN RST ToolCheck2
IF True THEN SET Axis1DriveOk
IF True THEN SET Axis2DriveOk
IF True THEN SET Axis3DriveOk
IF True THEN SET Axis4DriveOk
IF True THEN RST ToolUnclampButton
IF True THEN SET VFDZeroSpeed
IF True THEN SET VFDUpToSpeed
IF True THEN SET DrawBarReleased, SET DrawBarReleasedDisable_M
IF True THEN RST SpindleTempAlarmMessage
IF True THEN RST SpindleTempAlarmStop
IF True THEN RST AirPressureLowMessage
IF True THEN RST AirPressureLowStop
IF True THEN RST RPM_Sensor, SET RPMSensorDisabled_M
IF True THEN SET TorchBreakawayOk
IF True THEN SET TorchFloatSwitchDisabled_M
IF True THEN SET TorchArcOkDisabled_M
IF True THEN SET SlavedAxisDriveOk
IF True THEN RST NoFaultOut
IF True THEN RST LubePump
IF True THEN SET SpindleBrakeRelease, SET SpindleBrakeDisabled_M
IF True THEN RST SpinFWD
IF True THEN RST SpinREV
IF True THEN RST DriveResetOut
IF True THEN RST Flood
IF True THEN RST TurnClampOn
IF True THEN RST G540SpinRevOff
IF True THEN RST G540SpinFwdOff
IF True THEN RST Mist
IF True THEN RST VacuumOn
IF True THEN RST DustCollectionOn
IF True THEN RST OpenChuck
IF True THEN RST CloseChuck
IF True THEN RST WorkLight, SET WorkLightDisabled_M
IF True THEN RST PartChute
IF True THEN RST AirBlowNozzle
IF True THEN RST ColletOpenClose, SET ColletDisabled_M
IF True THEN RST CutOff
IF True THEN RST RotateToolTurret
IF True THEN RST ReverseToolTurret
IF True THEN RST ToolTurretEnable
IF True THEN RST UnclampTool
IF True THEN RST OrientSpindle
IF True THEN RST ATC_CarouselForward
IF True THEN RST ATC_CarouselReverse
IF True THEN RST ATC_ToolCounter
IF True THEN RST ATC_CarouselIsIn
IF True THEN RST ATC_CarouselIsOut
IF True THEN RST ATC_CarouselOut
IF True THEN RST ATC_CarouselIn
IF True THEN RST SafetyDoorLockOpen_O
IF True THEN RST VFDEnable_O
IF True THEN SET VFDDirection_O
IF True THEN RST VFDResetOut_O
IF True THEN RST TailStockInOut
IF True THEN RST ATCAirBlowActivate
IF True THEN RST RouterDustCollection
IF True THEN RST RouterVacuumHoldDown
IF True THEN RST DustFootActivate
IF True THEN RST LaserAlignActivate
IF True THEN RST PopUpPins
IF True THEN RST SpindleCooling
IF True THEN RST GreenLight
IF True THEN RST AmberLight
IF True THEN RST RedLight
IF True THEN RST SpindleCooling_Fan
IF True THEN RST LaserEnable
IF True THEN RST PWMSelect
IF True THEN RST LaserReset
IF True THEN RST PWMOutput
IF True THEN RST TorchOn
IF True THEN RST TorchTouchDisconnect
IF True THEN RST M94M95124
IF True THEN RST M94M95123
IF True THEN RST M94M95122
IF True THEN RST M94M95121
IF True THEN RST M94M95120
IF True THEN RST M94M95119
IF True THEN RST M94M95113
IF True THEN RST M94M95125
IF True THEN RST M94M95111
IF True THEN RST M94M95118
IF True THEN RST M94M95117
IF True THEN RST M94M95116
IF True THEN RST M94M95115
IF True THEN RST M94M95114
IF True THEN RST M94M95112
IF True THEN RST M94M95126
IF True THEN SET StandardSpindleStage, RST G540SpindleStage
; #endregion

;Do gather if commanded (uncomment and recompile for debugging purposes)
;IF Aux11Key || ((SV_MPU11_ABS_POS_2 < SV_MACHINE_PARAMETER_45) && (SV_MACHINE_PARAMETER_45 < -1000)) THEN (Aux11PD)
;IF Aux11PD  THEN (SV_TRIGGER_PLOT_DUMP), SET SV_STOP
IF PLOT_SV || (SV_MACHINE_PARAMETER_820 == 3 && (TorchBreakawayFault_M || TorchArcLost_T)) THEN (PLOT_PD)
IF Aux11Key || SkinDebugTest_M || PLOT_PD THEN (SV_TRIGGER_PLOT_DUMP)
IF PLOT_SV THEN RST PLOT_SV
;Parm 962 = disable alt-j jog panel, (use usb jog device) 0=disable, 1 enable,
;2 = use shuttle
IF OnAtPowerUp_M && SV_MACHINE_PARAMETER_962 > 0 THEN SET TempJPActive_M
IF True THEN UsbJog_W = SV_MACHINE_PARAMETER_962
IF True THEN BITTST UsbJog_W 0 XkeysUsb_M
IF True THEN BITTST UsbJog_W 1 ShuttleExpressUsb_M

IF ShuttleExpressUsb_M && SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN SET ShuttleStage
IF SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN RST TempJPActive_M
IF !ShuttleExpressUsb_M || !SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN RST ShuttleStage
IF (Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_9 || Kb_10_Key_9) && AllowKbInput_M
  THEN (ShuttleAxisSelectKey)

IF (((Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_1 || Kb_2 || Kb_3 || Kb_4 || Kb_5 || Kb_6 || Kb_7)) ||
   ((Kb_L_Alt || Kb_R_Alt) && (Kb_q || Kb_w || Kb_e || Kb_r || Kb_y || Kb_u || Kb_o)) ||
   ((Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_z || Kb_Del || Kb_9)) || (Kb_PgDown || Kb_PgUp)) &&
   !SV_PC_VIRTUAL_JOGPANEL_ACTIVE
   THEN InfoMsg_W = PRESS_ALT_J_TO_ENABLE_USB_JOGGING, (ShuttleDisabled)

;IF !SV_PROGRAM_RUNNING THEN RST DisableAxis1Limit, RST DisableAxis2Limit, RST DisableAxis3Limit, RST DisableAxis4Limit

IF (SV_MACHINE_PARAMETER_964 == 0 &&
   SV_MACHINE_PARAMETER_965 == 0 &&
   SV_MACHINE_PARAMETER_966 == 0 &&
   SV_MACHINE_PARAMETER_967 != 0) THEN (PairedAxesLED)
;Call out stage to home the turret
IF M18 && SV_MACHINE_PARAMETER_820 == 1 THEN SET HomeTurretStage
IF !M18 && SV_MACHINE_PARAMETER_820 == 1 THEN RST HomeTurretStage, RST TurretHomed_M
   
;Reset everything once tool change is complete
IF ToolChangeComplete_M && SV_MACHINE_PARAMETER_820 == 1
							THEN RST TurretIndex_M, 
							 RST ReverseToolTurret,
							 RST ToolChangeTimeOutTimer,
							 RST ToolTurretOffCurrentToolTimer,
							 RST TurretReverseTimer,
							 RST ToolChangeComplete_M,
							 RST RotateTurretStage,
							 RST RotateTurretStage2,
							 RST RotateTurretStage3
							 
;Reset everything if SV_STOP or E-stop
IF (SV_STOP || !EStopOk) && SV_MACHINE_PARAMETER_820 == 1
						THEN RST HomeTurretStage,
							RST RotateTurretStage,
							RST RotateTurretStage2,
							RST RotateTurretStage3,
							RST TurretIndex_M,
							RST ToolChangeComplete_M,
							RST RotateToolTurret,
							RST ToolTurretEnable,
							RST ReverseToolTurret,
							RST TurretReverseTimer,
							RST ToolTurretOffCurrentToolTimer,
							RST ToolChangeTimeOutTimer

;------------------------------------------------------------------------------
;                            ETHER1616 ALIVE Section
;------------------------------------------------------------------------------
IF Initialize_T THEN ETHER1616_ALIVE_W = SV_ETHER1616_ONLINE_BITS
IF Initialize_T THEN P415Value_W = SV_MACHINE_PARAMETER_415

;IF Initialize_T && (ETHER1616_ALIVE_W != P415Value_W)
; THEN FaultMsg_W = ETH1616_CONFIGFAULT_MSG, SET OtherFault_M

IF TRUE THEN BITTST ETHER1616_ALIVE_W 0 ETHER1616_1_ONLINE_M
IF TRUE THEN BITTST ETHER1616_ALIVE_W 1 ETHER1616_2_ONLINE_M
IF TRUE THEN BITTST ETHER1616_ALIVE_W 2 ETHER1616_3_ONLINE_M
IF TRUE THEN BITTST ETHER1616_ALIVE_W 3 ETHER1616_4_ONLINE_M
IF TRUE THEN BITTST ETHER1616_ALIVE_W 4 ETHER1616_5_ONLINE_M

IF P415Value_W == 1 && !ETHER1616_1_ONLINE_M THEN FaultMsg_W = ETH1616_FAULT_MSG, SET OtherFault_M
IF P415Value_W == 3 && !(ETHER1616_1_ONLINE_M && ETHER1616_2_ONLINE_M) THEN FaultMsg_W = ETH1616_FAULT_MSG, SET OtherFault_M
IF P415Value_W == 7 && !(ETHER1616_1_ONLINE_M && ETHER1616_2_ONLINE_M && ETHER1616_3_ONLINE_M)
  THEN FaultMsg_W = ETH1616_FAULT_MSG, SET OtherFault_M
IF P415Value_W == 15 && !(ETHER1616_1_ONLINE_M && ETHER1616_2_ONLINE_M && ETHER1616_3_ONLINE_M && ETHER1616_4_ONLINE_M)
  THEN FaultMsg_W = ETH1616_FAULT_MSG, SET OtherFault_M
IF P415Value_W == 15 && !(ETHER1616_1_ONLINE_M && ETHER1616_2_ONLINE_M && ETHER1616_3_ONLINE_M && ETHER1616_4_ONLINE_M)
  THEN FaultMsg_W = ETH1616_FAULT_MSG, SET OtherFault_M
IF P415Value_W == 31 && !(ETHER1616_1_ONLINE_M && ETHER1616_2_ONLINE_M && ETHER1616_3_ONLINE_M && ETHER1616_4_ONLINE_M && ETHER1616_5_ONLINE_M)
  THEN FaultMsg_W = ETH1616_FAULT_MSG, SET OtherFault_M
;------------------------------------------------------------------------------
;                            USB Mpg Section
;------------------------------------------------------------------------------
;Word to bit for usb mpg operation
IF True THEN WTB SV_USB_MPG_BUTTON_STATE MpgResetKey_M 14
IF (SV_USB_MPG_SCALE_SELECT == 1000) THEN SET MpgSpinWheelSelect_M
IF (SV_USB_MPG_SCALE_SELECT != 1000) THEN RST MpgSpinWheelSelect_M
IF (SV_USB_MPG_SCALE_SELECT == 10000) THEN SET MpgFeedWheelSelect_M
IF (SV_USB_MPG_SCALE_SELECT != 10000) THEN RST MpgFeedWheelSelect_M

;Handle jog keys for MPGKey
;Reset all keys first
IF !((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgJogPlus_M) THEN RST MpgAxis1JogPlus_M
IF !((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgJogMinus_M) THEN RST MpgAxis1JogMinus_M
IF !((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgJogPlus_M) THEN RST MpgAxis2JogPlus_M
IF !((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgJogMinus_M) THEN RST MpgAxis2JogMinus_M
IF !((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgJogPlus_M) THEN RST MpgAxis3JogPlus_M
IF !((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgJogMinus_M) THEN RST MpgAxis3JogMinus_M
IF !((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgJogPlus_M) THEN RST MpgAxis4JogPlus_M
IF !((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgJogMinus_M) THEN RST MpgAxis4JogMinus_M

;Set Appropriate key
IF ((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgJogPlus_M) THEN SET MpgAxis1JogPlus_M
IF ((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgJogMinus_M) THEN SET MpgAxis1JogMinus_M
IF ((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgJogPlus_M) THEN SET MpgAxis2JogPlus_M
IF ((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgJogMinus_M) THEN SET MpgAxis2JogMinus_M
IF ((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgJogPlus_M) THEN SET MpgAxis3JogPlus_M
IF ((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgJogMinus_M) THEN SET MpgAxis3JogMinus_M
IF ((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgJogPlus_M) THEN SET MpgAxis4JogPlus_M
IF ((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgJogMinus_M) THEN SET MpgAxis4JogMinus_M

;MPG Macro Keys
;By setting SV_SYS_MACRO to a value of something other than zero, the PLC is 
;requesting CNC12 to run the corresponding macro in the c:\cncm\system directory
;Setting SV_SYS_MACRO = 1, run c:\cncm\system\MPGmacro1.mac. Cnc12 will not run the
;same macro twice in a row unless SV_SYS_MACRO has been set to 0 between requests.
IF (MpgMacro1_M && !PlasmaWMPG_M) || (MpgSpinAutoMan_M && PlasmaWMPG_M) THEN SV_SYS_MACRO = 1
IF (MpgMacro2_M && !PlasmaWMPG_M) || (MpgMacro1_M && PlasmaWMPG_M) THEN SV_SYS_MACRO = 2
IF (MpgMacro3_M && !PlasmaWMPG_M) THEN SV_SYS_MACRO = 3
IF (MpgMacro4_M && !PlasmaWMPG_M) THEN SV_SYS_MACRO = 4

IF !(MpgMacro1_M || MpgMacro2_M || MpgMacro3_M || MpgMacro4_M) THEN SET NoMacroKeyPressedTimer

IF NoMacroKeyPressedTimer THEN SV_SYS_MACRO = 0, RST NoMacroKeyPressedTimer

;------------------------------------------------------------------------------
;                            Skinning Section
;------------------------------------------------------------------------------
;IF TRUE THEN Skinning_W1 = SV_SKINNING_DATA_W_1, Skinning_W12 = SV_SKINNING_DATA_W_12,
;Skinning_FW8 = SV_SKINNING_DATA_FW_1, Skinning_DFW8 = SV_SKINNING_DATA_DFW_1

;Set up skinning framework
IF TRUE THEN SkinFeedOverride_W1 = SV_SKINNING_DATA_W_1

IF True THEN SkinningInt12_W = SV_SKINNING_DATA_W_12

;Tell Virtual Jog Panel Cnc software and PLC are alive
IF SV_PC_SOFTWARE_READY THEN (CncAndPlcActive_M)

;The following code uses SV_SKINNING_DATA_W_12 to SET and RST MEM and OUT bits
;using SetMemBit(), RstMemBit() and SetOutput(), RstOutput()
;Care should be taken to  RST MEM and OUT bits on SV_STOP when appropriate.
;Grouped I/O can be SET/RST as follows:
;IF SV_STOP THEN RST OUT40..OUT50
;Resets (turns off) OUT40 through OUT50

;IF TRUE THEN SkinningInt12_W = SV_SKINNING_DATA_W_12

;If bit 12 is set, skinning is requesting a membit to be set
;If bit 13 is set, skinning is requesting a membit to be reset
;If bit 14 is set, skinning is requesting a output to be set
;If bit 15 is set, skinning is requesting a output to be reset

;IF TRUE THEN BITTST SkinningInt12_W 12 SetMem_M
;IF TRUE THEN BITTST SkinningInt12_W 13 RstMem_M
;IF TRUE THEN BITTST SkinningInt12_W 14 SetOut_M
;IF TRUE THEN BITTST SkinningInt12_W 15 RstOut_M

;IF SetMem_M THEN Mem_W = SkinningInt12_W - 4096, SET MEM[Mem_W]
;IF RstMem_M THEN Mem_W = SkinningInt12_W - 8192, RST MEM[Mem_W]
;IF SetOut_M THEN Out_W = SkinningInt12_W - 16384, SET OUT[Out_W]
;IF RstOut_M THEN Out_W = SkinningInt12_W - 32768, RST OUT[Out_W]

;IF True THEN SkinningInt12_W = 0, RST SetMem_M, RST RstMem_M,
;             RST SetOut_M, RST RstOut_M, Mem_W = 0, Out_W = 0

IF True THEN KeepAliveTimer = 1000
IF SV_PC_SOFTWARE_READY && (KeepAliveTimer < 1) THEN SET KeepAliveTimer
IF KeepAliveTimer > 500 THEN (KeepAlive_M)
IF KeepAliveTimer THEN RST KeepAliveTimer

If SkinResetButtonPressed_M && (EstopOK) THEN (ResetPD)
IF (ResetPD && SkinResetSet_M) THEN (ResetSetPD)
IF (ResetPD && !SkinResetSet_M) THEN (ResetResetPD)
;IF (!EstopOK && SkinResetSet_M) THEN (SkinResetSet_M), SET SkinResetOk_M

IF ResetSetPD THEN RST SkinResetSet_M, SET SkinResetOk_M
IF ResetResetPD || OnAtPowerUp_M  THEN SET SkinResetSet_M, RST SkinResetOk_M

;IF !SkinResetOk_M THEN SET SkinResetSet_M
IF SkinResetOk_M THEN (SkinResetOkPD)

IF SV_STOP && (!EstopOK || SkinResetOkPD) THEN RST SkinResetSet_M,
                                               SET SkinResetOk_M

IF SkinResetSet_M THEN (ResetOutput)

;Handle Forced E-Stop Homing
;For Jog to Home Users, Need to Disable Travel Limits.
;If Machine was already homed and EStop is Pressed and Forced E-Stop Homing Enabled,
; then disable Travel Limits
IF SV_PC_HOME_SET && SV_MACHINE_PARAMETER_425 == 1 && !EStopOk THEN SET SV_PLC_DISABLE_TRAVEL_LIMITS

;Wait for Operator to Press CycleStart and start homing sequence, Enable Software Limits
IF SV_PLC_DISABLE_TRAVEL_LIMITS && SV_JOB_IN_PROGRESS THEN RST SV_PLC_DISABLE_TRAVEL_LIMITS

;------------------------------------------------------------------------------
;End Skinning section
;------------------------------------------------------------------------------
;Paired Axes Homing
IF !HomeAll || !SlavedHomeInput || !FirstAxisHomeOk || !FirstAxisHomeLimitOk ||
  !SecondAxisHomeOk || !SecondAxisHomeLimitOk THEN (PairedHomeTripped)

;Probe and Tool Touch Off tripped together logic
IF ((ProbeTripped && ProbeDetect && ProbeNO_M) || (ProbeTripped && !ProbeNO_M)
    || (ToolTouchOffTriggered && ToolTouchOffDetect && TTNO_M)
	|| (ToolTouchOffTriggered && !TTNO_M))
  THEN (ProbeToolTripped)

;Limits/Home switches
IF SV_LIMIT_TRIPPED THEN (LimitTripped_M)

;---------------------------Spindle Brake Release------------------------------
IF SpindleBrakeDisabled_M THEN SpindleBrakeTimer = 0
IF !SpindleBrakeDisabled_M && SV_MACHINE_PARAMETER_990 == 0 THEN SpindleBrakeTimer = 250
IF !SpindleBrakeDisabled_M && SV_MACHINE_PARAMETER_990 > 0 THEN SpindleBrakeTimer = SV_MACHINE_PARAMETER_990

; Toggle brake mode on and off
IF SkinSpindleBrake_M && !SpindleBrakeDisabled_M THEN (SpindleBrakePD)
IF SpindleBrakePD && !SpindleBrakeLED THEN SET SpinBrakeOff_M, RST SpinBrakeOn_M
IF SpindleBrakePD && SpindleBrakeLED THEN RST SpinBrakeOff_M, SET SpinBrakeOn_M

; Set SpindleBrakeTimer if spindle is commanded to turn on.
; If SpindleBrake is disabled, SpindleBrakeTimer will = 0 and spindle will turn on right away.
IF ((StandardSpindleStage && SpindleEnableOut_M) ||
   (G540SpindleStage && (SpindleForward_M || SpindleReverse_M)))
  THEN SET SpindleBrakeTimer

; Reset SpindleBrakeTimer if Spindle is not running
IF ((StandardSpindleStage && !SpindleEnableOut_M) ||
   (G540SpindleStage && (!SpindleForward_M && !SpindleReverse_M)))
   THEN RST SpindleBrakeTimer

; Turn on SpindleBrakeRelease if SpindleBrake is enabled and when spindle is
; requested to turn on OR the SpinBrakeMode_M is off.
IF !SpindleBrakeDisabled_M &&
   ((StandardSpindleStage && SpindleEnableOut_M) ||
   (G540SpindleStage && (SpindleForward_M || SpindleReverse_M)) ||
   SpinBrakeOn_M)
  THEN SET SpindleBrakeRelease

; Turn off SpindleBrakeRelease if SpindleBrake is enabled and SpinBrakeMode_M is on
; and Spindle is not running
IF !SpindleBrakeDisabled_M &&
   ((StandardSpindleStage && !SpindleEnableOut_M && !SpinBrakeOn_M) ||
   (G540SpindleStage && (!SpindleForward_M && !SpindleReverse_M) && !SpinBrakeOn_M) ||
   (SpinBrakeOff_M && !((StandardSpindleStage && SpindleEnableOut_M) ||
   (G540SpindleStage && (SpindleForward_M || SpindleReverse_M)))))
  THEN RST SpindleBrakeRelease

IF !SpindleBrakeRelease THEN (SpindleBrakeLED)

;---------------------------End Spindle Brake Release------------------------------

;-----------------------------------OrientSpindle----------------------------------
;Set timer for 5 seconds
IF True THEN OrientTimer = 5000

;Set memory bit based on input state
IF SpindleIsOriented THEN (SpindleOrientedState_M)

;Turn on output and set timer
IF M19 THEN (OrientSpindle), SET OrientTimer

;Turn off timer once spindle is oriented
IF OrientSpindle && SpindleOrientedState_M THEN RST OrientTimer

;Turn everything off if in E-stop or program isn't running
IF !EstopOK || !SV_PROGRAM_RUNNING THEN RST M19, RST OrientTimer

;Throw fault if spindle isn't oriented within allotted time
IF OrientSpindle && (OrientTimer && !SpindleOrientedState_M)
  THEN FaultMsg_W = ORIENT_TIMEOUT,
       SET OtherFault_M,
	   RST OrientTimer,
	   RST OrientSpindle,
	   RST M19
;-----------------------------------End OrientSpindle------------------------------

;-----------------------------------DrawBar----------------------------------------
;Display Message if Drawbar is Released/Clamped
IF DrawBarReleased && !DrawBarReleasedDisable_M && !ToolUnclampedState_M THEN InfoMsg_W = DRAWBAR_RELEASED_MSG

IF !DrawBarReleased && !DrawBarReleasedDisable_M && ToolUnclampedState_M THEN InfoMsg_W = DRAWBAR_CLAMPED_MSG

;----------------------------------End DrawBar-------------------------------------

;-----------------------------------UnclampTool------------------------------------
;Set timer for 5 seconds
IF True THEN ToolUnclampTimer = 5000

;Set memory bit based on input state
IF (ToolIsUnclamped && DrawBarReleasedDisable_M) || (DrawBarReleased && ToolIsUnclampedDisable_M)
	THEN (ToolUnclampedState_M)

;Turn on output and set timer
IF VFDZeroSpeed && (((ToolUnclampButton || SkinToolRelease_M) && !SpindleEnableOut_M) || 
 M15 && SV_PROGRAM_RUNNING) THEN (UnclampTool), SET ToolUnclampTimer

;Turn on ATCAirBlowActivate
IF UnClampTool THEN (ATCAirBlowActivate)

;Turn off timer once tool is unclamped
IF UnclampTool && ToolUnclampedState_M || !M15 THEN RST ToolUnclampTimer

;Turn everything off if in E-stop or program isn't running
IF !EstopOK || !SV_PROGRAM_RUNNING THEN RST M15, RST ToolUnclampTimer

;Throw fault if tool isn't unclamped within allotted time
IF UnclampTool && (ToolUnclampTimer && !ToolUnclampedState_M)
  THEN FaultMsg_W = TOOL_UNCLAMP_TIMEOUT,
       SET OtherFault_M,
	   RST ToolUnclampTimer,
	   RST UnclampTool,
	   RST M15
;-----------------------------------End UnclampTool------------------------------

;No Fault Out
IF !SV_STOP THEN (NoFaultOut)

;Drive Reset
IF !EStopOk THEN (DriveResetOut)

;Spindle Reset
IF !EstopOK THEN (VFDResetOut_O)

;--Worklight
IF SkinWorklight_M THEN (WorklightPD)
IF (WorklightPD ^ WorklightLED) || (OnAtPowerUp_M && !WorkLightDisabled_M) THEN (WorklightLED)
IF WorklightLED THEN (WorkLight)

;--DryRun
IF (DryRun_M || (MpgFeedHold_M && PlasmaWMPG_M)) && !SV_PROGRAM_RUNNING THEN (DryRunPD)
IF (DryRunPD ^ DryRunLED) THEN (DryRunLED)

;--TurnClampOn
IF SkinClampOn_M THEN (ClampOnPD)
IF ((ClampOnPD ^ TurnClampOn) && !SV_PROGRAM_RUNNING) || (M10M && SV_PROGRAM_RUNNING)
	THEN (TurnClampOn)
IF TurnClampOn THEN (ClampOnLED)

;VacuumOn
IF (VacOnKey || SkinVacOn_M) THEN (VacOnPD)
IF ((VacuumOn ^ (!CoolAutoModeLED && VacOnPD)) || CoolAutoModeLED && M27) &&
	!(CoolAutoModeLED && !M27) THEN (VacuumOn), (VacOnLED)

;IF VacOnKey || SkinVacOn_M THEN (VacOnPD)
;IF (VacOnPD && !VacuumOn) || M27 THEN SET VacuumOn, SET VacOnLED
;IF (VacOnPD && VacuumOn) || !M27 THEN RST VacuumOn, RST VacOnLED

;DustCollectionOn
IF !SV_PROGRAM_RUNNING THEN (StopRunningPD)
IF StopRunningPD THEN RST DustCollectionOn
IF SkinDustCollection_M THEN (DustCollectionPD)

IF (DustCollectionPD && !DustCollectionOn && !SV_PROGRAM_RUNNING) ||
	(M35 && SV_PROGRAM_RUNNING) THEN SET DustCollectionOn
IF (DustCollectionPD && DustCollectionOn && !SV_PROGRAM_RUNNING) ||
	(!M35 && SV_PROGRAM_RUNNING) THEN RST DustCollectionOn
IF DustCollectionOn THEN (DustCollectionLED)

;DustFootActivate
IF SkinDustFoot_M THEN (DustFootPD)
IF DustFootPD && SV_PROGRAM_RUNNING THEN SET DustFootVCP_M, RST DustFootActivate_SV
IF !SV_PROGRAM_RUNNING || DustFootActivate_SV THEN RST DustFootVCP_M

IF (DustFootPD && !DustFootActivate && !DustFootActivate_SV) ||
	(DustFootActivate_SV && SV_PROGRAM_RUNNING && !DustFootVCP_M) THEN SET DustFootActivate
IF (DustFootPD && DustFootActivate && !DustFootActivate_SV) ||
	(!DustFootActivate_SV && SV_PROGRAM_RUNNING && !DustFootVCP_M) THEN RST DustFootActivate
IF DustFootActivate THEN (DustFootLED)

;LaserAlignActivate
IF SkinLaserAlign_M THEN (LaserAlignPD)
IF LaserAlignPD && !LaserAlignActivate THEN SET LaserAlignActivate_SV
IF LaserAlignPD && LaserAlignActivate THEN RST LaserAlignActivate_SV

IF LaserAlignActivate_SV THEN (LaserAlignActivate)

IF LaserAlignActivate THEN (LaserAlignLED)

;PopUpPins
IF SkinPopUpPins_M THEN (PopUpPinsPD)
IF (PopUpPinsPD || (DoCycleStart && PopUpPinsCycleStart_M)) && !SV_PROGRAM_RUNNING THEN RST PopUpPins_SV
IF (((PopUpPinsPD ^ PopUpPins) && !SV_PROGRAM_RUNNING) ||
	PopUpPins_SV) ^ (DoCycleStart && PopUpPins && PopUpPinsCycleStart_M) THEN (PopUpPins)
IF PopUpPins THEN (PopUpPinsLED)

;SpindleCooling
IF SkinSpindleCooling_M THEN (SpindleCoolingPD)
IF SpindleCoolingPD THEN RST SpindleCooling_SV
IF ((SpindleCoolingPD ^ SpindleCooling) && !SV_PROGRAM_RUNNING) ||
	SpindleCooling_SV THEN (SpindleCooling)
IF SpindleCooling THEN (SpindleCoolingLED)

;AirBlowNozzle
IF SkinAirBlowNozzle_M THEN (AirBlowNozzlePD)
IF (AirBlowNozzlePD ^ AirBlowNozzle) THEN (AirBlowNozzle)
IF AirBlowNozzle THEN (AirBlowNozzleLED)

;SpindleCooling_Fan
;Turn SpindleCooling_Fan on anytime Spindle is Enabled
IF True THEN SpindleCooling_T = SV_MACHINE_PARAMETER_997 * 1000
IF SpindleEnableOut_M THEN SET SpindleCooling_Fan, RST SpindleCooling_T
IF !SpindleEnableOut_M THEN SET SpindleCooling_T
IF SpindleCooling_T THEN RST SpindleCooling_Fan

;VFDZeroSpeed
IF VFDZeroSpeed THEN (SpindleZeroSpeedState_M)

;CAxisEnable
IF M51_SV THEN (CAxisEnable)

;------------------------------------Chuck-------------------------------------
; ChuckState_M Designates whether Chuck should be Open or Closed
; ChuckState_M (GRN) = Chuck Opened
; ChuckState_M (RED) = Chuck Closed
IF TRUE THEN ChuckTimer = SV_MACHINE_PARAMETER_992

IF ChuckFootPedal_I && !SpindleEnableOut_M THEN (ChuckFootPedal_PD)
;IF (ChuckFootPedal_PD ^ ChuckState_M) THEN (ChuckState_M)

;Open Chuck
IF SkinOpenChuck_M || (ChuckFootPedal_PD && !ChuckState_M) THEN (OpenChuckPD)
IF ((OpenChuckPD && !OpenChuck) || (M11L && SV_PROGRAM_RUNNING)) && ColletDisabled_M
	&& !SpindleEnableOut_M && ChuckOpenCloseComplete_M THEN RST CloseChuck, SET OpenChuck, SET ChuckTimer,
	RST ChuckOpenCloseComplete_M

;Close Chuck
IF SkinCloseChuck_M || (ChuckFootPedal_PD && ChuckState_M) THEN (CloseChuckPD)
IF ((CloseChuckPD && !CloseChuck) || (M10L && SV_PROGRAM_RUNNING)) && ColletDisabled_M
	&& !SpindleEnableOut_M && ChuckOpenCloseComplete_M THEN SET CloseChuck, RST OpenChuck, SET ChuckTimer,
	RST ChuckOpenCloseComplete_M

;Reset if Activated while Open/Closing
;IF (OpenChuckPD && OpenChuck) || (!M11L && SV_PROGRAM_RUNNING)
;	THEN RST OpenChuck, SET ChuckState_M
;IF (CloseChuckPD && CloseChuck) || (!M10L && SV_PROGRAM_RUNNING)
;	THEN RST CloseChuck, RST ChuckState_M
;IF (OpenChuckPD && OpenChuck) || (CloseChuckPD && CloseChuck)
;	THEN RST ChuckTimer

;Reset By Timer or Input
IF OpenChuck && !ChuckOpenCloseComplete_M && (ChuckIsOpen || (ChuckIsOpenIs_M && ChuckTimer))
  THEN SET ChuckOpenCloseComplete_M, RST OpenChuck, RST M11L, SET ChuckState_M
IF CloseChuck && !ChuckOpenCloseComplete_M && (ChuckIsClosed || (ChuckIsClosedIs_M && ChuckTimer))
  THEN SET ChuckOpenCloseComplete_M, RST CloseChuck, RST M10L, RST ChuckState_M
  
;OpenFault
IF OpenChuck && !ChuckOpenCloseComplete_M && (ChuckTimer && !ChuckIsOpenIs_M)
  THEN FaultMsg_W = CHUCK_TIMEOUT, Set OtherFault_M, RST ChuckTimer, RST OpenChuck, RST M11L

;CloseFault
IF CloseChuck && !ChuckOpenCloseComplete_M && (ChuckTimer && !ChuckIsClosedIs_M)
  THEN FaultMsg_W = CHUCK_TIMEOUT, Set OtherFault_M, RST ChuckTimer, RST CloseChuck, RST M10L

;Clear chuck bits
IF OnAtPowerUp_M THEN SET ChuckOpenCloseComplete_M
IF ChuckOpenCloseComplete_M THEN RST ChuckTimer

;IF (!M10L && !M11L && SV_PROGRAM_RUNNING) THEN RST OpenChuck, RST CloseChuck,
;											    RST ChuckOpenCloseComplete_M,
;                                               RST ChuckTimer


;-----------------------------------End Chuck----------------------------------

;------------------------------------Collet-------------------------------------
IF (SkinColletOpenClose_M || ChuckFootPedal_I) && !SpindleEnableOut_M THEN (ColletOpenClosePD)

IF ((ColletOpenClosePD && !ColletOpenClose) || (M11L && SV_PROGRAM_RUNNING)) && !SpindleEnableOut_M THEN SET ColletOpenClose
IF ((ColletOpenClosePD && ColletOpenClose) || (M10L && SV_PROGRAM_RUNNING)) && !SpindleEnableOut_M THEN RST ColletOpenClose
IF ColletOpenClose THEN (ColletOpenCloseLED)

;-----------------------------------End Collet----------------------------------

;-----------------------------------PartChute----------------------------------
IF TRUE THEN SpindleLockTimer = SV_MACHINE_PARAMETER_994
IF M22 THEN SET PartChute, SET PartchuteTimer
IF PartChuteIsIn || (PartChuteIsInIs_M && PartChuteTimer)
  THEN SET PartChuteComplete

IF !M22 THEN RST PartChute, RST PartchuteTimer, RST PartChuteComplete

;Fault
IF PartchuteTimer && !PartChuteIsInIs_M
  THEN FaultMsg_W = PART_CHUTE_TIMEOUT, SET OtherFault_M, RST PartChute, RST PartchuteTimer
;-----------------------------------End PartChute------------------------------

;-----------------------------------LightStack---------------------------------
;Blink Lights, On 5 Seconds, Off 1 Second
IF True THEN SET LightTurnOnTimer
IF LightTurnOnTimer THEN SET LightTurnOffTimer
IF LightTurnOffTimer THEN RST LightTurnOnTimer, RST LightTurnOffTimer

;Set Lights on Machine Status
IF SV_JOB_IN_PROGRESS && (LightTurnOnTimer || (SV_MACHINE_PARAMETER_890 == 1)) THEN (GreenLight) ; If job running normally then greenlight on
IF !SV_JOB_IN_PROGRESS && !SV_STOP && (LightTurnOnTimer || (SV_MACHINE_PARAMETER_890 == 1))  THEN (Amberlight) ; If not in job and not in fault then yellow light on
IF SV_STOP && (LightTurnOnTimer || (SV_MACHINE_PARAMETER_890 == 1)) THEN (RedLight) ; if in fault then red light on
;---------------------------------End LightStack-------------------------------

;LockSpindle 93
;IF TRUE THEN SpindleLockTimer = SV_MACHINE_PARAMETER_993
;IF M19 THEN SET LockSpindle, SET SpindleLockTimer
;IF SpindleIsLocked || (SpindleIsLockedIs_M && SpindleLockTimer)
;  THEN SET SpindleLockComplete
;
;IF !M19 THEN RST LockSpindle, RST SpindleLockTimer, RST SpindleLockComplete
;
;;Fault
;IF SpindleLockTimer && !SpindleIsLockedIs_M
;  THEN FaultMsg_W = SPINDLE_LOCK_TIMEOUT, SET OtherFault_M, RST SpindleLockTimer

;Cutoff 95
IF TRUE THEN CutOffTimer = SV_MACHINE_PARAMETER_995

IF M13 THEN SET CutOff, SET CutOffTimer

IF CutOffIsDown || (CutOffIsDownIs_M && CutOffTimer)
  THEN SET CutOffComplete

IF !M13 THEN RST CutOff, RST CutOffTimer, RST CutOffComplete

;Fault
IF CutOffTimer && !CutOffIsDownIs_M
  THEN FaultMsg_W = CUT_OFF_TIMEOUT, SET OtherFault_M, RST CutOff, RST CutOffTimer

;Laser
IF SV_STOP || !(SV_PROGRAM_RUNNING || SV_MDI_MODE) THEN RST M37, RST PWMSelect_SV, RST LaserReset_SV
IF M37 && !SV_STOP THEN (LaserEnable)
IF PWMSelect_SV && !SV_STOP THEN (PWMSelect)
IF LaserReset_SV && !SV_STOP THEN (LaserReset)

;OUTPUT1-8
IF M61 THEN (OUTPUT1)
IF M62 THEN (OUTPUT2)
IF M63 THEN (OUTPUT3)
IF M64 THEN (OUTPUT4)
IF M65 THEN (OUTPUT5)
IF M66 THEN (OUTPUT6)
IF M67 THEN (OUTPUT7)
IF M68 THEN (OUTPUT8)

;ETH1616 OUTPUTS 1-16
IF M94M95111_SV THEN (M94M95111)
IF M94M95112_SV THEN (M94M95112)
IF M94M95113_SV THEN (M94M95113)
IF M94M95114_SV THEN (M94M95114)
IF M94M95115_SV THEN (M94M95115)
IF M94M95116_SV THEN (M94M95116)
IF M94M95117_SV THEN (M94M95117)
IF M94M95118_SV THEN (M94M95118)
IF M94M95119_SV THEN (M94M95119)
IF M94M95120_SV THEN (M94M95120)
IF M94M95121_SV THEN (M94M95121)
IF M94M95122_SV THEN (M94M95122)
IF M94M95123_SV THEN (M94M95123)
IF M94M95124_SV THEN (M94M95124)
IF M94M95125_SV THEN (M94M95125)
IF M94M95126_SV THEN (M94M95126)

;------------------------------------------------------------------------------
;           Probe protection while jogging
;------------------------------------------------------------------------------
; If the probe comes to be tripped while a jogging move is active,
; then trigger an error (stop jog and output message),
; and also disable jogging in the direction it was going.
IF (Ax1PlusJogKey  || KbJogAx1Plus_M || SkinJogax1Plus_M || MpgAxis1JogPlus_M) ||
   (Ax1MinusJogKey  || KbJogAx1Minus_M || SkinJogax1Minus_M || MpgAxis1JogMinus_M) ||
   (Ax2PlusJogKey  || KbJogAx2Plus_M || SkinJogax2Plus_M || MpgAxis2JogPlus_M) ||
   (Ax2MinusJogKey  || KbJogAx2Minus_M || SkinJogax2Minus_M || MpgAxis2JogMinus_M) ||
   (Ax3PlusJogKey  || KbJogAx3Plus_M || SkinJogax3Plus_M || MpgAxis3JogPlus_M) ||
   (Ax3MinusJogKey  || KbJogAx3Minus_M || SkinJogax3Minus_M || MpgAxis3JogMinus_M) ||
   (Ax4PlusJogKey  || KbJogAx4Plus_M || SkinJogax4Plus_M || MpgAxis4JogPlus_M) ||
   (Ax4MinusJogKey  || KbJogAx4Minus_M || SkinJogax4Minus_M || MpgAxis4JogMinus_M) ||
   (SkinJogAx1Ax2Plus_M || SkinJogAx1Ax2Minus_M || SkinJogAx1PlusAx2Minus_M || SkinJogAx1MinusAx2Plus_M)
THEN (JogKeyPressed_M)

IF (Ax1PlusJogDisabled_M || Ax1MinusJogDisabled_M || Ax2PlusJogDisabled_M ||
	Ax2MinusJogDisabled_M || Ax3MinusJogDisabled_M) THEN (JoggingDisabled_M)

;Set Mem bit for if Probe or Tool was tripped for messages
IF ProbeProtectionEnable_M && ProbeToolTripped && ((ToolTouchOffTriggered && ToolTouchOffDetect && TTNO_M) ||
	(ToolTouchOffTriggered && !TTNO_M)) THEN SET ToolTouchTripped_M
IF ProbeProtectionEnable_M && ProbeToolTripped && ((ProbeTripped && ProbeDetect && ProbeNO_M) ||
	(ProbeTripped && !ProbeNO_M)) THEN SET ProbeTripped_M

;Info Message if Jogging with USB Handwheel and Probe or TTO Tripped
IF (UsbMpgWheelJoggingEnabled_M && UsbWheelDelta != 0 && ProbeProtectionEnable_M && ProbeToolTripped && (usbscalemonitor_W == 10 || usbscalemonitor_W == 100))
THEN SET UsbProbeTripped_M

IF UsbProbeTripped_M && ToolTouchTripped_M THEN InfoMsg_W = HANDWHEEL_TTO_TRIPPED_MSG
IF UsbProbeTripped_M && ProbeTripped_M THEN InfoMsg_W = HANDWHEEL_PROBE_TRIPPED_MSG

;Probe Protection while Jogging
IF ProbeProtectionEnable_M && ProbeToolTripped && JogKeyPressed_M && !ProbeTrippedDisarm_M THEN SET JogWithProbeTrippedArmed_M
IF ProbeProtectionEnable_M && ProbeToolTripped && !JogKeyPressed_M && !JogWithProbeTrippedArmed_M && !SV_PROGRAM_RUNNING && !JogWithHandwheelTripped_M
	THEN SET ProbeTrippedDisarm_M

;Activate probe protection if tripped while jogging, only allowing opposite direction
IF JogWithProbeTrippedArmed_M && DoAx1PlusJog  && !Ax1MinusJogDisabled_M && !ProbeTrippedDisarm_M || BreakAwayAllowZ_M THEN SET Ax1PlusJogDisabled_M
IF JogWithProbeTrippedArmed_M && DoAx1MinusJog && !Ax1PlusJogDisabled_M && !ProbeTrippedDisarm_M || BreakAwayAllowZ_M THEN SET Ax1MinusJogDisabled_M
IF JogWithProbeTrippedArmed_M && DoAx2PlusJog  && !Ax2MinusJogDisabled_M && !ProbeTrippedDisarm_M || BreakAwayAllowZ_M THEN SET Ax2PlusJogDisabled_M
IF JogWithProbeTrippedArmed_M && DoAx2MinusJog && !Ax2PlusJogDisabled_M && !ProbeTrippedDisarm_M || BreakAwayAllowZ_M THEN SET Ax2MinusJogDisabled_M
IF ProbeProtectionEnable_M && ProbeToolTripped || BreakAwayAllowZ_M THEN SET Ax3MinusJogDisabled_M

;Send TTO or Probe Tripped Message
IF ProbeTripTimer && ProbeTrippedDisarm_M && ToolTouchTripped_M && !UsbProbeTripped_M THEN ErrorMsg_W = POWERUP_TTO_TRIPPED_MSG
IF ProbeTripTimer && ProbeTrippedDisarm_M && ProbeTripped_M && !UsbProbeTripped_M THEN ErrorMsg_W = POWERUP_PROBE_TRIPPED_MSG

IF ProbeProtectionEnable_M && ProbeToolTripped && !JogProbeFault_M && (DoAx1PlusJog || DoAx1MinusJog ||
  DoAx2PlusJog || DoAx2MinusJog || DoAx3PlusJog || DoAx3MinusJog ||
  DoAx4PlusJog || DoAx4MinusJog || DoAx5PlusJog || DoAx5MinusJog)
  THEN (JogProbeFaultPD)

IF JogProbeFaultPD && ToolTouchTripped_M && !ProbeTrippedDisarm_M THEN SET JogProbeFault_M,
                        SET ErrorFlag_M,
                        ErrorMsg_W = TTO_JOG_TRIP_MSG
IF JogProbeFaultPD && ProbeTripped_M && !ProbeTrippedDisarm_M THEN SET JogProbeFault_M,
                        SET ErrorFlag_M,
                        ErrorMsg_W = PROBE_JOG_TRIP_MSG

If Initialize_T && ProbeToolTripped && ToolTouchTripped_M && (ProbeTripTimer > 20) && (ProbeTripTimer < 900)
   THEN SET ErrorFlag_M,
        ErrorMsg_W = POWERUP_TTO_TRIPPED_MSG
If Initialize_T && ProbeToolTripped && ProbeTripped_M && (ProbeTripTimer > 20) && (ProbeTripTimer < 900)
   THEN SET ErrorFlag_M,
        ErrorMsg_W = POWERUP_PROBE_TRIPPED_MSG

IF !ProbeToolTripped && !JogKeyPressed_M && !BreakAwayAllowZ_M
  THEN RST JogProbeFault_M,
       RST Ax1PlusJogDisabled_M,
       RST Ax1MinusJogDisabled_M,
       RST Ax2PlusJogDisabled_M,
       RST Ax2MinusJogDisabled_M,
       RST Ax3MinusJogDisabled_M

; If the probe comes to be tripped while no program cycle is running,
; then save the previous jog mode (fast/slow) and force slow mode.
IF ProbeProtectionEnable_M && ProbeToolTripped && !SV_PROGRAM_RUNNING && !JogModeSaved_M && Initialize_T
  THEN (SaveJogModePD),
       SET JogModeSaved_M
IF SaveJogModePD && FastSlowLED THEN SET LastProbeMode_M
IF SaveJogModePD && !FastSlowLED THEN RST LastProbeMode_M
IF ProbeProtectionEnable_M && ProbeToolTripped && !SV_PROGRAM_RUNNING THEN SET FastSlowLED

; Once the probe clears, restore the saved mode and reset
IF !(ProbeToolTripped) && JogModeSaved_M && !LastProbeMode_M
  THEN RST FastSlowLED,
       RST JogModeSaved_M

;Send TTO or Probe cleared message when cleared
IF !ProbeToolTripped && ToolTouchTripped_M && (JogWithProbeTrippedArmed_M || JogWithHandwheelTripped_M || ProbeTrippedDisarm_M) THEN InfoMsg_W = TTO_TRIP_CLEARED_MSG
IF !ProbeToolTripped && ProbeTripped_M && (JogWithProbeTrippedArmed_M || JogWithHandwheelTripped_M || ProbeTrippedDisarm_M) THEN InfoMsg_W = PROBE_TRIP_CLEARED_MSG
IF !ProbeToolTripped && !BreakAwayAllowZ_M THEN RST JogWithProbeTrippedArmed_M, RST ProbeTrippedDisarm_M, RST Ax1PlusJogDisabled_M, RST Ax1MinusJogDisabled_M, RST Ax2PlusJogDisabled_M,
						RST Ax2MinusJogDisabled_M, RST ProbeTripped_M, RST ToolTouchTripped_M, RST UsbProbeTripped_M

;--Process important Keyboard keys all the time
;--Cycle Cancel (ESC)
IF Kb_Escape THEN (KbCycleCancel_M)
;KbFeedHold_M (spacebar)
IF Kb_spacebar && AllowKbInput_M && SV_PROGRAM_RUNNING THEN (KbFeedHold_M)

IF SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN (KbJpActive_M)

;Call KeyboardEventsStage if needed
IF Kb_L_Ctrl || Kb_R_Ctrl ||
   Kb_L_Shift || Kb_R_Shift ||
   Kb_R_Alt || Kb_L_Alt || KbJpActive_M ||
   Kb_Enter || Kb_Num_Enter
  THEN SET KeyboardEventsStage

IF (Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt || Kb_L_Alt)
   && (Kb_j || Kb_f || Kb_a || Kb_s) && !AllowKbInput_M
  THEN InfoMsg_W = KB_JOG_MSG

;--Handle Faults
IF !EStopOk || PLCFault_M || SV_STALL_ERROR || SpindleFault_M || SkinResetSet_M ||
   LubeFault_M || AxisFault_M || ProbeFault_M || OtherFault_M || DoorShutDownStop_M ||
   THCError_M THEN SET SV_STOP

IF SV_STOP THEN RST SV_MASTER_ENABLE
IF SV_STOP || DoCycleCancel THEN RST M61; OUTPUT1
IF SV_STOP || DoCycleCancel THEN RST M62; OUTPUT2
IF SV_STOP || DoCycleCancel THEN RST M63; OUTPUT3
IF SV_STOP || DoCycleCancel THEN RST M64; OUTPUT4
IF SV_STOP || DoCycleCancel THEN RST M65; OUTPUT5
IF SV_STOP || DoCycleCancel THEN RST M66; OUTPUT6
IF SV_STOP || DoCycleCancel THEN RST M67; OUTPUT7
IF SV_STOP || DoCycleCancel THEN RST M68; OUTPUT8

;Spindle Fault
IF True THEN SpindleFaultTimer_T = SV_MACHINE_PARAMETER_996, SET SpindleFaultTimer_T
IF !EstopOK || ResetOkPD THEN RST SpindleFaultTimer_T
IF SpindleFaultTimer_T && !SpindleOk THEN FaultMsg_W = SPINDLE_FAULT_MSG, SET SpindleFault_M, SET OtherFault_M

;Drive Fault
IF TRUE THEN DriveFaultTimer = SV_MACHINE_PARAMETER_991, SET  DriveFaultTimer

IF !EStopOk || SkinResetSet_M || (DriveOk && Axis1DriveOk && Axis2DriveOk && Axis3DriveOk && Axis4DriveOk && SlavedAxisDriveOk) ||
	(!SV_PC_POWER_AXIS_1 && !SV_PC_POWER_AXIS_2 && !SV_PC_POWER_AXIS_3 && !SV_PC_POWER_AXIS_4)
	THEN RST DriveFaultTimer

IF Initialize_T && ((!DriveOk || !SlavedAxisDriveOk) && DriveFaultTimer) && EstopOK && (SV_PC_POWER_AXIS_1 || SV_PC_POWER_AXIS_2 || SV_PC_POWER_AXIS_3 || SV_PC_POWER_AXIS_4)
  THEN FaultMsg_W = DRIVE_FAULT_MSG, SET DriveFault_M, SET OtherFault_M

IF Initialize_T && (!EstopOK || SkinResetOkPD)
  THEN SET SkinResetOk_M, RST SkinResetSet_M, (ResetOkPD)

IF !EStopOk || ResetOkPD
  THEN RST SV_STALL_ERROR,
       RST LubeFault_M,
       RST SpindleFault_M,
       RST OtherFault_M,
       RST ProbeFault_M,
       RST ProbeMsgSent_M,
       RST DriveFault_M

IF Initialize_T && !LubeOk && !SV_PROGRAM_RUNNING
  THEN SET LubeFault_M, FaultMsg_W = LUBE_FAULT_MSG

;SpindleTempAlarm
IF SpindleTempAlarmMessage THEN InfoMSG_W = SPINDLETEMPALARM_MSG
IF SpindleTempAlarmStop THEN FaultMsg_W = SPINDLETEMPALARM_MSG, SET SpindleFault_M

;AirPressureLow
IF AirPressureLowMessage THEN InfoMSG_W = AIRPRESSURELOW_MSG
IF AirPressureLowStop THEN FaultMsg_W = AIRPRESSURELOW_MSG, SET OtherFault_M

;TorchTipMessage
IF TorchTouched_M THEN (TorchTripped_PD)
IF !TorchTouched_M THEN (TorchCleared_PD)

IF TorchTripped_PD THEN InfoMsg_W = TORCH_TIP_TRIPPED_MSG
IF TorchCleared_PD THEN InfoMsg_W = TORCH_TIP_CLEARED_MSG

IF !LubeOk && SV_PROGRAM_RUNNING THEN InfoMsg_W = LUBE_WARNING_MSG

;------------Carousel In/Out Section------------------------
;Carousel In
IF (SpindleIsOriented && M80_SV && M6) || M80_SV THEN RST M81_SV, SET ATC_CarouselIn,
	SET CarouselInOutTimer_T, SET MovingCarouselIn_M, RST MovingCarouselOut_M
  
IF SV_STOP || !SV_PROGRAM_RUNNING || (MovingCarouselIn_M && ATC_CarouselIsIn)
	THEN RST ATC_CarouselIn, RST M80_SV

IF ATC_CarouselIsIn THEN (CarouselInState_M)

;CarouselOut
IF (M81_SV && M6) || M81_SV THEN RST M80_SV, SET ATC_CarouselOut, SET CarouselInOutTimer_T,
	SET MovingCarouselOut_M, RST MovingCarouselIn_M
  
IF SV_STOP || !SV_PROGRAM_RUNNING || (MovingCarouselOut_M && ATC_CarouselIsOut)
	THEN RST ATC_CarouselOut, RST M81_SV
	
IF ATC_CarouselIsOut THEN (CarouselOutState_M)

;RST Timer on successful completion, job cancellation or fault
IF SV_STOP || !SV_PROGRAM_RUNNING || (MovingCarouselIn_M && ATC_CarouselIsIn) || 
  (MovingCarouselOut_M && ATC_CarouselIsOut)
  THEN RST CarouselInOutTimer_T, RST MovingCarouselIn_M, RST MovingCarouselOut_M 

IF (MovingCarouselIn_M && CarouselInOutTimer_T) || 
  (MovingCarouselOut_M && CarouselInOutTimer_T) 
  THEN FaultMsg_W = CAROUSEL_IN_OUT_TIMEOUT_MSG, SET OtherFault_M
;-------------END Carousel In/Out Section---------------------------

; Echo some system variables to memory bits, for troubleshooting only
IF SV_MASTER_ENABLE THEN (MasterEnable_M)
IF SV_STALL_ERROR THEN (Stall_M)
IF SV_STOP THEN (Stop_M)

; Reset faults if E-stop is released and no fault condition persists
IF EStopOk && SkinResetOk_M &&
	!(PLCFault_M || SV_STALL_ERROR || SpindleFault_M || LubeFault_M ||
	AxisFault_M || OtherFault_M || SoftwareNotReady_M || PLCExecutorFault_M
	|| DoorShutDownStop_M || THCError_M) THEN RST SV_STOP

IF SkinResetSet_M && SV_PC_SOFTWARE_READY THEN SET OtherFault_M, FaultMsg_W = RESET_DETECTED

IF SkinResetOkPD || !EstopOK THEN RST OtherFault_M

IF True THEN MessageTimer = 200
IF SkinResetOkPD THEN SET MessageTimer, RST SkinResetSet_M
IF MessageTimer THEN InfoMsg_W = RESET_CLEARED, RST MessageTimer
IF SkinResetSet_M || !EstopOK THEN RST MessageTimer

; Automatically reset non-fault errors after a short time
IF ErrorFlag_M THEN SET ErrorFlag_T
IF ErrorFlag_T THEN RST ErrorFlag_M, RST ErrorFlag_T

IF ProbeFault_M && !ProbeMsgSent_M
  THEN FaultMsg_W = PROBE_FAULT_MSG, SET ProbeMsgSent_M

;--M-Codes
;    Reset these M-codes if not in CNC Program Running mode
IF !(SV_PROGRAM_RUNNING || SV_MDI_MODE) || SV_STOP
  THEN RST M3,
       RST M4,
	   RST M6,		   
       RST M8,
       RST M7,
       RST M10M,
	   RST M10L,
	   RST M11L,
	   RST M18,
	   RST M3P,
	   RST M35

; Detect auto spindle and coolant requests during manual modes
IF M3 || M4 THEN (AutoSpindlePD)
IF AutoSpindlePD && !SpinAutoModeLED
  THEN SET ActivateFeedHold_M,
       InfoMsg_W = AUTO_SPINDLE_PROMPT

IF M7 || M8 THEN (AutoCoolantPD)
IF AutoCoolantPD && !CoolAutoModeLED
  THEN SET ActivateFeedHold_M,
       InfoMsg_W = AUTO_COOLANT_PROMPT

IF ActivateFeedHold_M THEN TriggerPause_T=100, SET TriggerPause_T
IF TriggerPause_T THEN RST TriggerPause_T, RST ActivateFeedHold_M

;Enable RPM Sensor Stage
IF !RPMSensorDisabled_M THEN SET RPMSensorStage
IF RPMSensorDisabled_M THEN RST RPMSensorStage

;--turn off default setup variable
IF True THEN RST OnAtPowerUp_M

IF !Initialize_T || !SV_PC_SOFTWARE_READY THEN RST OUT1, RST OUT2, RST OUT3, RST OUT4, RST OUT5, RST OUT6, RST OUT7, RST OUT8

;==============================================================================
                             RPMSensorStage
;==============================================================================
IF RPM_Sensor THEN (RPMSensorPD)

IF (RPMSensorPD && RPMSensorTimer_T) || (RPMSensorTimer_T >= 3000)
	THEN SpinSensorTimer_FW = RPMSensorTimer_T, RST RPMSensorTimer_T
IF RPMSensorPD && !RPMSensorTimer_T THEN SET RPMSensorTimer_T

;==============================================================================
                             HomeAllStage
;==============================================================================
;SV_MACHINE_PARAMETER_822 = Input for HomeAll
IF HomeAll || DisableAxis1Limit || LimitOverrideEnabled THEN (Axis1HomeLimitOkMem)
IF HomeAll || DisableAxis2Limit || LimitOverrideEnabled THEN (Axis2HomeLimitOkMem)
IF HomeAll || DisableAxis3Limit || LimitOverrideEnabled THEN (Axis3HomeLimitOkMem)
IF HomeAll || DisableAxis4Limit || LimitOverrideEnabled THEN (Axis4HomeLimitOkMem)

IF !EstopOK || SkinResetOkPD
  THEN RST DisableAxis1Limit, RST DisableAxis2Limit, RST DisableAxis3Limit, RST DisableAxis4Limit

;==============================================================================
                                 ShuttleStage
;==============================================================================
IF ShuttleAxisSelectKey && ((!SV_PROGRAM_RUNNING) || (SV_PROGRAM_RUNNING && SV_MDI_MODE))
  THEN (ShuttleAxisSelectPD), SET ShuttlePresent
;If using shuttle wheel and not in continuous mode, set to continuous
;IF (((Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_1 || Kb_2 || Kb_3 || Kb_4 || Kb_5 || Kb_6 || Kb_7)) ||
;   ((Kb_L_Alt || Kb_R_Alt) && (Kb_q || Kb_w || Kb_e || Kb_r || Kb_y || Kb_u || Kb_o)))
;    && IncrContLED THEN (IncrContPD)

;If using shuttle or jog wheel no axis is selected, issue message
IF (((Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_1 || Kb_2 || Kb_3 || Kb_4 || Kb_5 || Kb_6 || Kb_7)) ||
   ((Kb_L_Alt || Kb_R_Alt) && (Kb_q || Kb_w || Kb_e || Kb_r || Kb_y || Kb_u || Kb_o)) ||
   (Kb_PgDown || Kb_PgUp)) && (0 + ShuttleAxisSelect_W == 0)
   THEN InfoMsg_W = PLEASE_SELECT_AN_AXIS

IF (Kb_R_Alt || Kb_L_Alt) && Kb_q THEN (Shuttle10_OverPlusKey)
IF (Kb_R_Alt || Kb_L_Alt) && Kb_w THEN (Shuttle35_OverPlusKey)
IF (Kb_R_Alt || Kb_L_Alt) && Kb_e THEN (Shuttle75_OverPlusKey)
IF (Kb_R_Alt || Kb_L_Alt) && Kb_r THEN (Shuttle100_OverPlusKey)
IF (Kb_R_Alt || Kb_L_Alt) && Kb_y THEN (Shuttle135_OverPlusKey)
IF (Kb_R_Alt || Kb_L_Alt) && Kb_u THEN (Shuttle175_OverPlusKey)
IF (Kb_R_Alt || Kb_L_Alt) && Kb_o THEN (Shuttle200_OverPlusKey)

IF (Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_1 || Kb_10_Key_1) THEN (Shuttle10_OverMinusKey)
IF (Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_2 || Kb_10_Key_2) THEN (Shuttle35_OverMinusKey)
IF (Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_3 || Kb_10_Key_3) THEN (Shuttle75_OverMinusKey)
IF (Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_4 || Kb_10_Key_4) THEN (Shuttle100_OverMinusKey)
IF (Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_5 || Kb_10_Key_5) THEN (Shuttle135_OverMinusKey)
IF (Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_6 || Kb_10_Key_6) THEN (Shuttle175_OverMinusKey)
IF (Kb_L_Ctrl || Kb_R_Ctrl) && (Kb_7 || Kb_10_Key_7) THEN (Shuttle200_OverMinusKey)

IF (Kb_L_Ctrl || Kb_R_Ctrl) && Kb_Backslash THEN KbOverride_W = 100

IF Kb_Del THEN (ShuttleIncJogDec)

IF Kb_PgUp && AllowKbInput_M THEN (ShuttleIncJogPlus)
IF Kb_pgDown && AllowKbInput_M THEN (ShuttleIncJogMinus)
;IF ShuttleIncJogMinus || ShuttleIncJogPlus && IncrContLED THEN (IncrContPD)

IF ShuttleIncJogDec && AllowKbInput_M
  THEN (ShuttleIncJogDec), InfoMsg_W = JOG_INCREMENT_DECREASED

IF (Kb_L_Ctrl || Kb_R_Ctrl) && Kb_z && AllowKbInput_M
  THEN (ShuttleIncJogInc), InfoMsg_W = JOG_INCREMENT_INCREASED

IF (Shuttle10_OverMinusKey || Shuttle35_OverMinusKey || Shuttle75_OverMinusKey ||
  Shuttle100_OverMinusKey || Shuttle135_OverMinusKey || Shuttle175_OverMinusKey ||
  Shuttle200_OverMinusKey) THEN (ShuttleAxisJogContMinus)

IF (Shuttle10_OverPlusKey || Shuttle35_OverPlusKey || Shuttle75_OverPlusKey ||
  Shuttle100_OverPlusKey || Shuttle135_OverPlusKey || Shuttle175_OverPlusKey ||
  Shuttle200_OverPlusKey) THEN (ShuttleAxisJogContPlus)

IF (((Shuttle10_OverMinusKey || Shuttle35_OverMinusKey || Shuttle75_OverMinusKey ||
  Shuttle100_OverMinusKey || Shuttle135_OverMinusKey || Shuttle175_OverMinusKey ||
  Shuttle200_OverMinusKey) && !IncrContLED) || (ShuttleIncJogMinus && IncrContLED))
  && ((!SV_PROGRAM_RUNNING) || (SV_PROGRAM_RUNNING && SV_MDI_MODE)) && ShuttleEnabled
  THEN (ShuttleAxisJogMinusKey)

IF (((Shuttle10_OverPlusKey || Shuttle35_OverPlusKey || Shuttle75_OverPlusKey ||
  Shuttle100_OverPlusKey || Shuttle135_OverPlusKey || Shuttle175_OverPlusKey ||
  Shuttle200_OverPlusKey) && !IncrContLED) || (ShuttleIncJogPlus && IncrContLED))
  && ((!SV_PROGRAM_RUNNING) || (SV_PROGRAM_RUNNING && SV_MDI_MODE)) && ShuttleEnabled
  THEN (ShuttleAxisJogPlusKey)

IF (Shuttle10_OverMinusKey || Shuttle10_OverPlusKey) THEN KbOverride_W = 10
IF (Shuttle35_OverMinusKey || Shuttle35_OverPlusKey) THEN KbOverride_W = 35
IF (Shuttle75_OverMinusKey || Shuttle75_OverPlusKey) THEN KbOverride_W = 75
IF (Shuttle100_OverMinusKey || Shuttle100_OverPlusKey) THEN KbOverride_W = 100
IF (Shuttle135_OverMinusKey || Shuttle135_OverPlusKey) THEN KbOverride_W = 135
IF (Shuttle175_OverMinusKey || Shuttle175_OverPlusKey) THEN KbOverride_W = 175
IF (Shuttle200_OverMinusKey || Shuttle200_OverPlusKey) THEN KbOverride_W = 200

IF (ShuttleAxisSelectPD && (ShuttleAxisSelect_W == 4)) || SV_STOP ||
  (SV_PROGRAM_RUNNING && !SV_MDI_MODE)
  THEN RST ShuttleEnabled

IF (ShuttleAxisSelectPD && (ShuttleAxisSelect_W == 0))
  THEN SET ShuttleAxis1Selected, RST ShuttleAxis2Selected,
  RST ShuttleAxis3Selected, RST ShuttleAxis4Selected

IF (ShuttleAxisSelectPD && (ShuttleAxisSelect_W == 1))
  THEN RST ShuttleAxis1Selected, SET ShuttleAxis2Selected,
  RST ShuttleAxis3Selected, RST ShuttleAxis4Selected

IF (ShuttleAxisSelectPD && (ShuttleAxisSelect_W == 2))
  THEN RST ShuttleAxis1Selected, RST ShuttleAxis2Selected,
  SET ShuttleAxis3Selected, RST ShuttleAxis4Selected

IF (ShuttleAxisSelectPD && (ShuttleAxisSelect_W == 3))
  THEN RST ShuttleAxis1Selected, RST ShuttleAxis2Selected,
  RST ShuttleAxis3Selected, SET ShuttleAxis4Selected

IF (ShuttleAxisSelectPD && ShuttleAxisSelect_W == 4) ||
  SV_STOP || (SV_PROGRAM_RUNNING && !SV_MDI_MODE)
  THEN ShuttleAxisSelect_W = 0, RST ShuttleAxis1Selected, RST ShuttleAxis2Selected,
  RST ShuttleAxis3Selected, RST ShuttleAxis4Selected

IF ShuttleAxisSelectPD && ShuttleAxis1Selected
  THEN ShuttleAxisSelect_W = 1, InfoMsg_W = SHUTTLE_AXIS1_SELECTED
IF ShuttleAxisSelectPD && ShuttleAxis2Selected
  THEN ShuttleAxisSelect_W = 2, InfoMsg_W = SHUTTLE_AXIS2_SELECTED
IF ShuttleAxisSelectPD && ShuttleAxis3Selected
  THEN ShuttleAxisSelect_W = 3, InfoMsg_W = SHUTTLE_AXIS3_SELECTED
IF ShuttleAxisSelectPD && ShuttleAxis4Selected
  THEN ShuttleAxisSelect_W = 4, InfoMsg_W = SHUTTLE_AXIS4_SELECTED

IF ShuttleAxis1Selected || ShuttleAxis2Selected || ShuttleAxis3Selected || ShuttleAxis4Selected
  THEN (ShuttleEnabled)

IF  ShuttleAxisSelectPD && (!ShuttleAxis1Selected && !ShuttleAxis2Selected &&
  !ShuttleAxis3Selected && !ShuttleAxis4Selected)
  THEN InfoMsg_W = SHUTTLE_DISABLED
  
;==============================================================================
                            TorchSectionStage
;==============================================================================
;Error Handling
; SV_THC_ENCODER_STATUS Bits
;  Bit 0 = General Error (Any of the other bits are on)
;  Bit 1 = Encoder Reading Negative Values
;  Bit 2 = Error when neither Bit 6 or Bit 7 are set.
;  Bit 3 = Error when both bit 6 and bit 7 are set.
;  Bit 4 = Encoder Disconnected Error (Checks for consecutive zeros)
IF (SV_MACHINE_PARAMETER_820 == 3) && !THCNotInstalledBit_M
	THEN THCEncoderStatus_W = SV_THC_ENCODER_STATUS,
         BITTST THCEncoderStatus_W 0 THCError_M,
		 BITTST THCEncoderStatus_W 1 THCNegativeError_M,
		 BITTST THCEncoderStatus_W 4 THCDisconnectError_M
		 
IF THCNotInstalledBit_M THEN RST THCError_M, RST THCNegativeError_M, RST THCDisconnectError_M
			 
IF Initialize_T && THCError_M THEN FaultMsg_W = THC_ENCODER_FAULT_MSG

;TorchBreakaway
; SV_STOP Condition when Breakaway while not running job
; FeedHold condition when Breakaway while running job.
IF !TorchBreakawayOk || (TorchFloatSwitch_I && !DisableTouchFault_SV) THEN (TorchBreakawayFault_M)
IF !TorchBreakawayFault_M THEN RST TorchBreakawayTripped_M, RST SkinBreakawayDisable_M
IF !SV_PROGRAM_RUNNING || SV_STOP THEN RST DisableTouchFault_SV

;Handle TorchBreakaway when Out of Program
IF TorchBreakawayFault_M && !SV_PROGRAM_RUNNING && !BreakAwayAllowZ_M && !TorchRestartModeLED
	THEN FaultMsg_W = TORCH_BREAK_MSG, SET OtherFault_M, SET BreakAwayAllowZ_M

IF !SV_STOP && BreakAwayAllowZ_M THEN InfoMsg_W = TORCH_BREAK_ALLOW_MSG
IF !TorchBreakawayFault_M && BreakAwayAllowZ_M && !SV_PROGRAM_RUNNING THEN InfoMsg_W = TORCH_BREAK_CLEAR_MSG
IF (TorchBreakawayOk && !TorchFloatSwitch_I) || SV_PROGRAM_RUNNING THEN RST BreakAwayAllowZ_M

;Handle TorchBreakaway when In Program
IF TorchBreakawayFault_M && SV_PROGRAM_RUNNING && !TorchBreakawayTripped_M THEN (TorchBreakaway_PD), SET TorchBreakawayTripped_M
IF TorchBreakaway_PD && !SkinBreakawayDisable_M THEN ErrorMsg_W = TORCH_BREAK_MSG, SET ActivateFeedHold_M

;Handle VCP Toggle Buttons
IF SkinTorchOn_M THEN SET TorchToggleOn_M
IF SkinTorchOff_M || SV_STOP THEN RST TorchToggleOn_M

;TorchCheck VCP Button
; When outside of a program, Torchcheck should act as an AuxKey
; When inside of a program, Torchcheck should activate feedhold, and initiate restart mode.
; Restart Feature will then handle Torch Check Functionality.
IF (SkinTorchCheck_M || MpgToolCheck_M) && SV_PROGRAM_RUNNING && !TorchCheckMode_M THEN SET ActivateFeedHold_M, SET TorchCheckMode_M
IF SkinResetTorchCheck_M || (CycleCancelKey || KbCycleCancel_M || SkinCycleCancel_M || MpgResetKey_M || CycleCancel2) || SV_STOP THEN RST TorchCheckMode_M

;Reset M3 and Toggle Buttons if FeedHold is Active
IF FeedHoldLED THEN RST TorchToggleOn_M, RST M3P

;Handle Torch Restart
IF SkinTorchRestartMode_M || TorchCheckMode_M || (MpgMacro3_M && PlasmaWMPG_M) THEN (TorchRestartMode_PD)
IF (TorchRestartMode_PD || TorchBreakaway_PD) && !TorchRestartModeLED THEN LastKbOverride_W = KbOverride_W
IF (TorchRestartMode_PD || TorchBreakaway_PD) && !TorchRestartModeLED THEN SET TorchRestartModeLED, KbOverride_W = 25
IF SV_STOP || ((CycleCancelKey || KbCycleCancel_M || SkinCycleCancel_M || MpgResetKey_M || CycleCancel2) && !SV_PROGRAM_RUNNING) ||
	SkinRestartModeCancel_M THEN RST TorchRestartModeLED
IF !TorchRestartModeLED THEN (TorchRestartModeOff_PD)
IF TorchRestartModeOff_PD THEN KbOverride_W = LastKbOverride_W

;Handle Torch Fire
; Disconnect Torch Touch Before Firing Torch
; This Prevents possible High Voltage damaging Opto input Chip
IF ((M3P && SV_PROGRAM_RUNNING && !DryRunLED) || TorchToggleOn_M || SkinTorchTest_M) &&
	!SV_STOP THEN (TorchOn_M), SET TorchTouchDisconnect
IF TorchOn_M THEN SET TorchDisconnect_T, RST TorchConnect_T
IF !TorchOn_M THEN RST TorchDisconnect_T, SET TorchConnect_T
IF TorchDisconnect_T THEN (TorchOn)

;Reconnect Torch Touch after Torch is off
IF TorchConnect_T THEN RST TorchTouchDisconnect, RST TorchConnect_T

;Override Knob Handling (See FastStage "TorchStage" for AutoSense TargetVoltage_W)
; If Autosense turned off P523 != 2, then target voltage is P511 Modified by Voltage Override Knob
; If Autosense enabled, then target voltage is TargetVoltage_W modified by Voltage Override Knob
IF !THCAutoSenseBit_M THEN SV_THC_TARGET_VOLTAGE = SV_MACHINE_PARAMETER_511 * SV_PLC_SPINDLE_KNOB * 0.01
IF THCAutoSenseBit_M THEN SV_THC_TARGET_VOLTAGE = TargetVoltage_W * SV_PLC_SPINDLE_KNOB * 0.01

;Prohibit changing Target Voltage from Tripping Anti-Dive.
;If Anti-Dives Trips when knob is changed, it will be ignored (See TorchStage)
IF Last_TorchKnob_W != SV_PLC_SPINDLE_KNOB THEN SET TorchKnobChanged_M
IF Last_TorchKnob_W == SV_PLC_SPINDLE_KNOB && TorchKnobChanged_M THEN RST TorchKnobChanged_M
IF True THEN Last_TorchKnob_W = SV_PLC_SPINDLE_KNOB

;THCAuto
IF SkinTHCAuto_M || (MpgSpinOnOff_M && PlasmaWMPG_M) THEN (THCAuto_PD)
IF SV_PROGRAM_RUNNING && (THCAutomaticBit_M || THCAutoSenseBit_M) THEN (THCAutoOn_PD)
IF SV_PROGRAM_RUNNING && !THCAutomaticBit_M && !THCAutoSenseBit_M THEN (THCAutoOff_PD)

IF (((THCAuto_PD ^ THCAutoLED) || THCAutoOn_PD) && !THCAutoOff_PD && !TorchRestartModeLED && !THCNotInstalledBit_M) ||
	OnAtPowerUp_M THEN (THCAutoLED)

;ButtonPressed Section for Restart Feature
; Allows time for Skinning to pick up that a button has been pressed.
IF (CycleStartKey || KbCycleStart_M || SkinCycleStart_M || MpgCycleStart_M || CycleStart2) THEN SET CycleStartPressed_M, SET ButtonPressed_T
IF (CycleCancelKey || KbCycleCancel_M || SkinCycleCancel_M || MpgResetKey_M || CycleCancel2) THEN SET CycleCancelPressed_M, SET ButtonPressed_T
IF (SkinTorchCheck_M || MpgToolCheck_M) THEN SET TorchCheckPressed_M, SET ButtonPressed_T
IF SkinTorchRestartForward_M || (MpgMacro4_M && PlasmaWMPG_M) THEN SET RestartForwardPressed_M, SET ButtonPressed_T
IF SkinTorchRestartBackward_M || (MpgMacro2_M && PlasmaWMPG_M) THEN SET RestartBackwardPressed_M, SET ButtonPressed_T

IF ButtonPressed_T || SV_STOP THEN RST CycleStartPressed_M,
                                   RST TorchCheckPressed_M,
								   RST RestartForwardPressed_M,
								   RST RestartBackwardPressed_M,
								   RST CycleCancelPressed_M,
								   RST ButtonPressed_T

;==========================================================
	DoorInterlockStage
;==========================================================
;--DoorInterlock Mode
IF !SafetyDoorSwitchClosed_I && !DoorClosed_M THEN SET DoorOpen_M
IF SafetyDoorSwitchClosed_I && !DoorOpen_M THEN SET DoorClosed_M

;If door open and not running a job, then slow jog only:
IF (!(SV_PROGRAM_RUNNING || SV_MDI_MODE) && DoorInterlockMode_M
    && !SafetyDoorSwitchClosed_I)
    THEN (DoorOpenSlowJog_M), SET ErrorFlag_M

;IF Starting or Running Program and door opens, set feed hold and Errormsg.
IF ((SV_PROGRAM_RUNNING || SV_MDI_MODE) && DoorInterlockMode_M
    && !SafetyDoorSwitchClosed_I) || ((!SV_PROGRAM_RUNNING || !SV_MDI_MODE) && DoorInterlockMode_M
    && DoCycleStart && !SafetyDoorSwitchClosed_I)
   THEN SET ActivateFeedHold_M, SET DoorFeedHold_M, ErrorMsg_W = WAITING_FOR_DOOR_CLOSED

;Send InfoMsg when door is opened
IF DoorInterlockMode_M && !SafetyDoorSwitchClosed_I && DoorClosed_M
	&& !DoorFeedHold_M && (!SV_PROGRAM_RUNNING || !SV_MDI_MODE)
	THEN SET DoorOpen_M, RST DoorClosed_M, InfoMSG_W = DOOR_OPEN

;Send InfoMsg when door is closed
IF (DoorInterlockMode_M) && SafetyDoorSwitchClosed_I && DoorOpen_M
	&& !DoorFeedHold_M && (!SV_PROGRAM_RUNNING || !SV_MDI_MODE)
	THEN SET DoorClosed_M, RST DoorOpen_M, InfoMSG_W = DOOR_CLOSED

;Reset FeedStop and Display message to press cycle start
IF DoorInterlockMode_M && SafetyDoorSwitchClosed_I && FeedHoldLED && DoorFeedHold_M
	THEN InfoMsg_W = DOOR_CLOSED_FEED, RST DoorFeedHold_M

;Reset FeedHoldMode if no longer in job
IF DoorInterlockMode_M && DoorFeedHold_M && ((!SV_PROGRAM_RUNNING || SV_MDI_MODE))
	THEN RST DoorFeedHold_M

;--DoorShutdown Mode
;IF in Shutdown mode and door is open, STOP and send error
IF (DoorInterlockShutdown_M && !SafetyDoorSwitchClosed_I)
	THEN SET DoorShutDownStop_M, ErrorMsg_W = WAITING_FOR_DOOR_CLOSED
;
;Send ErrorMSG if user tried to turn on fast jog with InterlockMode
IF SlowFastPD && DoorOpenSlowJog_M THEN ErrorMsg_W = DOOR_OPEN_SLOW_ONLY

;Reset Display message to cycle E-Stop When in SV_Stop after Door Opened.
IF DoorInterlockShutdown_M && SafetyDoorSwitchClosed_I && SV_STOP && DoorShutDownStop_M
	THEN InfoMsg_W = DOOR_CLOSED_SHUTDOWN

;Reset Door Shutdown if door is closed
IF (!EstopOK || !SkinResetOk_M) && (DoorInterlockShutdown_M && SafetyDoorSwitchClosed_I)
	THEN RST DoorShutDownStop_M

;--Door Lock
;Unlock Door if Not Running program or during feedhold and no spindle.
IF (!DoorInterlockMode_M && !DoorInterlockShutdown_M) || !SV_PROGRAM_RUNNING || (FeedHoldLED && !SpindleEnableOut_M)
	THEN SET SafetyDoorLock_T, RST SafetyDoorLockConfirm_T

IF SafetyDoorLock_T THEN SET SafetyDoorLockOpen_O

;Lock Door if Running Program
IF ((DoorInterlockMode_M && SV_PROGRAM_RUNNING && !FeedHoldLED) ||
	(DoorInterlockShutdown_M && SV_PROGRAM_RUNNING))&& DoorClosed_M
	THEN RST SafetyDoorLockOpen_O, SET SafetyDoorLockConfirm_T, RST SafetyDoorLock_T

IF SafetyDoorLockConfirmed_I THEN RST SafetyDoorLockConfirm_T

;Error if Door Lock not confirmed after 2 seconds
IF (DoorInterlockMode_M || DoorInterlockShutdown_M) && !SafetyDoorLockConfirmed_I && SafetyDoorLockConfirm_T
	THEN FaultMsg_W = DOOR_LOCK_FAULT, SET OtherFault_M, RST SafetyDoorLockConfirm_T

;==============================================================================
                               ZriHomeStage
;==============================================================================
;SV_MACHINE_PARAMETER_823 = Input for ZRI
IF 1 == 1 THEN SET MEM1000

;==============================================================================
                             PairedHomingStage
;==============================================================================
;SV_MACHINE_PARAMETER_821 = Bitwise PLC inputs for paired axis homing.
; 3=INP1(Master) & INP2(paired). Negate if paired is first. etc...
; -3=INP1(paired) & INP2(master) = paired.
IF 1 == 1 THEN SET MEM1000

;==============================================================================
                              LimitAllStage
;==============================================================================
;SV_MACHINE_PARAMETER_824 = LimitAllInput
IF 1 == 1 THEN SET MEM1000

;==============================================================================
                               UsbMpgStage
;==============================================================================
;SV_MACHINE_PARAMETER_218 if non-zero value, start UsbMpg Pipe client with CNC12
IF 1 == 1 THEN SET MEM1000

;==============================================================================
                             SetRequestedPositionStage
;==============================================================================
IF 1 == 1 THEN SET MEM1000
;==============================================================================
                             MonitorATCStage
;==============================================================================
;Stage is to Determine what ATC related stages should be enabled and disabled based
;on ATC type, Inputs selected, and ect.
;ATCType_W 0 = Manual Tool Changer
;ATCType_W 1 = Umbrella/Carousel
;ATCType_W 2 = Counter Turret
;ATCType_W 3 = Graycode 2 Output
;ATCType_W 4 = Graycode 1 Output
;ATCType_W 5 = Time Based Turret
;ATCType_W 6 = Axis Based Turret
;ATCType_W 7 = Rack Based Tool Changer

;ATC Setup
IF (ATCType_W == 1) THEN SET ReportCarouselPositionStage,
						 SET ResetCarouselStage,
						 SET MonitorIndexATCRequestStage,
						 RST ATCIncrementalStage,
						 RST ATCGrayCodeStage,
						 RST ATCPositionReportStage

IF (AtcType_W == 2) THEN RST ReportCarouselPositionStage,
						 RST ResetCarouselStage,
						 SET ATCIncrementalStage,
						 RST ATCGrayCodeStage,
						 RST ATCPositionReportStage

IF (ATCType_W == 3) || (ATCType_W == 4) THEN RST ReportCarouselPositionStage,
											 RST ResetCarouselStage,
											 SET ATCGrayCodeStage,
											 RST AtcIncrementalStage,
											 RST ATCPositionReportStage

IF (ATCType_W == 5) THEN RST ReportCarouselPositionStage,
						 RST ResetCarouselStage,
						 SET ATCPositionReportStage,
						 RST ATCGrayCodeStage,
						 RST ATCIncrementalStage

IF (ATCType_W == 6) || (ATCType_W == 7) THEN RST ReportCarouselPositionStage,
											 RST ResetCarouselStage,
											 SET ATCPositionReportStage,
											 RST ATCGrayCodeStage,
											 RST ATCIncrementalStage

;Index the turret
IF SkinTurretIndex_M THEN SET TurretIndex_M, SET IndexTurretStage

;Call out stage to perform tool change
IF M6 && (ATCType_W == 2) THEN SET RotateTurretStage2, RST TurretIndex_M
IF M6 && (ATCType_W == 3) THEN SET RotateTurretStage,  RST TurretIndex_M
IF M6 && (ATCType_W == 4) THEN SET RotateTurretStage2, RST TurretIndex_M
IF M6 && (ATCType_W == 5) THEN SET RotateTurretStage3, RST TurretIndex_M

;==============================================================================
                               ATCPositionReportStage
;==============================================================================

;Report Current Turret Position for PLC Tracked
IF (ATCType_W == 5) THEN SV_PLC_CAROUSEL_POSITION = CurrentTurretPosition_W

;Report Current Turret Position for Macro Tracked
IF (ATCType_W == 6) || (ATCType_W == 7) THEN CurrentTurretPosition_W = SV_MACHINE_PARAMETER_976
IF (ATCType_W == 6) || (ATCType_W == 7) THEN SV_PLC_CAROUSEL_POSITION = CurrentTurretPosition_W

;==============================================================================
                               ATCGrayCodeStage
;==============================================================================
; Check input based on parameter bits to determine tool location
IF !(ToolTurretPosBit1 ^ P831Bit0) && !(ToolTurretPosBit2 ^ P831Bit1) 
 && !(ToolTurretPosBit3 ^ P831Bit2) && !(ToolTurretPosBit4 ^ P831Bit3)
 && SV_MACHINE_PARAMETER_161 >= 1 THEN CurrentTurretPosition_W = 1
IF !(ToolTurretPosBit1 ^ P832Bit0) && !(ToolTurretPosBit2 ^ P832Bit1) 
 && !(ToolTurretPosBit3 ^ P832Bit2) && !(ToolTurretPosBit4 ^ P832Bit3)
 && SV_MACHINE_PARAMETER_161 >= 2 THEN CurrentTurretPosition_W = 2
IF !(ToolTurretPosBit1 ^ P833Bit0) && !(ToolTurretPosBit2 ^ P833Bit1) 
 && !(ToolTurretPosBit3 ^ P833Bit2) && !(ToolTurretPosBit4 ^ P833Bit3)
 && SV_MACHINE_PARAMETER_161 >= 3 THEN CurrentTurretPosition_W = 3
IF !(ToolTurretPosBit1 ^ P834Bit0) && !(ToolTurretPosBit2 ^ P834Bit1) 
 && !(ToolTurretPosBit3 ^ P834Bit2) && !(ToolTurretPosBit4 ^ P834Bit3)
 && SV_MACHINE_PARAMETER_161 >= 4 THEN CurrentTurretPosition_W = 4
IF !(ToolTurretPosBit1 ^ P835Bit0) && !(ToolTurretPosBit2 ^ P835Bit1)
 && !(ToolTurretPosBit3 ^ P835Bit2) && !(ToolTurretPosBit4 ^ P835Bit3)
 && SV_MACHINE_PARAMETER_161 >= 6 THEN CurrentTurretPosition_W = 5
IF !(ToolTurretPosBit1 ^ P836Bit0) && !(ToolTurretPosBit2 ^ P836Bit1)
 && !(ToolTurretPosBit3 ^ P836Bit2) && !(ToolTurretPosBit4 ^ P836Bit3)
 && SV_MACHINE_PARAMETER_161 >= 6 THEN CurrentTurretPosition_W = 6
IF !(ToolTurretPosBit1 ^ P837Bit0) && !(ToolTurretPosBit2 ^ P837Bit1)
 && !(ToolTurretPosBit3 ^ P837Bit2) && !(ToolTurretPosBit4 ^ P837Bit3)
 && SV_MACHINE_PARAMETER_161 >= 7 THEN CurrentTurretPosition_W = 7
IF !(ToolTurretPosBit1 ^ P838Bit0) && !(ToolTurretPosBit2 ^ P838Bit1)
 && !(ToolTurretPosBit3 ^ P838Bit2) && !(ToolTurretPosBit4 ^ P838Bit3)
 && SV_MACHINE_PARAMETER_161 >= 8 THEN CurrentTurretPosition_W = 8
IF !(ToolTurretPosBit1 ^ P839Bit0) && !(ToolTurretPosBit2 ^ P839Bit1)
 && !(ToolTurretPosBit3 ^ P839Bit2) && !(ToolTurretPosBit4 ^ P839Bit3)
 && SV_MACHINE_PARAMETER_161 >= 9 THEN CurrentTurretPosition_W = 9
IF !(ToolTurretPosBit1 ^ P840Bit0) && !(ToolTurretPosBit2 ^ P840Bit1)
 && !(ToolTurretPosBit3 ^ P840Bit2) && !(ToolTurretPosBit4 ^ P840Bit3)
 && SV_MACHINE_PARAMETER_161 >= 10 THEN CurrentTurretPosition_W = 10
IF !(ToolTurretPosBit1 ^ P841Bit0) && !(ToolTurretPosBit2 ^ P841Bit1)
 && !(ToolTurretPosBit3 ^ P841Bit2) && !(ToolTurretPosBit4 ^ P841Bit3)
 && SV_MACHINE_PARAMETER_161 >= 11 THEN CurrentTurretPosition_W = 11
IF !(ToolTurretPosBit1 ^ P842Bit0) && !(ToolTurretPosBit2 ^ P842Bit1)
 && !(ToolTurretPosBit3 ^ P842Bit2) && !(ToolTurretPosBit4 ^ P842Bit3)
 && SV_MACHINE_PARAMETER_161 >= 12 THEN CurrentTurretPosition_W = 12
IF !(ToolTurretPosBit1 ^ P843Bit0) && !(ToolTurretPosBit2 ^ P843Bit1)
 && !(ToolTurretPosBit3 ^ P843Bit2) && !(ToolTurretPosBit4 ^ P843Bit3)
 && SV_MACHINE_PARAMETER_161 >= 13 THEN CurrentTurretPosition_W = 13
IF !(ToolTurretPosBit1 ^ P844Bit0) && !(ToolTurretPosBit2 ^ P844Bit1)
 && !(ToolTurretPosBit3 ^ P844Bit2) && !(ToolTurretPosBit4 ^ P844Bit3)
 && SV_MACHINE_PARAMETER_161 >= 14 THEN CurrentTurretPosition_W = 14
IF !(ToolTurretPosBit1 ^ P845Bit0) && !(ToolTurretPosBit2 ^ P845Bit1)
 && !(ToolTurretPosBit3 ^ P845Bit2) && !(ToolTurretPosBit4 ^ P845Bit3)
 && SV_MACHINE_PARAMETER_161 >= 15 THEN CurrentTurretPosition_W = 15
IF !(ToolTurretPosBit1 ^ P846Bit0) && !(ToolTurretPosBit2 ^ P846Bit1)
 && !(ToolTurretPosBit3 ^ P846Bit2) && !(ToolTurretPosBit4 ^ P846Bit3)
 && SV_MACHINE_PARAMETER_161 >= 16 THEN CurrentTurretPosition_W = 16

IF TRUE THEN SV_PLC_CAROUSEL_POSITION = CurrentTurretPosition_W

;==============================================================================
                              ATCIncrementalStage
;==============================================================================
;For incremental ATC's, ToolTurretPosBit1 is the tool counter and toggles each time the 
;turret rotates to a tool position. If ToolTurretPosBit1 toggles while ReverseToolTurret is
;not on, then CurrentTurretPosition_W = CurrentTurretPosition_W + 1. If ToolTurretPosBit1
;toggles while ReverseToolTurret is on, then CurrentTurretPosition_W = CurrentTurretPosition_W -1.
;IF ToolTurretPosBit1 && RotateToolTurret && !ReverseToolTurret 
  ;THEN CurrentTurretPosition_W = CurrentTurretPosition_W + 1 
;IF ToolTurretPosBit1 && RotateToolTurret && ReverseToolTurret 
  ;THEN CurrentTurretPosition_W = CurrentTurretPosition_W - 1

;Turn timer on when turret motor is moving
;This will allow time to skip the first count it sees
IF RotateToolTurret THEN SET CountSkipTimer

;Turn timers off when turret is not on
IF !RotateToolTurret THEN RST CountSkipTimer, RST ToolTurretOffCurrentToolTimer

;Update turret position every time the ToolCounterInput fires
;Use 1 shot so tool counter only increments once when input is turned on
IF ToolTurretCounter THEN (ToolCounterPD)
IF RotateToolTurret && ToolCounterPD && CountSkipTimer THEN CurrentTurretPosition_W = CurrentTurretPosition_W + 1

;Rollover after turret goes over the max bins  
IF CurrentTurretPosition_W > SV_MACHINE_PARAMETER_161 THEN CurrentTurretPosition_W = 1 

;Send the current position to CNC12
IF TRUE THEN SV_PLC_CAROUSEL_POSITION = CurrentTurretPosition_W
  
;==============================================================================
                                IndexTurretStage
;==============================================================================
IF TurretIndex_M && (CurrentTurretPosition_W == SV_MACHINE_PARAMETER_161) 
	THEN RequestedTurretPosition_W = 1
IF TurretIndex_M && (CurrentTurretPosition_W != SV_MACHINE_PARAMETER_161) 
	THEN RequestedTurretPosition_W = CurrentTurretPosition_W +1

IF (ATCType_W == 3) THEN SET RotateTurretStage, RST IndexTurretStage
IF (ATCType_W == 2) || (ATCType_W == 4) THEN SET RotateTurretStage2, RST IndexTurretStage
IF (ATCType_W == 5) THEN SET RotateTurretStage3, RST IndexTurretStage

;==============================================================================
                                HomeTurretStage
;==============================================================================
;If not at home, turn turret on
IF M18 && !TurretHomed_M THEN SET RotateToolTurret

;Turn timer on once home signal is triggered
IF M18 && ToolTurretSyncBit THEN SET ToolTurretOffCurrentToolTimer

;Turn motor off and assign value of 1 when timer is up
IF ToolTurretOffCurrentToolTimer THEN RST RotateToolTurret,
									  CurrentTurretPosition_W = 1,
									  SET TurretHomed_M

;==============================================================================
                                RotateTurretStage
;==============================================================================
;--2 Output GrayCode Turret
;Determine the desired tool location
IF !TurretIndex_M THEN RequestedTurretPosition_W = SV_TOOL_NUMBER

;Error if Tool Invalid
IF RequestedTurretPosition_W > SV_MACHINE_PARAMETER_161
	THEN FaultMsg_W = INVALID_TOOL_REQUEST, SET OtherFault_M

;If not at desired location start rotating the turret
IF (M6 || TurretIndex_M) && (RequestedTurretPosition_W != CurrentTurretPosition_W) 
	THEN SET RotateToolTurret, SET ToolChangeTimeOutTimer, SET ToolTurretEnable

;Turn the timer on once at the desired location to go slightly past the tool location
;in order to reverse into correct tool location
IF (M6 || TurretIndex_M) && (RequestedTurretPosition_W == CurrentTurretPosition_W) 
	THEN (ToolTimerPD)

IF ToolTimerPD THEN SET ToolTurretOffCurrentToolTimer 

;Reverse turret after timer expires in order to lock into correct tool location
IF ToolTurretOffCurrentToolTimer THEN SET ReverseToolTurret, SET TurretReverseTimer

;Set memory bit stating tool change is done
IF TurretReverseTimer THEN SET ToolChangeComplete_M,
						   RST RotateToolTurret,
						   RST ToolTurretEnable

;If timer expires set fault
IF ToolChangeTimeOutTimer THEN SET SV_STOP, FaultMsg_W = TURRET_TIMEOUT_FAULT

;==============================================================================
                                RotateTurretStage2
;==============================================================================
;--1 Output GrayCode Turret
;Determine the desired tool location
IF !TurretIndex_M THEN RequestedTurretPosition_W = SV_TOOL_NUMBER

;Error if Tool Invalid
IF RequestedTurretPosition_W > SV_MACHINE_PARAMETER_161
	THEN FaultMsg_W = INVALID_TOOL_REQUEST, SET OtherFault_M

;If not at desired location start rotating the turret
IF (M6 || TurretIndex_M) && (RequestedTurretPosition_W != CurrentTurretPosition_W) 
	THEN SET RotateToolTurret, SET ToolChangeTimeOutTimer, SET ToolTurretEnable

;Turn the timer on once at the desired location to go slightly past the tool location
;in order to reverse into correct tool location
IF (M6 || TurretIndex_M) && (RequestedTurretPosition_W == CurrentTurretPosition_W) 
	THEN SET ToolTurretOffCurrentToolTimer 

;Reverse turret after timer expires in order to lock into correct tool location
IF ToolTurretOffCurrentToolTimer THEN RST RotateToolTurret, SET ToolChangeComplete_M, RST ToolTurretEnable

;If timer expires set fault
IF ToolChangeTimeOutTimer THEN SET SV_STOP, FaultMsg_W = TURRET_TIMEOUT_FAULT

;==============================================================================
                                RotateTurretStage3
;==============================================================================
;--Time Based Turret
;IF M6 || TurretIndex_M THEN (ToolTimerPD)
;Determine the desired tool location
IF !TurretIndex_M THEN RequestedTurretPosition_W = SV_TOOL_NUMBER

;Error if Tool Invalid
IF RequestedTurretPosition_W > SV_MACHINE_PARAMETER_161
	THEN FaultMsg_W = INVALID_TOOL_REQUEST, SET OtherFault_M

;Determine Amount of Time required to get to Requested Tool
IF (RequestedTurretPosition_W >= CurrentTurretPosition_W) THEN
	ToolChangeTimer = (ABS(RequestedTurretPosition_W - CurrentTurretPosition_W) * SV_MACHINE_PARAMETER_975)

IF (RequestedTurretPosition_W < CurrentTurretPosition_W) THEN
	ToolChangeTimer = ((ABS(SV_MACHINE_PARAMETER_161 - CurrentTurretPosition_W) + RequestedTurretPosition_W) * SV_MACHINE_PARAMETER_975)

;If not at desired location start rotating the turret
IF (M6 || TurretIndex_M) && (RequestedTurretPosition_W != CurrentTurretPosition_W) 
	THEN SET RotateToolTurret, SET ToolChangeTimer, SET ToolTurretEnable

;Stop turret after timer expires in order to lock into correct tool location
IF ToolChangeTimer THEN RST RotateToolTurret, SET ToolChangeComplete_M, RST ToolChangeTimer, RST ToolTurretEnable

;Set Current Turret Position
IF ToolChangeComplete_M THEN CurrentTurretPosition_W = RequestedTurretPosition_W

;==============================================================================
                        MonitorIndexATCRequestStage
;==============================================================================
IF SkinATCIndexMinus_M THEN (ATCIndexMinusPD)
IF (ATCIndexMinusPD && !DoingIndex_M) && (!SV_PROGRAM_RUNNING ||(SV_MDI_MODE && 
  SV_PROGRAM_RUNNING && !DoingM6_M)) 
  THEN SET DoingIndexMinus_M, SET DoingIndex_M, SET RequestedBinPositionStage  

IF SkinATCIndexPlus_M THEN (ATCIndexPlusPD)  
IF (ATCIndexPlusPD && !DoingIndex_M) && (!SV_PROGRAM_RUNNING ||(SV_MDI_MODE && 
  SV_PROGRAM_RUNNING && !DoingM6_M)) 
  THEN SET DoingIndexPlus_M, SET DoingIndex_M, SET RequestedBinPositionStage

IF (ATCIndexMinusPD || ATCIndexPlusPD) && M6
  THEN InfoMsg_W = MANUAL_INDEX_WHILE_ATC_MSG, RST DoingIndex_M   

IF M6 && !DoingIndex_M 
  THEN (M6PD)
  
IF M6 && (DoingIndexMinus_M || DoingIndexPlus_M)
  THEN RST M6, InfoMsg_W = ATC_WHILE_MANUAL_INDEX_MSG 
  
IF M6PD THEN SET DoingM6_M, SET RequestedBinPositionStage

;==============================================================================
                         ReportCarouselPositionStage
;==============================================================================
IF (ATC_CarouselForward || ATC_CarouselReverse) && !ATC_ToolCounter THEN SET ToolCounterArmed_M
IF (ATC_CarouselForward || ATC_CarouselReverse) && ATC_ToolCounter && ToolCounterArmed_M 
  THEN (ToolCounterPD), RST ToolCounterArmed_M

;Skip Count if Turret direction was reversed
;IF ToolCounterPD && (ATC_CarouselForward && (LastCarouselDir_W == 1)) ||
;  (ATC_CarouselReverse && LastCarouselDir_W == 0)
;  THEN RST CarouselReversed_M
;
;IF ToolCounterPD && (ATC_CarouselForward && (LastCarouselDir_W != 1)) ||
;  (ATC_CarouselReverse && LastCarouselDir_W != 0)
;  THEN SET CarouselReversed_M 
IF True THEN RST CarouselReversed_M

IF ToolCounterPD && ATC_CarouselForward THEN LastCarouselDir_W = 1   
IF ToolCounterPD && ATC_CarouselReverse THEN LastCarouselDir_W = 0
  
IF ToolCounterPD && ATC_CarouselForward && !CarouselReversed_M
  THEN CurrentCarouselPosition_W = CurrentCarouselPosition_W + 1
IF ToolCounterPD && ATC_CarouselReverse && !CarouselReversed_M 
  THEN CurrentCarouselPosition_W = CurrentCarouselPosition_W - 1

IF CurrentCarouselPosition_W > SV_MACHINE_PARAMETER_161 THEN CurrentCarouselPosition_W = 1  
IF CurrentCarouselPosition_W < 1 THEN CurrentCarouselPosition_W = SV_MACHINE_PARAMETER_161

IF M18 THEN CurrentCarouselPosition_W = 1, RequestedCarouselPosition_W = 1, PutBackPosition_W = 1
IF !SV_PROGRAM_RUNNING THEN RST M18, RST DoingM18_M

IF True THEN SV_PLC_CAROUSEL_POSITION = CurrentCarouselPosition_W

;==============================================================================
                       RequestedBinPositionStage
;==============================================================================
IF DoingIndexPlus_M THEN RequestedCarouselPosition_W = CurrentCarouselPosition_W + 1 
IF DoingIndexMinus_M THEN RequestedCarouselPosition_W = CurrentCarouselPosition_W - 1
IF DoingIndex_M && (RequestedCarouselPosition_W > SV_MACHINE_PARAMETER_161)
  THEN RequestedCarouselPosition_W = 1 
IF DoingIndex_M && (RequestedCarouselPosition_W < 1) 
  THEN RequestedCarouselPosition_W = SV_MACHINE_PARAMETER_161   

IF DoingM6_M && (CurrentCarouselPosition_W == PutBackPosition_W)   
  THEN RequestedCarouselPosition_W = SV_TOOL_NUMBER, 
  SET AtPutbackLocation_M, SET WaitingForPutbackComplete_M
  
IF PutBackPosition_W == 0 THEN RST WaitingForPutbackComplete_M  
  
IF DoingM6_M && (CurrentCarouselPosition_W != PutBackPosition_W) &&
  ((PutBackPosition_W != 0) && DoingM6_M) 
  THEN RequestedCarouselPosition_W = PutBackPosition_W, SET DoingPutback_M

IF True THEN RST DoingIndexMinus_M, RST DoingIndexPlus_M, JMP CarouselDirectionStage

;==============================================================================
                        CarouselDirectionStage
;==============================================================================

;CW 1-2-3
IF ((RequestedCarouselPosition_W > CurrentCarouselPosition_W) && 
 (RequestedCarouselPosition_W - CurrentCarouselPosition_W <= (SV_MACHINE_PARAMETER_161 / 2))) ||
 ((RequestedCarouselPosition_W < CurrentCarouselPosition_W) &&
 (CurrentCarouselPosition_W - RequestedCarouselPosition_W > (SV_MACHINE_PARAMETER_161 / 2)))
 THEN RST CarouselCCW_M

;CCW 3-2-1
IF M18 || (((RequestedCarouselPosition_W < CurrentCarouselPosition_W) && 
 (CurrentCarouselPosition_W - RequestedCarouselPosition_W <= (SV_MACHINE_PARAMETER_161 / 2))) ||
 ((RequestedCarouselPosition_W > CurrentCarouselPosition_W) &&
 (RequestedCarouselPosition_W - CurrentCarouselPosition_W > (SV_MACHINE_PARAMETER_161 / 2))))
 THEN SET CarouselCCW_M
 
IF True THEN JMP RotateCarouselStage

;==============================================================================
                             RotateCarouselStage
;==============================================================================
IF (DoingM6_M || DoingIndex_M) && (RequestedCarouselPosition_W != CurrentCarouselPosition_W) &&
  !WaitingForPutbackComplete_M && !CarouselCCW_M
  THEN SET ATC_CarouselForward, RST ATC_CarouselReverse
  
IF (DoingM6_M || DoingIndex_M) && (RequestedCarouselPosition_W != CurrentCarouselPosition_W) &&
  !WaitingForPutbackComplete_M && CarouselCCW_M
  THEN SET ATC_CarouselReverse, RST ATC_CarouselForward
  
IF DoingPutback_M && (ATC_CarouselForward || ATC_CarouselReverse) THEN SET WaitingForPutbackComplete_M
IF PutbackComplete_SV || !SV_PROGRAM_RUNNING THEN RST DoingPutback_M, RST WaitingForPutbackComplete_M  
  
IF (RequestedCarouselPosition_W == CurrentCarouselPosition_W)
  THEN RST ATC_CarouselForward, RST ATC_CarouselReverse

IF (RequestedCarouselPosition_W == CurrentCarouselPosition_W) && DoingM6_M && 
  (!ATC_CarouselForward || !ATC_CarouselReverse) && !AtPutbackLocation_M
  THEN JMP RequestedBinPositionStage
  
IF (RequestedCarouselPosition_W == CurrentCarouselPosition_W) && DoingM6_M &&  
  AtPutbackLocation_M && !AtRequestedToolLocation_M && PutbackComplete_SV
  THEN SET AtRequestedToolLocation_M, SET ToolChangeComplete_M  
  
IF ((RequestedCarouselPosition_W == CurrentCarouselPosition_W) && DoingM6_M && AtPutbackLocation_M &&
  AtRequestedToolLocation_M && ToolChangeComplete_M && !M6) || SV_STOP
  THEN RST RotateCarouselStage, RST ATC_CarouselForward, RST ATC_CarouselReverse, RST CarouselDirectionStage,
  RST RotateCarouselStage, RST RequestedBinPositionStage, RST DoingM6_M, 
  RST M6, RST AtPutbackLocation_M, RST AtRequestedToolLocation_M, 
  RST ToolChangeComplete_M, PutBackPosition_W = CurrentCarouselPosition_W

IF (RequestedCarouselPosition_W == CurrentCarouselPosition_W) && DoingIndex_M
  THEN RST DoingIndex_M  

;==============================================================================
                            ResetCarouselStage
;==============================================================================
IF SV_STOP || (!SV_PROGRAM_RUNNING && M6) 
  THEN RST DoingIndexMinus_M, RST DoingIndexPlus_M, RST DoingIndex_M,
  RST ATC_CarouselForward, RST ATC_CarouselReverse, RST CarouselDirectionStage, RST RotateCarouselStage,
  RST RequestedBinPositionStage, RST DoingM6_M, RST M6, RST AtPutbackLocation_M,
  RST AtRequestedToolLocation_M, RST ToolChangeComplete_M, RST DoingPutback_M 

IF !SV_PROGRAM_RUNNING THEN RST CarouselHomeComplete_M, RST DoingM18_M, 
  RST WaitingForPutbackComplete_M, RST PutbackComplete_SV

;==============================================================================
                                TailStockStage
;==============================================================================
IF SkinTailStock_M THEN (TailStockPD)
IF (TailStockPD && !SV_PROGRAM_RUNNING && !TailStockInOut) || (M32 && SV_PROGRAM_RUNNING)
	THEN SET TailStockInOut, SET Aux11LED
IF (TailStockPD && !SV_PROGRAM_RUNNING && TailStockInOut) || (!M32 && SV_PROGRAM_RUNNING)
	THEN RST TailStockInOut, RST Aux11LED

;IF TailOut_T THEN RST M33, RST TailOut_T ;Reset After 15 Seconds

;==============================================================================
   MessageStage
;==============================================================================
IF FaultMsg_W != 0 THEN SET ShowFaultStage
IF FaultMsg_W == 0 && ErrorMsg_W != 0 THEN SET ShowErrorStage
IF FaultMsg_W == 0 && ErrorMsg_W == 0 && InfoMsg_W != 0 THEN SET ShowInfoStage

;==============================================================================
   ShowFaultStage
;==============================================================================
IF !((FaultMsg_W % 256 == 1) || (FaultMsg_W % 256 == 2))
  THEN JMP BadMsgStage
IF True THEN MSG FaultMsg_W
IF !EStopOk || (SkinResetOkPD) THEN FaultMsg_W = 0,
                                    InfoMsg_W = MSG_CLEARED_MSG,
                                    RST ShowFaultStage

;==============================================================================
   ShowErrorStage
;==============================================================================
IF !((ErrorMsg_W % 256 == 1) || (ErrorMsg_W % 256 == 2))
  THEN JMP BadMsgStage
IF True THEN MSG ErrorMsg_W, SET MsgClear_T
IF MsgClear_T THEN ErrorMsg_W = 0,
                   RST MsgClear_T,
                   RST ShowErrorStage

;==============================================================================
   ShowInfoStage
;==============================================================================
IF !((InfoMsg_W % 256 == 1) || (InfoMsg_W % 256 == 2))
  THEN JMP BadMsgStage
IF True THEN MSG InfoMsg_W, SET MsgClear_T
IF MsgClear_T THEN InfoMsg_W = 0,
                   RST MsgClear_T,
                   RST ShowInfoStage

;=============================================================================
   BadMsgStage
;=============================================================================
IF True THEN FaultMsg_W = 0,
             ErrorMsg_W = 0,
             InfoMsg_W = BAD_MESSAGE_MSG,
             RST BadMsgStage
